{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Documentation"},{"location":"api/","text":"Introduction \u00b6 This is a reference guide for the available Core APIs. APIs expose different resources and data provided by the Core Server (Node). Based on the Core Server configuration (enabled core modules) we can configure different array of services, such as: Public REST API Webhook API Each Core server (node) has its own internal blockchain and state, meaning it may have forked or be out of sync, causing queries to fail. Monitor your node by comparing it to different public nodes, such as the official Mainnet Explorer or the Testnet Explorer to ensure you are in sync.","title":"Introduction"},{"location":"api/#introduction","text":"This is a reference guide for the available Core APIs. APIs expose different resources and data provided by the Core Server (Node). Based on the Core Server configuration (enabled core modules) we can configure different array of services, such as: Public REST API Webhook API Each Core server (node) has its own internal blockchain and state, meaning it may have forked or be out of sync, causing queries to fail. Monitor your node by comparing it to different public nodes, such as the official Mainnet Explorer or the Testnet Explorer to ensure you are in sync.","title":"Introduction"},{"location":"api/public-rest-api/getting-started/","text":"Getting Started \u00b6 All HTTP requests have to be sent with the Content-Type: application/json header. If the header is not present it will result in malformed responses or request rejections. This is the reference guide for the Public API. This API exposes all resources and data provided by an Solar Core node; and is the preferred way of interacting with the Solar Network. Note that each node has its own internal blockchain and state, meaning it may have forked or be out of sync, causing queries to fail. Monitor your node by comparing it to different public nodes, such as an official explorer to ensure you are in sync. Mainnet: https://explorer.solar.org Testnet: https://texplorer.solar.org If you have any problems or requests please open an issue . Pagination \u00b6 Requests that return multiple items will be paginated to 100 items by default. You can specify further pages with the ?page parameter. For some resources, you can also set a custom page size up to 100 with the ?limit parameter. Note that for technical reasons not all endpoints respect the ?limit parameter. Public Testing Relay \u00b6 If you are not running a relay yourself you can test API calls using: Mainnet: https://sxp.mainnet.sh Testnet: https://sxp.testnet.sh Happy developing!","title":"Getting Started"},{"location":"api/public-rest-api/getting-started/#getting-started","text":"All HTTP requests have to be sent with the Content-Type: application/json header. If the header is not present it will result in malformed responses or request rejections. This is the reference guide for the Public API. This API exposes all resources and data provided by an Solar Core node; and is the preferred way of interacting with the Solar Network. Note that each node has its own internal blockchain and state, meaning it may have forked or be out of sync, causing queries to fail. Monitor your node by comparing it to different public nodes, such as an official explorer to ensure you are in sync. Mainnet: https://explorer.solar.org Testnet: https://texplorer.solar.org If you have any problems or requests please open an issue .","title":"Getting Started"},{"location":"api/public-rest-api/getting-started/#pagination","text":"Requests that return multiple items will be paginated to 100 items by default. You can specify further pages with the ?page parameter. For some resources, you can also set a custom page size up to 100 with the ?limit parameter. Note that for technical reasons not all endpoints respect the ?limit parameter.","title":"Pagination"},{"location":"api/public-rest-api/getting-started/#public-testing-relay","text":"If you are not running a relay yourself you can test API calls using: Mainnet: https://sxp.mainnet.sh Testnet: https://sxp.testnet.sh Happy developing!","title":"Public Testing Relay"},{"location":"api/public-rest-api/modify-response/","text":"Preface \u00b6 In some cases users wants to alter existing HTTP API responses, by removing excess fields, changing content or modify result in any other way. In this chapter we will go trough process step by step and describe how to remove explorer property from the /node/configuration route accessible on GET method. { \"data\" : { \"symbol\" : \"tSXP\" , \"explorer\" : \"http://texplorer.solar.org\" , \"version\" : 30 , } } Desired response : { \"data\" : { \"symbol\" : \"tSXP\" , \"version\" : 30 , } } Process \u00b6 Get route \u00b6 First we need get existing route object that we want to modify. Be aware there can be two Server instances accessible via Identifiers.HTTP or Identifiers.HTTPS symbols. Each Server instance expose getRoute method which is used for obtaining ServerRoute . const route = this . app . get < Server > ( Identifiers . HTTP ). getRoute ( \"GET\" , \"/api/node/configuration\" ); Keep original handler \u00b6 Save the reference to existing handler. Use bind() function to bind original object which method belongs to, otherwise you will lose this reference if one is used inside the handler. const originalHandler = route . settings . handler . bind ( route . settings . bind ); Create new handler \u00b6 Replace route handler with new wrapper function. New function will call original handler and set desired property to undefined . JSON standard defined that undefined properties are not included in stringified response, which will result as removed field in response body. Finally return modified response. route . settings . handler = async ( request : Hapi.Request , h : Hapi.ResponseToolkit ) => { const response = await originalHandler ( arguments ); response . data . explorer = undefined ; return response ; }; API \u00b6 Methods \u00b6 Server.getRoute(method: string , path: string ) : ServerRoute | undefined \u00b6 Parameters : method - HTTP method eg. \"GET\", \"POST\" path - route path eg. \"/api/node/configuration\" Response : Returns ServerRoute object or undefined . Complete code sample \u00b6 // Import import Hapi from \"@hapi/hapi\" ; // Modify route const route = this . app . get < Server > ( Identifiers . HTTP ). getRoute ( \"GET\" , \"/api/node/configuration\" ); if ( route ) { const originalHandler = route . settings . handler . bind ( route . settings . bind ); route . settings . handler = async ( request : Hapi.Request , h : Hapi.ResponseToolkit ) => { const response = await originalHandler ( arguments ); response . data . explorer = undefined ; return response ; }; } Additional reading \u00b6 Hapi official documentation","title":"Modify API response"},{"location":"api/public-rest-api/modify-response/#preface","text":"In some cases users wants to alter existing HTTP API responses, by removing excess fields, changing content or modify result in any other way. In this chapter we will go trough process step by step and describe how to remove explorer property from the /node/configuration route accessible on GET method. { \"data\" : { \"symbol\" : \"tSXP\" , \"explorer\" : \"http://texplorer.solar.org\" , \"version\" : 30 , } } Desired response : { \"data\" : { \"symbol\" : \"tSXP\" , \"version\" : 30 , } }","title":"Preface"},{"location":"api/public-rest-api/modify-response/#process","text":"","title":"Process"},{"location":"api/public-rest-api/modify-response/#get-route","text":"First we need get existing route object that we want to modify. Be aware there can be two Server instances accessible via Identifiers.HTTP or Identifiers.HTTPS symbols. Each Server instance expose getRoute method which is used for obtaining ServerRoute . const route = this . app . get < Server > ( Identifiers . HTTP ). getRoute ( \"GET\" , \"/api/node/configuration\" );","title":"Get route"},{"location":"api/public-rest-api/modify-response/#keep-original-handler","text":"Save the reference to existing handler. Use bind() function to bind original object which method belongs to, otherwise you will lose this reference if one is used inside the handler. const originalHandler = route . settings . handler . bind ( route . settings . bind );","title":"Keep original handler"},{"location":"api/public-rest-api/modify-response/#create-new-handler","text":"Replace route handler with new wrapper function. New function will call original handler and set desired property to undefined . JSON standard defined that undefined properties are not included in stringified response, which will result as removed field in response body. Finally return modified response. route . settings . handler = async ( request : Hapi.Request , h : Hapi.ResponseToolkit ) => { const response = await originalHandler ( arguments ); response . data . explorer = undefined ; return response ; };","title":"Create new handler"},{"location":"api/public-rest-api/modify-response/#api","text":"","title":"API"},{"location":"api/public-rest-api/modify-response/#methods","text":"","title":"Methods"},{"location":"api/public-rest-api/modify-response/#servergetroutemethod-string-path-string-serverroute-undefined","text":"Parameters : method - HTTP method eg. \"GET\", \"POST\" path - route path eg. \"/api/node/configuration\" Response : Returns ServerRoute object or undefined .","title":"Server.getRoute(method: string, path: string) : ServerRoute | undefined"},{"location":"api/public-rest-api/modify-response/#complete-code-sample","text":"// Import import Hapi from \"@hapi/hapi\" ; // Modify route const route = this . app . get < Server > ( Identifiers . HTTP ). getRoute ( \"GET\" , \"/api/node/configuration\" ); if ( route ) { const originalHandler = route . settings . handler . bind ( route . settings . bind ); route . settings . handler = async ( request : Hapi.Request , h : Hapi.ResponseToolkit ) => { const response = await originalHandler ( arguments ); response . data . explorer = undefined ; return response ; }; }","title":"Complete code sample"},{"location":"api/public-rest-api/modify-response/#additional-reading","text":"Hapi official documentation","title":"Additional reading"},{"location":"api/public-rest-api/troubleshooting/","text":"Troubleshooting \u00b6 If you're encountering some oddities in the API, here's a list of resolutions to some of the problems you may be experiencing. Why Am I Getting a 404 Error on a Resource That Exists? \u00b6 All HTTP requests have to be sent with the Content-Type: application/json header. If the header is not present it will result in malformed responses or request rejections. Typically, this means that the node you are sending your requests to is out of sync and missing data that exists on other nodes that are in sync. To troubleshoot, ensure you're querying a node that is in sync, and third-party application restrictions are not blocking access. Querying the explorer is usually a good start. Why Am I Not Seeing All My Results? \u00b6 Most API calls accessing a list of resources (e.g., blocks and transactions) support pagination. If you're making requests and receiving an incomplete set of results, you're probably only seeing the first page. You'll need to request the remaining pages to get more results. It's important not to try to guess the format of the pagination URL. Not every API call uses the same structure. Instead, extract the pagination information from the meta field, which is sent with every request. My Node Is Running, but API Keeps Returning CONNECTION REFUSED ? \u00b6 Note that the Public API is only available after a node has fully synced. This ensures your data on the blockchain is up to date. A full sync may take up to 15h, depending on your hardware configuration and network speed. If your node is synced and you still get CONNECTION_REFUSED error, please check your firewall configuration and if needed whitelist your client.","title":"Troubleshooting"},{"location":"api/public-rest-api/troubleshooting/#troubleshooting","text":"If you're encountering some oddities in the API, here's a list of resolutions to some of the problems you may be experiencing.","title":"Troubleshooting"},{"location":"api/public-rest-api/troubleshooting/#why-am-i-getting-a-404-error-on-a-resource-that-exists","text":"All HTTP requests have to be sent with the Content-Type: application/json header. If the header is not present it will result in malformed responses or request rejections. Typically, this means that the node you are sending your requests to is out of sync and missing data that exists on other nodes that are in sync. To troubleshoot, ensure you're querying a node that is in sync, and third-party application restrictions are not blocking access. Querying the explorer is usually a good start.","title":"Why Am I Getting a 404 Error on a Resource That Exists?"},{"location":"api/public-rest-api/troubleshooting/#why-am-i-not-seeing-all-my-results","text":"Most API calls accessing a list of resources (e.g., blocks and transactions) support pagination. If you're making requests and receiving an incomplete set of results, you're probably only seeing the first page. You'll need to request the remaining pages to get more results. It's important not to try to guess the format of the pagination URL. Not every API call uses the same structure. Instead, extract the pagination information from the meta field, which is sent with every request.","title":"Why Am I Not Seeing All My Results?"},{"location":"api/public-rest-api/troubleshooting/#my-node-is-running-but-api-keeps-returning-connection-refused","text":"Note that the Public API is only available after a node has fully synced. This ensures your data on the blockchain is up to date. A full sync may take up to 15h, depending on your hardware configuration and network speed. If your node is synced and you still get CONNECTION_REFUSED error, please check your firewall configuration and if needed whitelist your client.","title":"My Node Is Running, but API Keeps Returning CONNECTION REFUSED?"},{"location":"api/public-rest-api/endpoints/blockchain/","text":"Blockchain \u00b6 Endpoints \u00b6 Request \u00b6 Blockchain GET : \"https://sxp.mainnet.sh/api/blockchain\" { \"title\" : \"Retrieve Blockchain State\" , \"description\" : \"Used to get the latest block and supply of the blockchain.\" , \"method\" : \"GET\" , \"path\" : \"/blockchain\" }","title":"Blockchain"},{"location":"api/public-rest-api/endpoints/blockchain/#blockchain","text":"","title":"Blockchain"},{"location":"api/public-rest-api/endpoints/blockchain/#endpoints","text":"","title":"Endpoints"},{"location":"api/public-rest-api/endpoints/blockchain/#request","text":"Blockchain GET : \"https://sxp.mainnet.sh/api/blockchain\" { \"title\" : \"Retrieve Blockchain State\" , \"description\" : \"Used to get the latest block and supply of the blockchain.\" , \"method\" : \"GET\" , \"path\" : \"/blockchain\" }","title":"Request"},{"location":"api/public-rest-api/endpoints/blocks/","text":"Blocks \u00b6 Blocks are added every eight seconds to the blockchain by a Delegate Node. Due to network/technical errors, a Delegate might miss a block. The time between two blocks is then 16 seconds, as the round continues to the next Delegate. All state changes to the blockchain are in the form of blocks; they contain a set of transactions and metadata. A block is rejected if one or more of the transactions is invalid; or if the metadata is invalid. Thus a block returned from the Public API is always valid. Endpoints \u00b6 GET : \"https://sxp.mainnet.sh/api/blocks\" All Retrieve First Block Retrieve Last Block Retrieve a Block List all tx's in a block GET : \"https://sxp.mainnet.sh/api/blocks?page=1&limit=100\" { \"title\" : \"List All Blocks\" , \"description\" : \"The Public API may be used to query for blocks. This dataset contains millions of blocks; thus for analytical purposes, we recommend you query the database directly.\" , \"method\" : \"GET\" , \"path\" : \"blocks\" , \"parameters\" : { \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"example\" : 100 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"transform\" : { \"type\" : \"query\" , \"description\" : \"The structure of response to be retrieved.\" , \"rules\" : [ \"nullable\" , \"boolean\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column and order by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"id\" : { \"type\" : \"query\" , \"description\" : \"The identifier of the block to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"height\" : { \"type\" : \"query\" , \"description\" : \"The height of the block to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"height.from\" : { \"type\" : \"query\" , \"description\" : \"The height from which blocks will be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"height.to\" : { \"type\" : \"query\" , \"description\" : \"The height to which blocks will be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"timestamp\" : { \"type\" : \"query\" , \"description\" : \"The timestamp of the block to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"timestamp.from\" : { \"type\" : \"query\" , \"description\" : \"The timestamp from which blocks will be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"timestamp.to\" : { \"type\" : \"query\" , \"description\" : \"The timestamp to which blocks will be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] } } } GET : \"https://sxp.mainnet.sh/api/blocks/first\" { \"title\" : \"Retrieve first block\" , \"description\" : \"Retrieve first block.\" , \"method\" : \"GET\" , \"path\" : \"blocks/first\" , \"parameters\" : { \"transform\" : { \"type\" : \"query\" , \"description\" : \"The structure of response to be retrieved.\" , \"rules\" : [ \"nullable\" , \"boolean\" ] } } } GET : \"https://sxp.mainnet.sh/api/blocks/last\" { \"title\" : \"Retrieve last block\" , \"description\" : \"Retrieve last block.\" , \"method\" : \"GET\" , \"path\" : \"blocks/last\" , \"parameters\" : { \"transform\" : { \"type\" : \"query\" , \"description\" : \"The structure of response to be retrieved.\" , \"rules\" : [ \"nullable\" , \"boolean\" ] } } } GET : \"https://sxp.mainnet.sh/api/blocks/{id|height}\" { \"title\" : \"Retrieve a block\" , \"description\" : \"Blocks may be retrieved by ID or by height. The height is an incremental integer.\" , \"method\" : \"GET\" , \"path\" : \"blocks/{id|height}\" , \"parameters\" : { \"id\" : { \"type\" : \"path\" , \"description\" : \"The identifier of the block to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"height\" : { \"type\" : \"path\" , \"description\" : \"The height of the block to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"transform\" : { \"type\" : \"query\" , \"description\" : \"The structure of response to be retrieved.\" , \"rules\" : [ \"nullable\" , \"boolean\" ] } } } GET : \"https://sxp.mainnet.sh/api/blocks/{id|height}\" { \"title\" : \"List All Transactions in a Block\" , \"description\" : \"Instead of deserializing the block's payload; you can also obtain the transactions of each block as proper transaction objects directly.\" , \"method\" : \"GET\" , \"path\" : \"blocks/{blockId|height}/transactions\" , \"parameters\" : { \"blockId\" : { \"type\" : \"path\" , \"description\" : \"The identifier of the block to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"height\" : { \"type\" : \"path\" , \"description\" : \"The height of the block to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"example\" : 100 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"transform\" : { \"type\" : \"query\" , \"description\" : \"The structure of response to be retrieved.\" , \"rules\" : [ \"nullable\" , \"boolean\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column and order by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"id\" : { \"type\" : \"query\" , \"description\" : \"The identifier of the transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"senderPublicKey\" : { \"type\" : \"query\" , \"description\" : \"The sender public key of the transactions to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"recipientId\" : { \"type\" : \"query\" , \"description\" : \"The recipient address of the transactions to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"vendorField\" : { \"type\" : \"query\" , \"description\" : \"The vendor field of the transactions to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] } } }","title":"Blocks"},{"location":"api/public-rest-api/endpoints/blocks/#blocks","text":"Blocks are added every eight seconds to the blockchain by a Delegate Node. Due to network/technical errors, a Delegate might miss a block. The time between two blocks is then 16 seconds, as the round continues to the next Delegate. All state changes to the blockchain are in the form of blocks; they contain a set of transactions and metadata. A block is rejected if one or more of the transactions is invalid; or if the metadata is invalid. Thus a block returned from the Public API is always valid.","title":"Blocks"},{"location":"api/public-rest-api/endpoints/blocks/#endpoints","text":"GET : \"https://sxp.mainnet.sh/api/blocks\" All Retrieve First Block Retrieve Last Block Retrieve a Block List all tx's in a block GET : \"https://sxp.mainnet.sh/api/blocks?page=1&limit=100\" { \"title\" : \"List All Blocks\" , \"description\" : \"The Public API may be used to query for blocks. This dataset contains millions of blocks; thus for analytical purposes, we recommend you query the database directly.\" , \"method\" : \"GET\" , \"path\" : \"blocks\" , \"parameters\" : { \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"example\" : 100 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"transform\" : { \"type\" : \"query\" , \"description\" : \"The structure of response to be retrieved.\" , \"rules\" : [ \"nullable\" , \"boolean\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column and order by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"id\" : { \"type\" : \"query\" , \"description\" : \"The identifier of the block to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"height\" : { \"type\" : \"query\" , \"description\" : \"The height of the block to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"height.from\" : { \"type\" : \"query\" , \"description\" : \"The height from which blocks will be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"height.to\" : { \"type\" : \"query\" , \"description\" : \"The height to which blocks will be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"timestamp\" : { \"type\" : \"query\" , \"description\" : \"The timestamp of the block to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"timestamp.from\" : { \"type\" : \"query\" , \"description\" : \"The timestamp from which blocks will be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"timestamp.to\" : { \"type\" : \"query\" , \"description\" : \"The timestamp to which blocks will be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] } } } GET : \"https://sxp.mainnet.sh/api/blocks/first\" { \"title\" : \"Retrieve first block\" , \"description\" : \"Retrieve first block.\" , \"method\" : \"GET\" , \"path\" : \"blocks/first\" , \"parameters\" : { \"transform\" : { \"type\" : \"query\" , \"description\" : \"The structure of response to be retrieved.\" , \"rules\" : [ \"nullable\" , \"boolean\" ] } } } GET : \"https://sxp.mainnet.sh/api/blocks/last\" { \"title\" : \"Retrieve last block\" , \"description\" : \"Retrieve last block.\" , \"method\" : \"GET\" , \"path\" : \"blocks/last\" , \"parameters\" : { \"transform\" : { \"type\" : \"query\" , \"description\" : \"The structure of response to be retrieved.\" , \"rules\" : [ \"nullable\" , \"boolean\" ] } } } GET : \"https://sxp.mainnet.sh/api/blocks/{id|height}\" { \"title\" : \"Retrieve a block\" , \"description\" : \"Blocks may be retrieved by ID or by height. The height is an incremental integer.\" , \"method\" : \"GET\" , \"path\" : \"blocks/{id|height}\" , \"parameters\" : { \"id\" : { \"type\" : \"path\" , \"description\" : \"The identifier of the block to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"height\" : { \"type\" : \"path\" , \"description\" : \"The height of the block to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"transform\" : { \"type\" : \"query\" , \"description\" : \"The structure of response to be retrieved.\" , \"rules\" : [ \"nullable\" , \"boolean\" ] } } } GET : \"https://sxp.mainnet.sh/api/blocks/{id|height}\" { \"title\" : \"List All Transactions in a Block\" , \"description\" : \"Instead of deserializing the block's payload; you can also obtain the transactions of each block as proper transaction objects directly.\" , \"method\" : \"GET\" , \"path\" : \"blocks/{blockId|height}/transactions\" , \"parameters\" : { \"blockId\" : { \"type\" : \"path\" , \"description\" : \"The identifier of the block to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"height\" : { \"type\" : \"path\" , \"description\" : \"The height of the block to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"example\" : 100 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"transform\" : { \"type\" : \"query\" , \"description\" : \"The structure of response to be retrieved.\" , \"rules\" : [ \"nullable\" , \"boolean\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column and order by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"id\" : { \"type\" : \"query\" , \"description\" : \"The identifier of the transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"senderPublicKey\" : { \"type\" : \"query\" , \"description\" : \"The sender public key of the transactions to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"recipientId\" : { \"type\" : \"query\" , \"description\" : \"The recipient address of the transactions to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"vendorField\" : { \"type\" : \"query\" , \"description\" : \"The vendor field of the transactions to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] } } }","title":"Endpoints"},{"location":"api/public-rest-api/endpoints/delegates/","text":"Delegates \u00b6 Delegates are regular wallets (addresses) which have registered themselves eligible to become a Delegate by a registration transaction . If a Delegate is among the top 53 highest voted (by staked SXP), it may run a forging Node, which produces a single block per round, awarding the Delegate with Forged SXP + any transaction fees included in that block. The forging rewards are dynamic, based on the rank in the top 53. The total block reward per round (53 blocks) is 530 SXP. Genesis Delegates are the initial, virtualized Delegates. They were not registered nor voted in, and in the SXP mainnet has been replaced by actual Delegates a long time ago. Endpoints \u00b6 GET : \"https://sxp.mainnet.sh/api/delegates\" List all Delegates Retrieve a Delegate List all voters of a Delegate List All Blocks of a Delegate GET : \"https://sxp.mainnet.sh/api/delegates?page=1&limit=100\" { \"title\" : \"List All Delegates\" , \"description\" : \"You can obtain all Delegates through this paginated API. Note that all registered Delegates are returned in this response, not just the top 53 forging Delegates.\\nIf a Delegate Node is offline, it is still returned through this API; as the `delegate` resource is not concerned with the actual nodes, only with the on-chain registrations and wallets.\" , \"method\" : \"GET\" , \"path\" : \"delegates\" , \"parameters\" : { \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"example\" : 100 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column and order by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"username\" : { \"type\" : \"query\" , \"description\" : \"The username of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"address\" : { \"type\" : \"query\" , \"description\" : \"The address of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"publicKey\" : { \"type\" : \"query\" , \"description\" : \"The public key of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"votes\" : { \"type\" : \"query\" , \"description\" : \"The votes of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"votes.from \" : { \"type\" : \"query\" , \"description\" : \"The minimum votes of the delegates to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"votes.to \" : { \"type\" : \"query\" , \"description\" : \"The maximum votes of the delegates to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"isResigned\" : { \"type\" : \"query\" , \"description\" : \"The resignation status of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"boolean\" ] }, \"blocks.produced\" : { \"type\" : \"query\" , \"description\" : \"The number of produced blocks of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"blocks.produced.from\" : { \"type\" : \"query\" , \"description\" : \"The minimum number of produced blocks of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"blocks.produced.to\" : { \"type\" : \"query\" , \"description\" : \"The minimum number of produced blocks of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"blocks.last.id\" : { \"type\" : \"query\" , \"description\" : \"The last produced block id of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"blocks.last.height\" : { \"type\" : \"query\" , \"description\" : \"The last produced block height of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"blocks.last.timestamp.epoch\" : { \"type\" : \"query\" , \"description\" : \"The last produced block epoch timestamp of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"blocks.last.timestamp.epoch.from\" : { \"type\" : \"query\" , \"description\" : \"The minimum last produced block epoch timestamp of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"blocks.last.timestamp.epoch.to\" : { \"type\" : \"query\" , \"description\" : \"The maximum last produced block epoch timestamp of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"blocks.last.timestamp.unix\" : { \"type\" : \"query\" , \"description\" : \"The last produced block unix timestamp of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"blocks.last.timestamp.unix.from\" : { \"type\" : \"query\" , \"description\" : \"The minimum last produced unix epoch timestamp of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"blocks.last.timestamp.unix.to\" : { \"type\" : \"query\" , \"description\" : \"The maximum last produced unix epoch timestamp of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"blocks.last.timestamp.human\" : { \"type\" : \"query\" , \"description\" : \"The last produced block timestamp of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"production.approval\" : { \"type\" : \"query\" , \"description\" : \"The production approval rate of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"production.approval.from\" : { \"type\" : \"query\" , \"description\" : \"The minimum production approval rate of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"production.approval.to\" : { \"type\" : \"query\" , \"description\" : \"The maximum production approval rate of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"forged.fess\" : { \"type\" : \"query\" , \"description\" : \"The forged fees of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"forged.fess.from\" : { \"type\" : \"query\" , \"description\" : \"The minimum forged fees of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"forged.fess.to\" : { \"type\" : \"query\" , \"description\" : \"The maximum forged fees of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"forged.rewards\" : { \"type\" : \"query\" , \"description\" : \"The forged rewards of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"forged.rewards.from\" : { \"type\" : \"query\" , \"description\" : \"The minimum forged rewards of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"forged.rewards.to\" : { \"type\" : \"query\" , \"description\" : \"The maximum forged rewards of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"forged.total\" : { \"type\" : \"query\" , \"description\" : \"The forged fees and rewards of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"forged.total.from\" : { \"type\" : \"query\" , \"description\" : \"The minimum forged fees and rewards of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"forged.total.to\" : { \"type\" : \"query\" , \"description\" : \"The maximum forged fees and rewards of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] } } } GET : \"https://sxp.mainnet.sh/api/delegates/1\" { \"title\" : \"Retrieve a Delegate\" , \"description\" : \"You can query for a specific delegate by username, address, and public key; thus the following queries will result in an identical response. Note that public keys are always known for delegates, as they have previously transmitted a registration transaction. This is not the case for regular wallets.\" , \"method\" : \"GET\" , \"path\" : \"delegates/{username|address|publicKey}\" , \"parameters\" : { \"address\" : { \"type\" : \"path\" , \"description\" : \"The address of the delegate to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"string\" ] }, \"publicKey\" : { \"type\" : \"path\" , \"description\" : \"The public key of the delegate to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"string\" ] }, \"username\" : { \"type\" : \"path\" , \"description\" : \"The username of the delegate to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"string\" ] } } } GET : \"https://sxp.mainnet.sh/api/delegates/1/voters?page=1\" { \"title\" : \"List All Voters of a Delegate\" , \"description\" : \"Obtaining the voters of a Delegate is trivial as well. This endpoint returns **active** voters. To acquire historical voters, it is better to query the database directly.\" , \"method\" : \"GET\" , \"path\" : \"delegates/{delegateUsername|delegateAddress|delegatePublicKey}/voters\" , \"parameters\" : { \"delegateAddress\" : { \"type\" : \"path\" , \"description\" : \"The address of the delegate to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"string\" ] }, \"delegatePublicKey\" : { \"type\" : \"path\" , \"description\" : \"The public key of the delegate to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"string\" ] }, \"delegateUsername\" : { \"type\" : \"path\" , \"description\" : \"The username of the delegate to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"string\" ] }, \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column and order by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"address\" : { \"type\" : \"path\" , \"description\" : \"The address of the voter to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"publicKey\" : { \"type\" : \"path\" , \"description\" : \"The public key of the voter to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"balance\" : { \"type\" : \"path\" , \"description\" : \"The balance of the voter to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"balance.from\" : { \"type\" : \"path\" , \"description\" : \"The minimum balance of the voter to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"balance.to\" : { \"type\" : \"path\" , \"description\" : \"The maximum balance of the voter to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"nonce\" : { \"type\" : \"path\" , \"description\" : \"The nonce of the voter to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"nonce.from\" : { \"type\" : \"path\" , \"description\" : \"The minimum nonce of the voter to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"nonce.to\" : { \"type\" : \"path\" , \"description\" : \"The maximum nonce of the voter to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] } } } GET : \"https://sxp.mainnet.sh/api/delegates/1/blocks?page=1&limit=100\" { \"title\" : \"List All Blocks of a Delegate\" , \"description\" : \"The `delegate` resource allows you to obtain blocks from a specific Delegate. This is the equivalent of [searching for blocks](https://github.com/ArkEcosystem/gitbooks-api/tree/9815499ca52e615b8de858160da915cd960e6ea3/api/public/v2/blocks.html#search-all-blocks) using the `generatorPublicKey`.\" , \"method\" : \"GET\" , \"path\" : \"delegates/{delegateUsername|delegateAddress|delegatePublicKey}/blocks\" , \"parameters\" : { \"delegateAddress\" : { \"type\" : \"path\" , \"description\" : \"The address of the delegate to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"string\" ] }, \"delegatePublicKey\" : { \"type\" : \"path\" , \"description\" : \"The public key of the delegate to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"string\" ] }, \"delegateUsername\" : { \"type\" : \"path\" , \"description\" : \"The username of the delegate to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"string\" ] }, \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"example\" : 100 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"transform\" : { \"type\" : \"query\" , \"description\" : \"The structure of response to be retrieved.\" , \"rules\" : [ \"nullable\" , \"boolean\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column and order by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] } } }","title":"Delegates"},{"location":"api/public-rest-api/endpoints/delegates/#delegates","text":"Delegates are regular wallets (addresses) which have registered themselves eligible to become a Delegate by a registration transaction . If a Delegate is among the top 53 highest voted (by staked SXP), it may run a forging Node, which produces a single block per round, awarding the Delegate with Forged SXP + any transaction fees included in that block. The forging rewards are dynamic, based on the rank in the top 53. The total block reward per round (53 blocks) is 530 SXP. Genesis Delegates are the initial, virtualized Delegates. They were not registered nor voted in, and in the SXP mainnet has been replaced by actual Delegates a long time ago.","title":"Delegates"},{"location":"api/public-rest-api/endpoints/delegates/#endpoints","text":"GET : \"https://sxp.mainnet.sh/api/delegates\" List all Delegates Retrieve a Delegate List all voters of a Delegate List All Blocks of a Delegate GET : \"https://sxp.mainnet.sh/api/delegates?page=1&limit=100\" { \"title\" : \"List All Delegates\" , \"description\" : \"You can obtain all Delegates through this paginated API. Note that all registered Delegates are returned in this response, not just the top 53 forging Delegates.\\nIf a Delegate Node is offline, it is still returned through this API; as the `delegate` resource is not concerned with the actual nodes, only with the on-chain registrations and wallets.\" , \"method\" : \"GET\" , \"path\" : \"delegates\" , \"parameters\" : { \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"example\" : 100 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column and order by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"username\" : { \"type\" : \"query\" , \"description\" : \"The username of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"address\" : { \"type\" : \"query\" , \"description\" : \"The address of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"publicKey\" : { \"type\" : \"query\" , \"description\" : \"The public key of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"votes\" : { \"type\" : \"query\" , \"description\" : \"The votes of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"votes.from \" : { \"type\" : \"query\" , \"description\" : \"The minimum votes of the delegates to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"votes.to \" : { \"type\" : \"query\" , \"description\" : \"The maximum votes of the delegates to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"isResigned\" : { \"type\" : \"query\" , \"description\" : \"The resignation status of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"boolean\" ] }, \"blocks.produced\" : { \"type\" : \"query\" , \"description\" : \"The number of produced blocks of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"blocks.produced.from\" : { \"type\" : \"query\" , \"description\" : \"The minimum number of produced blocks of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"blocks.produced.to\" : { \"type\" : \"query\" , \"description\" : \"The minimum number of produced blocks of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"blocks.last.id\" : { \"type\" : \"query\" , \"description\" : \"The last produced block id of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"blocks.last.height\" : { \"type\" : \"query\" , \"description\" : \"The last produced block height of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"blocks.last.timestamp.epoch\" : { \"type\" : \"query\" , \"description\" : \"The last produced block epoch timestamp of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"blocks.last.timestamp.epoch.from\" : { \"type\" : \"query\" , \"description\" : \"The minimum last produced block epoch timestamp of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"blocks.last.timestamp.epoch.to\" : { \"type\" : \"query\" , \"description\" : \"The maximum last produced block epoch timestamp of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"blocks.last.timestamp.unix\" : { \"type\" : \"query\" , \"description\" : \"The last produced block unix timestamp of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"blocks.last.timestamp.unix.from\" : { \"type\" : \"query\" , \"description\" : \"The minimum last produced unix epoch timestamp of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"blocks.last.timestamp.unix.to\" : { \"type\" : \"query\" , \"description\" : \"The maximum last produced unix epoch timestamp of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"blocks.last.timestamp.human\" : { \"type\" : \"query\" , \"description\" : \"The last produced block timestamp of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"production.approval\" : { \"type\" : \"query\" , \"description\" : \"The production approval rate of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"production.approval.from\" : { \"type\" : \"query\" , \"description\" : \"The minimum production approval rate of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"production.approval.to\" : { \"type\" : \"query\" , \"description\" : \"The maximum production approval rate of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"forged.fess\" : { \"type\" : \"query\" , \"description\" : \"The forged fees of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"forged.fess.from\" : { \"type\" : \"query\" , \"description\" : \"The minimum forged fees of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"forged.fess.to\" : { \"type\" : \"query\" , \"description\" : \"The maximum forged fees of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"forged.rewards\" : { \"type\" : \"query\" , \"description\" : \"The forged rewards of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"forged.rewards.from\" : { \"type\" : \"query\" , \"description\" : \"The minimum forged rewards of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"forged.rewards.to\" : { \"type\" : \"query\" , \"description\" : \"The maximum forged rewards of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"forged.total\" : { \"type\" : \"query\" , \"description\" : \"The forged fees and rewards of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"forged.total.from\" : { \"type\" : \"query\" , \"description\" : \"The minimum forged fees and rewards of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"forged.total.to\" : { \"type\" : \"query\" , \"description\" : \"The maximum forged fees and rewards of the delegate to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] } } } GET : \"https://sxp.mainnet.sh/api/delegates/1\" { \"title\" : \"Retrieve a Delegate\" , \"description\" : \"You can query for a specific delegate by username, address, and public key; thus the following queries will result in an identical response. Note that public keys are always known for delegates, as they have previously transmitted a registration transaction. This is not the case for regular wallets.\" , \"method\" : \"GET\" , \"path\" : \"delegates/{username|address|publicKey}\" , \"parameters\" : { \"address\" : { \"type\" : \"path\" , \"description\" : \"The address of the delegate to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"string\" ] }, \"publicKey\" : { \"type\" : \"path\" , \"description\" : \"The public key of the delegate to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"string\" ] }, \"username\" : { \"type\" : \"path\" , \"description\" : \"The username of the delegate to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"string\" ] } } } GET : \"https://sxp.mainnet.sh/api/delegates/1/voters?page=1\" { \"title\" : \"List All Voters of a Delegate\" , \"description\" : \"Obtaining the voters of a Delegate is trivial as well. This endpoint returns **active** voters. To acquire historical voters, it is better to query the database directly.\" , \"method\" : \"GET\" , \"path\" : \"delegates/{delegateUsername|delegateAddress|delegatePublicKey}/voters\" , \"parameters\" : { \"delegateAddress\" : { \"type\" : \"path\" , \"description\" : \"The address of the delegate to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"string\" ] }, \"delegatePublicKey\" : { \"type\" : \"path\" , \"description\" : \"The public key of the delegate to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"string\" ] }, \"delegateUsername\" : { \"type\" : \"path\" , \"description\" : \"The username of the delegate to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"string\" ] }, \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column and order by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"address\" : { \"type\" : \"path\" , \"description\" : \"The address of the voter to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"publicKey\" : { \"type\" : \"path\" , \"description\" : \"The public key of the voter to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"balance\" : { \"type\" : \"path\" , \"description\" : \"The balance of the voter to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"balance.from\" : { \"type\" : \"path\" , \"description\" : \"The minimum balance of the voter to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"balance.to\" : { \"type\" : \"path\" , \"description\" : \"The maximum balance of the voter to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"nonce\" : { \"type\" : \"path\" , \"description\" : \"The nonce of the voter to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"nonce.from\" : { \"type\" : \"path\" , \"description\" : \"The minimum nonce of the voter to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"nonce.to\" : { \"type\" : \"path\" , \"description\" : \"The maximum nonce of the voter to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] } } } GET : \"https://sxp.mainnet.sh/api/delegates/1/blocks?page=1&limit=100\" { \"title\" : \"List All Blocks of a Delegate\" , \"description\" : \"The `delegate` resource allows you to obtain blocks from a specific Delegate. This is the equivalent of [searching for blocks](https://github.com/ArkEcosystem/gitbooks-api/tree/9815499ca52e615b8de858160da915cd960e6ea3/api/public/v2/blocks.html#search-all-blocks) using the `generatorPublicKey`.\" , \"method\" : \"GET\" , \"path\" : \"delegates/{delegateUsername|delegateAddress|delegatePublicKey}/blocks\" , \"parameters\" : { \"delegateAddress\" : { \"type\" : \"path\" , \"description\" : \"The address of the delegate to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"string\" ] }, \"delegatePublicKey\" : { \"type\" : \"path\" , \"description\" : \"The public key of the delegate to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"string\" ] }, \"delegateUsername\" : { \"type\" : \"path\" , \"description\" : \"The username of the delegate to be retrieved.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"string\" ] }, \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"example\" : 100 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"transform\" : { \"type\" : \"query\" , \"description\" : \"The structure of response to be retrieved.\" , \"rules\" : [ \"nullable\" , \"boolean\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column and order by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] } } }","title":"Endpoints"},{"location":"api/public-rest-api/endpoints/intro/","text":"Endpoints \u00b6","title":"Introduction"},{"location":"api/public-rest-api/endpoints/intro/#endpoints","text":"","title":"Endpoints"},{"location":"api/public-rest-api/endpoints/locks/","text":"Transactions \u00b6 HTLC - Hash Time-Locked Contracts transactions enable two parties to exchange tokens safely and securely at the protocol level, removing the need to trust an individual who could potentially be a bad actor and withdraw from a prior agreement once they have received their tokens. Locked funds can be transfer to another party using claim transactions, or refunded to the sender after the HTLC transaction's expiration. Endpoints \u00b6","title":"Locks"},{"location":"api/public-rest-api/endpoints/locks/#transactions","text":"HTLC - Hash Time-Locked Contracts transactions enable two parties to exchange tokens safely and securely at the protocol level, removing the need to trust an individual who could potentially be a bad actor and withdraw from a prior agreement once they have received their tokens. Locked funds can be transfer to another party using claim transactions, or refunded to the sender after the HTLC transaction's expiration.","title":"Transactions"},{"location":"api/public-rest-api/endpoints/locks/#endpoints","text":"","title":"Endpoints"},{"location":"api/public-rest-api/endpoints/node/","text":"Node \u00b6 The node resource is useful for service discovery, health checks, and obtaining network configurations, such as fees, API, and token information. Note that these parameters are returned by the specific Node and that other nodes might adhere to a different set of parameters. Endpoints \u00b6 Node Configuration \u00b6 Retrieve Node Configuration Retrieve Crypto Configuration Retrieve Fee Statistics GET : \"https://sxp.mainnet.sh/api/node/configuration\" { \"title\" : \"Retrieve the configuration\" , \"description\" : \"Used to access a Node's configuration and the network it is attached to (identified by the `nethash`).\" , \"method\" : \"GET\" , \"path\" : \"node/configuration\" } GET : \"https://sxp.mainnet.sh/api/node/configuration/crypto\" { \"title\" : \"Retrieve the Cryptography Configuration\" , \"description\" : \"Used to access a Node's configuration for the `@solar-network/crypto` package that handles all cryptography operations.\" , \"method\" : \"GET\" , \"path\" : \"node/configuration/crypto\" } GET : \"https://sxp.mainnet.sh/api/node/fees\" { \"title\" : \"Retrieve the Fee Statistics\" , \"description\" : \"Used to access a Node\u2019s fee statistics. By default, this endpoint returns calculations based on the 20 most-recent transactions for each type. Also note while using the `days` query that statistics may not be available for all transaction-types over a given period of time.\" , \"method\" : \"GET\" , \"path\" : \"node/fees\" , \"parameters\" : { \"days\" : { \"type\" : \"query\" , \"description\" : \"The number of days [1-30] to search.\" , \"rules\" : [ \"nullable\" , \"integer\" ] } } } Node Status \u00b6 Retrieve Status Retrieve Syncing Status GET : \"https://sxp.mainnet.sh/api/node/status\" { \"title\" : \"Retrieve the status\" , \"description\" : \"The status allows for health checking, showing if the node is in sync with the network.\" , \"method\" : \"GET\" , \"path\" : \"node/status\" } GET : \"https://sxp.mainnet.sh/api/node/syncing\" { \"title\" : \"Retrieve the Syncing Status\" , \"description\" : \"The `syncing` resource is very much alike `node/status`, providing information on the syncing progress. If a node is not syncing but significantly behind in blocks, it might be time to perform a check.\" , \"method\" : \"GET\" , \"path\" : \"node/syncing\" }","title":"Node"},{"location":"api/public-rest-api/endpoints/node/#node","text":"The node resource is useful for service discovery, health checks, and obtaining network configurations, such as fees, API, and token information. Note that these parameters are returned by the specific Node and that other nodes might adhere to a different set of parameters.","title":"Node"},{"location":"api/public-rest-api/endpoints/node/#endpoints","text":"","title":"Endpoints"},{"location":"api/public-rest-api/endpoints/node/#node-configuration","text":"Retrieve Node Configuration Retrieve Crypto Configuration Retrieve Fee Statistics GET : \"https://sxp.mainnet.sh/api/node/configuration\" { \"title\" : \"Retrieve the configuration\" , \"description\" : \"Used to access a Node's configuration and the network it is attached to (identified by the `nethash`).\" , \"method\" : \"GET\" , \"path\" : \"node/configuration\" } GET : \"https://sxp.mainnet.sh/api/node/configuration/crypto\" { \"title\" : \"Retrieve the Cryptography Configuration\" , \"description\" : \"Used to access a Node's configuration for the `@solar-network/crypto` package that handles all cryptography operations.\" , \"method\" : \"GET\" , \"path\" : \"node/configuration/crypto\" } GET : \"https://sxp.mainnet.sh/api/node/fees\" { \"title\" : \"Retrieve the Fee Statistics\" , \"description\" : \"Used to access a Node\u2019s fee statistics. By default, this endpoint returns calculations based on the 20 most-recent transactions for each type. Also note while using the `days` query that statistics may not be available for all transaction-types over a given period of time.\" , \"method\" : \"GET\" , \"path\" : \"node/fees\" , \"parameters\" : { \"days\" : { \"type\" : \"query\" , \"description\" : \"The number of days [1-30] to search.\" , \"rules\" : [ \"nullable\" , \"integer\" ] } } }","title":"Node Configuration"},{"location":"api/public-rest-api/endpoints/node/#node-status","text":"Retrieve Status Retrieve Syncing Status GET : \"https://sxp.mainnet.sh/api/node/status\" { \"title\" : \"Retrieve the status\" , \"description\" : \"The status allows for health checking, showing if the node is in sync with the network.\" , \"method\" : \"GET\" , \"path\" : \"node/status\" } GET : \"https://sxp.mainnet.sh/api/node/syncing\" { \"title\" : \"Retrieve the Syncing Status\" , \"description\" : \"The `syncing` resource is very much alike `node/status`, providing information on the syncing progress. If a node is not syncing but significantly behind in blocks, it might be time to perform a check.\" , \"method\" : \"GET\" , \"path\" : \"node/syncing\" }","title":"Node Status"},{"location":"api/public-rest-api/endpoints/peers/","text":"Peers \u00b6 The peers resource is much like the node resource, but only exposes the IPs and ports of connected peers. Recursively traversing this API and its responses allow you to inspect the entire network. Endpoints \u00b6 List All Peers Retrieve a Peer GET : \"https://sxp.mainnet.sh/api/peers?page=1&limit=100\" { \"title\" : \"List All Peers\" , \"description\" : \"Returns all peers known by the Node. These are not necessarily all peers; only public Nodes appear here.\" , \"method\" : \"GET\" , \"path\" : \"peers\" , \"parameters\" : { \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"example\" : 100 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"version\" : { \"type\" : \"query\" , \"description\" : \"The node version by which the resources will be filtered.\" , \"rules\" : [ \"nullable\" , \"string\" ] } } } GET : \"https://sxp.mainnet.sh/api/peers/{ip}\" { \"title\" : \"Retrieve a Peer\" , \"description\" : \"Specific peers can be found by IP address. Note that a peer may have their Public API disabled, and thus they are only reachable by the internal `p2p` API.\" , \"method\" : \"GET\" , \"path\" : \"peers/{ip}\" , \"parameters\" : { \"ip\" : { \"type\" : \"path\" , \"description\" : \"The IP address of the peer to be retrieved.\" , \"rules\" : [ \"required\" , \"integer\" ] } } }","title":"Peers"},{"location":"api/public-rest-api/endpoints/peers/#peers","text":"The peers resource is much like the node resource, but only exposes the IPs and ports of connected peers. Recursively traversing this API and its responses allow you to inspect the entire network.","title":"Peers"},{"location":"api/public-rest-api/endpoints/peers/#endpoints","text":"List All Peers Retrieve a Peer GET : \"https://sxp.mainnet.sh/api/peers?page=1&limit=100\" { \"title\" : \"List All Peers\" , \"description\" : \"Returns all peers known by the Node. These are not necessarily all peers; only public Nodes appear here.\" , \"method\" : \"GET\" , \"path\" : \"peers\" , \"parameters\" : { \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"example\" : 100 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"version\" : { \"type\" : \"query\" , \"description\" : \"The node version by which the resources will be filtered.\" , \"rules\" : [ \"nullable\" , \"string\" ] } } } GET : \"https://sxp.mainnet.sh/api/peers/{ip}\" { \"title\" : \"Retrieve a Peer\" , \"description\" : \"Specific peers can be found by IP address. Note that a peer may have their Public API disabled, and thus they are only reachable by the internal `p2p` API.\" , \"method\" : \"GET\" , \"path\" : \"peers/{ip}\" , \"parameters\" : { \"ip\" : { \"type\" : \"path\" , \"description\" : \"The IP address of the peer to be retrieved.\" , \"rules\" : [ \"required\" , \"integer\" ] } } }","title":"Endpoints"},{"location":"api/public-rest-api/endpoints/transactions/","text":"Transactions \u00b6 Transactions are signed, serialized payloads; batched together to form a block. Endpoints \u00b6 Retrieve \u00b6 List All Transactions Retrieve a Transaction GET : \"https://sxp.mainnet.sh/api/transactions?page=1&limit=100\" { \"title\" : \"List All Transactions\" , \"description\" : \"The paginated API is used to query for multiple transactions. You can apply _filters_ through the query parameter to search for specific transactions.\" , \"method\" : \"GET\" , \"path\" : \"transactions\" , \"parameters\" : { \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"example\" : 100 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"transform\" : { \"type\" : \"query\" , \"description\" : \"The structure of response to be retrieved.\" , \"rules\" : [ \"nullable\" , \"boolean\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"address\" : { \"type\" : \"query\" , \"description\" : \"The sender or recipient address of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"senderId\" : { \"type\" : \"query\" , \"description\" : \"The sender address of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"senderPublicKey\" : { \"type\" : \"query\" , \"description\" : \"The sender public key of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"recipientId\" : { \"type\" : \"query\" , \"description\" : \"The recipient address of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"id\" : { \"type\" : \"query\" , \"description\" : \"The id of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"version\" : { \"type\" : \"query\" , \"description\" : \"The version of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"blockId\" : { \"type\" : \"query\" , \"description\" : \"The block id of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"sequence\" : { \"type\" : \"query\" , \"description\" : \"The sequence of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"sequence.from\" : { \"type\" : \"query\" , \"description\" : \"The minimum sequence of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"sequence.to\" : { \"type\" : \"query\" , \"description\" : \"The maximum sequence of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"timestamp\" : { \"type\" : \"query\" , \"description\" : \"The timestamp of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"timestamp.from\" : { \"type\" : \"query\" , \"description\" : \"The minimum timestamp of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"timestamp.to\" : { \"type\" : \"query\" , \"description\" : \"The maximum timestamp of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"nonce\" : { \"type\" : \"query\" , \"description\" : \"The nonce of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"nonce.from\" : { \"type\" : \"query\" , \"description\" : \"The minimum nonce of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"nonce.to\" : { \"type\" : \"query\" , \"description\" : \"The maximum nonce of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"type\" : { \"type\" : \"query\" , \"description\" : \"The type of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"typeGroup\" : { \"type\" : \"query\" , \"description\" : \"The typeGroup of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"vendorField\" : { \"type\" : \"query\" , \"description\" : \"The vendorField of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"amount\" : { \"type\" : \"query\" , \"description\" : \"The amount of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"amount.from\" : { \"type\" : \"query\" , \"description\" : \"The minimum amount of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"amount.to\" : { \"type\" : \"query\" , \"description\" : \"The maximum amount of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"fee\" : { \"type\" : \"query\" , \"description\" : \"The fee of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"fee.from\" : { \"type\" : \"query\" , \"description\" : \"The minimum fee of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"fee.to\" : { \"type\" : \"query\" , \"description\" : \"The maximum fee of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"asset\" : { \"type\" : \"query\" , \"description\" : \"The asset of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"object\" ] } } } GET : \"https://sxp.mainnet.sh/api/transactions/{id}\" { \"title\" : \"Retrieve a Transaction\" , \"description\" : \"Obtaining a transaction by ID does not require advanced logic; as the API does not return a serialized transaction, but a nicer [DTO](https://en.wikipedia.org/wiki/Data_transfer_object).\" , \"method\" : \"GET\" , \"path\" : \"transactions/{id}\" , \"parameters\" : { \"id\" : { \"type\" : \"path\" , \"description\" : \"The identifier of the transaction to be retrieved.\" , \"rules\" : [ \"required\" , \"string\" ] } } } Unconfirmed Transactions \u00b6 List all Unconfirmed Transactions Get an Unconfirmed Transaction GET : \"https://sxp.mainnet.sh/api/transactions/unconfirmed?page=1&limit=100\" { \"title\" : \"List All Unconfirmed Transaction\" , \"description\" : \"Unconfirmed transactions have not been incorporated in the blockchain, but reside in the mempool. Although usually the mempool is cleared within minutes, during high network load a transaction with a low fee will live here for a considerable time. If you have set the transaction with a fee of near zero, it might not be picked up by a Delegate and will time out.\" , \"method\" : \"GET\" , \"path\" : \"transactions/unconfirmed\" , \"parameters\" : { \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"example\" : 100 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"transform\" : { \"type\" : \"query\" , \"description\" : \"The structure of response to be retrieved.\" , \"rules\" : [ \"nullable\" , \"boolean\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] } } } GET : \"https://sxp.mainnet.sh/api/transactions/unconfirmed/{id}\" { \"title\" : \"Get an Unconfirmed Transaction\" , \"description\" : \"As with confirmed transactions, you may query for unconfirmed transactions directly.\" , \"method\" : \"GET\" , \"path\" : \"transactions/unconfirmed/{id}\" , \"parameters\" : { \"id\" : { \"type\" : \"path\" , \"description\" : \"The identifier of the transaction to be retrieved.\" , \"rules\" : [ \"required\" , \"string\" ] } } } Broadcast \u00b6 Broadcast Transactions GET : \"https://sxp.mainnet.sh/api/transactions\" { \"title\" : \"Broadcast Transactions\" , \"description\" : \"Creating the correct payload for a transaction is non-trivial, as it requires cryptographic functions and a specific serialization protocol. Our [crypto SDKs](/docs/sdk) provide the functionality needed in most major programming languages. You can read more about it in the send transaction section.\" , \"method\" : \"POST\" , \"path\" : \"transactions\" , \"parameters\" : { \"transactions\" : { \"type\" : \"body\" , \"description\" : \"The list of transactions to broadcast.\" , \"rules\" : [ \"nullable\" , \"array\" ] } } } Fees, Types and Schemas \u00b6 Get Static Transaction Fees Get Transaction Types Get Transaction Schemas GET : \"https://sxp.mainnet.sh/api/transactions/fees\" { \"title\" : \"Get Transaction Fees (Non-Dynamic)\" , \"description\" : \"The static transaction fees are significantly higher than the dynamic transaction fees. Use the [node resource](https://github.com/ArkEcosystem/gitbooks-api/tree/9815499ca52e615b8de858160da915cd960e6ea3/api/public/v2/node.html#retrieve-the-configuration) to find dynamic fees, and prefer using these.\" , \"method\" : \"GET\" , \"path\" : \"transactions/fees\" } GET : \"https://sxp.mainnet.sh/api/transactions/types\" { \"title\" : \"Get Transaction Types\" , \"description\" : \"The transaction types are network specific. SXP currently supports eight different types, but BridgeChains may define more or less if needed for their business purpose.\" , \"method\" : \"GET\" , \"path\" : \"transactions/types\" } GET : \"https://sxp.mainnet.sh/api/transactions/schemas\" { \"title\" : \"Get Transaction Schemas\" , \"description\" : \"Get transaction schemas.\" , \"method\" : \"GET\" , \"path\" : \"transactions/schemas\" }","title":"Transactions"},{"location":"api/public-rest-api/endpoints/transactions/#transactions","text":"Transactions are signed, serialized payloads; batched together to form a block.","title":"Transactions"},{"location":"api/public-rest-api/endpoints/transactions/#endpoints","text":"","title":"Endpoints"},{"location":"api/public-rest-api/endpoints/transactions/#retrieve","text":"List All Transactions Retrieve a Transaction GET : \"https://sxp.mainnet.sh/api/transactions?page=1&limit=100\" { \"title\" : \"List All Transactions\" , \"description\" : \"The paginated API is used to query for multiple transactions. You can apply _filters_ through the query parameter to search for specific transactions.\" , \"method\" : \"GET\" , \"path\" : \"transactions\" , \"parameters\" : { \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"example\" : 100 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"transform\" : { \"type\" : \"query\" , \"description\" : \"The structure of response to be retrieved.\" , \"rules\" : [ \"nullable\" , \"boolean\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"address\" : { \"type\" : \"query\" , \"description\" : \"The sender or recipient address of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"senderId\" : { \"type\" : \"query\" , \"description\" : \"The sender address of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"senderPublicKey\" : { \"type\" : \"query\" , \"description\" : \"The sender public key of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"recipientId\" : { \"type\" : \"query\" , \"description\" : \"The recipient address of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"id\" : { \"type\" : \"query\" , \"description\" : \"The id of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"version\" : { \"type\" : \"query\" , \"description\" : \"The version of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"blockId\" : { \"type\" : \"query\" , \"description\" : \"The block id of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"sequence\" : { \"type\" : \"query\" , \"description\" : \"The sequence of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"sequence.from\" : { \"type\" : \"query\" , \"description\" : \"The minimum sequence of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"sequence.to\" : { \"type\" : \"query\" , \"description\" : \"The maximum sequence of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"timestamp\" : { \"type\" : \"query\" , \"description\" : \"The timestamp of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"timestamp.from\" : { \"type\" : \"query\" , \"description\" : \"The minimum timestamp of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"timestamp.to\" : { \"type\" : \"query\" , \"description\" : \"The maximum timestamp of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"nonce\" : { \"type\" : \"query\" , \"description\" : \"The nonce of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"nonce.from\" : { \"type\" : \"query\" , \"description\" : \"The minimum nonce of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"nonce.to\" : { \"type\" : \"query\" , \"description\" : \"The maximum nonce of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"type\" : { \"type\" : \"query\" , \"description\" : \"The type of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"typeGroup\" : { \"type\" : \"query\" , \"description\" : \"The typeGroup of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"vendorField\" : { \"type\" : \"query\" , \"description\" : \"The vendorField of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"amount\" : { \"type\" : \"query\" , \"description\" : \"The amount of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"amount.from\" : { \"type\" : \"query\" , \"description\" : \"The minimum amount of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"amount.to\" : { \"type\" : \"query\" , \"description\" : \"The maximum amount of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"fee\" : { \"type\" : \"query\" , \"description\" : \"The fee of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"fee.from\" : { \"type\" : \"query\" , \"description\" : \"The minimum fee of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"fee.to\" : { \"type\" : \"query\" , \"description\" : \"The maximum fee of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"asset\" : { \"type\" : \"query\" , \"description\" : \"The asset of transaction to be retrieved.\" , \"rules\" : [ \"nullable\" , \"object\" ] } } } GET : \"https://sxp.mainnet.sh/api/transactions/{id}\" { \"title\" : \"Retrieve a Transaction\" , \"description\" : \"Obtaining a transaction by ID does not require advanced logic; as the API does not return a serialized transaction, but a nicer [DTO](https://en.wikipedia.org/wiki/Data_transfer_object).\" , \"method\" : \"GET\" , \"path\" : \"transactions/{id}\" , \"parameters\" : { \"id\" : { \"type\" : \"path\" , \"description\" : \"The identifier of the transaction to be retrieved.\" , \"rules\" : [ \"required\" , \"string\" ] } } }","title":"Retrieve"},{"location":"api/public-rest-api/endpoints/transactions/#unconfirmed-transactions","text":"List all Unconfirmed Transactions Get an Unconfirmed Transaction GET : \"https://sxp.mainnet.sh/api/transactions/unconfirmed?page=1&limit=100\" { \"title\" : \"List All Unconfirmed Transaction\" , \"description\" : \"Unconfirmed transactions have not been incorporated in the blockchain, but reside in the mempool. Although usually the mempool is cleared within minutes, during high network load a transaction with a low fee will live here for a considerable time. If you have set the transaction with a fee of near zero, it might not be picked up by a Delegate and will time out.\" , \"method\" : \"GET\" , \"path\" : \"transactions/unconfirmed\" , \"parameters\" : { \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"example\" : 100 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"transform\" : { \"type\" : \"query\" , \"description\" : \"The structure of response to be retrieved.\" , \"rules\" : [ \"nullable\" , \"boolean\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] } } } GET : \"https://sxp.mainnet.sh/api/transactions/unconfirmed/{id}\" { \"title\" : \"Get an Unconfirmed Transaction\" , \"description\" : \"As with confirmed transactions, you may query for unconfirmed transactions directly.\" , \"method\" : \"GET\" , \"path\" : \"transactions/unconfirmed/{id}\" , \"parameters\" : { \"id\" : { \"type\" : \"path\" , \"description\" : \"The identifier of the transaction to be retrieved.\" , \"rules\" : [ \"required\" , \"string\" ] } } }","title":"Unconfirmed Transactions"},{"location":"api/public-rest-api/endpoints/transactions/#broadcast","text":"Broadcast Transactions GET : \"https://sxp.mainnet.sh/api/transactions\" { \"title\" : \"Broadcast Transactions\" , \"description\" : \"Creating the correct payload for a transaction is non-trivial, as it requires cryptographic functions and a specific serialization protocol. Our [crypto SDKs](/docs/sdk) provide the functionality needed in most major programming languages. You can read more about it in the send transaction section.\" , \"method\" : \"POST\" , \"path\" : \"transactions\" , \"parameters\" : { \"transactions\" : { \"type\" : \"body\" , \"description\" : \"The list of transactions to broadcast.\" , \"rules\" : [ \"nullable\" , \"array\" ] } } }","title":"Broadcast"},{"location":"api/public-rest-api/endpoints/transactions/#fees-types-and-schemas","text":"Get Static Transaction Fees Get Transaction Types Get Transaction Schemas GET : \"https://sxp.mainnet.sh/api/transactions/fees\" { \"title\" : \"Get Transaction Fees (Non-Dynamic)\" , \"description\" : \"The static transaction fees are significantly higher than the dynamic transaction fees. Use the [node resource](https://github.com/ArkEcosystem/gitbooks-api/tree/9815499ca52e615b8de858160da915cd960e6ea3/api/public/v2/node.html#retrieve-the-configuration) to find dynamic fees, and prefer using these.\" , \"method\" : \"GET\" , \"path\" : \"transactions/fees\" } GET : \"https://sxp.mainnet.sh/api/transactions/types\" { \"title\" : \"Get Transaction Types\" , \"description\" : \"The transaction types are network specific. SXP currently supports eight different types, but BridgeChains may define more or less if needed for their business purpose.\" , \"method\" : \"GET\" , \"path\" : \"transactions/types\" } GET : \"https://sxp.mainnet.sh/api/transactions/schemas\" { \"title\" : \"Get Transaction Schemas\" , \"description\" : \"Get transaction schemas.\" , \"method\" : \"GET\" , \"path\" : \"transactions/schemas\" }","title":"Fees, Types and Schemas"},{"location":"api/public-rest-api/endpoints/votes/","text":"Votes \u00b6 A vote is a specific type of transaction (type 3). A wallet votes on a different wallet, which has registered itself eligible to become a Delegate. Wallets may vote for themselves. Users are often confused by the voting mechanism and the fee associated with a vote. A Delegate does not receive SXP from their voters, nor is the number of blocks they produce proportional to their voting weight. Endpoints \u00b6 List all Votes Retrieve a Vote GET : \"https://sxp.mainnet.sh/api/votes?page=1&limit=100\" { \"title\" : \"List All Votes\" , \"description\" : \"All voting transactions may be obtained through this API. This is the equivalent of `transactions/search` with the body parameter `type: 3`.\" , \"method\" : \"GET\" , \"path\" : \"votes\" , \"parameters\" : { \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"example\" : 100 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"transform\" : { \"type\" : \"query\" , \"description\" : \"The structure of response to be retrieved.\" , \"rules\" : [ \"nullable\" , \"boolean\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] } } } GET : \"https://sxp.mainnet.sh/api/votes/beb8dd43c640f562704090159154b2742afba7eacada9e8edee447e34e7675c6\" { \"title\" : \"Retrieve a Vote\" , \"description\" : \"Votes may be retrieved using their transaction ID. Note the `asset` field, which contains the `votes` object. The first character of each item in the array indicates if it was a vote: `+`, or unvote: `-`, followed by the public key of the Delegate.\" , \"method\" : \"GET\" , \"path\" : \"votes/{id}\" , \"parameters\" : { \"id\" : { \"type\" : \"path\" , \"description\" : \"The identifier of the vote to be retrieved.\" , \"example\" : \"beb8dd43c640f562704090159154b2742afba7eacada9e8edee447e34e7675c6\" , \"rules\" : [ \"required\" , \"integer\" ] } } }","title":"Votes"},{"location":"api/public-rest-api/endpoints/votes/#votes","text":"A vote is a specific type of transaction (type 3). A wallet votes on a different wallet, which has registered itself eligible to become a Delegate. Wallets may vote for themselves. Users are often confused by the voting mechanism and the fee associated with a vote. A Delegate does not receive SXP from their voters, nor is the number of blocks they produce proportional to their voting weight.","title":"Votes"},{"location":"api/public-rest-api/endpoints/votes/#endpoints","text":"List all Votes Retrieve a Vote GET : \"https://sxp.mainnet.sh/api/votes?page=1&limit=100\" { \"title\" : \"List All Votes\" , \"description\" : \"All voting transactions may be obtained through this API. This is the equivalent of `transactions/search` with the body parameter `type: 3`.\" , \"method\" : \"GET\" , \"path\" : \"votes\" , \"parameters\" : { \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"example\" : 100 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"transform\" : { \"type\" : \"query\" , \"description\" : \"The structure of response to be retrieved.\" , \"rules\" : [ \"nullable\" , \"boolean\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] } } } GET : \"https://sxp.mainnet.sh/api/votes/beb8dd43c640f562704090159154b2742afba7eacada9e8edee447e34e7675c6\" { \"title\" : \"Retrieve a Vote\" , \"description\" : \"Votes may be retrieved using their transaction ID. Note the `asset` field, which contains the `votes` object. The first character of each item in the array indicates if it was a vote: `+`, or unvote: `-`, followed by the public key of the Delegate.\" , \"method\" : \"GET\" , \"path\" : \"votes/{id}\" , \"parameters\" : { \"id\" : { \"type\" : \"path\" , \"description\" : \"The identifier of the vote to be retrieved.\" , \"example\" : \"beb8dd43c640f562704090159154b2742afba7eacada9e8edee447e34e7675c6\" , \"rules\" : [ \"required\" , \"integer\" ] } } }","title":"Endpoints"},{"location":"api/public-rest-api/endpoints/wallets/","text":"Wallets \u00b6 A Wallet resource is reachable using an associated Address or PublicKey. Note that a PublicKey might not yet be associated with a Wallet if a particular Address has never sent funds. Endpoints \u00b6 Retrieve Wallet \u00b6 List All Wallets Retrieve a Wallet GET : \"https://sxp.mainnet.sh/api/wallets?page=1&limit=100\" { \"title\" : \"List All Wallets\" , \"description\" : \"A paginated API is provided to obtain all wallets, including empty ones.\" , \"method\" : \"GET\" , \"path\" : \"wallets\" , \"parameters\" : { \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"example\" : 100 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"address\" : { \"type\" : \"query\" , \"description\" : \"The address of the wallet to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"publicKey\" : { \"type\" : \"query\" , \"description\" : \"The public key of the wallet to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"balance\" : { \"type\" : \"query\" , \"description\" : \"The balance of the wallet to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"balance.from\" : { \"type\" : \"query\" , \"description\" : \"The minimum balance of the wallet to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"balance.to\" : { \"type\" : \"query\" , \"description\" : \"The maximum balance of the wallet to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"nonce\" : { \"type\" : \"query\" , \"description\" : \"The nonce of the wallet to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"nonce.from\" : { \"type\" : \"query\" , \"description\" : \"The minimum nonce of the wallet to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"nonce.to\" : { \"type\" : \"query\" , \"description\" : \"The maximum nonce of the wallet to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"attributes\" : { \"type\" : \"query\" , \"description\" : \"The attributes of the wallet to be retrieved.\" , \"rules\" : [ \"nullable\" , \"object\" ] } } } GET : \"https://sxp.mainnet.sh/api/wallets/{id}\" { \"title\" : \"Retrieve a Wallet\" , \"description\" : \"Specific wallets can be obtained either by their `publicKey` or `address`.\" , \"method\" : \"GET\" , \"path\" : \"wallets/{id}\" , \"parameters\" : { \"id\" : { \"type\" : \"path\" , \"description\" : \"The identifier of the wallet to be retrieved.\" , \"rules\" : [ \"required\" , \"string\" ] } } } Transactions Wallet \u00b6 List All Transactions of a Wallet List All Sent Transactions of a Wallet List All Received Transactions of a Wallet GET : \"https://sxp.mainnet.sh/api/wallets/{walletId}/transactions?page=1&limit=100\" { \"title\" : \"List All Transactions of a Wallet\" , \"description\" : \"All transactions belonging to a wallet can be obtained using this API. Equivalent to `/transactions` with parameter `address`.\" , \"method\" : \"GET\" , \"path\" : \"wallets/{walletId}/transactions\" , \"parameters\" : { \"walletId\" : { \"type\" : \"path\" , \"description\" : \"The identifier of the wallet to be retrieved.\" , \"rules\" : [ \"required\" , \"string\" ] }, \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"example\" : 100 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"transform\" : { \"type\" : \"query\" , \"description\" : \"The structure of response to be retrieved.\" , \"rules\" : [ \"nullable\" , \"boolean\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] } } } GET : \"https://sxp.mainnet.sh/api/wallets/{id}/transactions/sent?page=1&limit=100\" { \"title\" : \"List All Sent Transactions of a Wallet\" , \"description\" : \"Outgoing transactions can be obtained as well, Equivalent to `/transactions` with parameter `senderId` set.\\n> Note that the balance of a wallet does not equal `totalIncoming - totalOutgoing` if the wallet is a Delegate. You must then also add the total reward from transaction fees and forged blocks to their balance.\" , \"method\" : \"GET\" , \"path\" : \"wallets/{id}/transactions/sent\" , \"parameters\" : { \"id\" : { \"type\" : \"path\" , \"description\" : \"The identifier of the wallet to be retrieved.\" , \"rules\" : [ \"required\" , \"string\" ] }, \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"example\" : 100 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"transform\" : { \"type\" : \"query\" , \"description\" : \"The structure of response to be retrieved.\" , \"rules\" : [ \"nullable\" , \"boolean\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] } } } GET : \"https://sxp.mainnet.sh/api/wallets/{id}/transactions/received?page=1&limit=100\" { \"title\" : \"List All Received Transactions of a Wallet\" , \"description\" : \"Incoming transactions can be obtained as well, Equivalent to `/transactions` with parameter `recipientId` set.\" , \"method\" : \"GET\" , \"path\" : \"wallets/{id}/transactions/received\" , \"parameters\" : { \"id\" : { \"type\" : \"path\" , \"description\" : \"The identifier of the wallet to be retrieved.\" , \"rules\" : [ \"required\" , \"string\" ] }, \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"example\" : 100 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"transform\" : { \"type\" : \"query\" , \"description\" : \"The structure of response to be retrieved.\" , \"rules\" : [ \"nullable\" , \"boolean\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] } } } Votes Wallet \u00b6 List All Votes of a Wallet GET : \"https://sxp.mainnet.sh/api/wallets/{id}/votes?page=1&limit=100\" { \"title\" : \"List All Votes of a Wallet\" , \"description\" : \"Returns all votes made by the wallet. Often users create a new wallet instead of recasting their vote, as the former was historically cheaper. Equivalent to `/transactions` with parameter `senderId` and vote `type` set.\" , \"method\" : \"GET\" , \"path\" : \"wallets/{id}/votes\" , \"parameters\" : { \"id\" : { \"type\" : \"path\" , \"description\" : \"The identifier of the wallet to be retrieved.\" , \"rules\" : [ \"required\" , \"string\" ] }, \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"example\" : 100 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"transform\" : { \"type\" : \"query\" , \"description\" : \"The structure of response to be retrieved.\" , \"rules\" : [ \"nullable\" , \"boolean\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] } } } Locks Wallet \u00b6 List All Lock Transactions of a Wallet GET : \"https://sxp.mainnet.sh/api/wallets/{walletId}/locks?page=1&limit=100\" { \"title\" : \"List All Lock Transactions of a Wallet\" , \"description\" : \"All lock transactions belonging to a wallet can be obtained using this API. Equivalent to `/locks` with parameter `senderPublicKey`.\" , \"method\" : \"GET\" , \"path\" : \"wallets/{walletId}/locks\" , \"parameters\" : { \"walletId\" : { \"type\" : \"path\" , \"description\" : \"The identifier of the wallet to be retrieved.\" , \"rules\" : [ \"required\" , \"string\" ] }, \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"example\" : 100 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] } } }","title":"Wallets"},{"location":"api/public-rest-api/endpoints/wallets/#wallets","text":"A Wallet resource is reachable using an associated Address or PublicKey. Note that a PublicKey might not yet be associated with a Wallet if a particular Address has never sent funds.","title":"Wallets"},{"location":"api/public-rest-api/endpoints/wallets/#endpoints","text":"","title":"Endpoints"},{"location":"api/public-rest-api/endpoints/wallets/#retrieve-wallet","text":"List All Wallets Retrieve a Wallet GET : \"https://sxp.mainnet.sh/api/wallets?page=1&limit=100\" { \"title\" : \"List All Wallets\" , \"description\" : \"A paginated API is provided to obtain all wallets, including empty ones.\" , \"method\" : \"GET\" , \"path\" : \"wallets\" , \"parameters\" : { \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"example\" : 100 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"address\" : { \"type\" : \"query\" , \"description\" : \"The address of the wallet to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"publicKey\" : { \"type\" : \"query\" , \"description\" : \"The public key of the wallet to be retrieved.\" , \"rules\" : [ \"nullable\" , \"string\" ] }, \"balance\" : { \"type\" : \"query\" , \"description\" : \"The balance of the wallet to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"balance.from\" : { \"type\" : \"query\" , \"description\" : \"The minimum balance of the wallet to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"balance.to\" : { \"type\" : \"query\" , \"description\" : \"The maximum balance of the wallet to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"nonce\" : { \"type\" : \"query\" , \"description\" : \"The nonce of the wallet to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"nonce.from\" : { \"type\" : \"query\" , \"description\" : \"The minimum nonce of the wallet to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"nonce.to\" : { \"type\" : \"query\" , \"description\" : \"The maximum nonce of the wallet to be retrieved.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"attributes\" : { \"type\" : \"query\" , \"description\" : \"The attributes of the wallet to be retrieved.\" , \"rules\" : [ \"nullable\" , \"object\" ] } } } GET : \"https://sxp.mainnet.sh/api/wallets/{id}\" { \"title\" : \"Retrieve a Wallet\" , \"description\" : \"Specific wallets can be obtained either by their `publicKey` or `address`.\" , \"method\" : \"GET\" , \"path\" : \"wallets/{id}\" , \"parameters\" : { \"id\" : { \"type\" : \"path\" , \"description\" : \"The identifier of the wallet to be retrieved.\" , \"rules\" : [ \"required\" , \"string\" ] } } }","title":"Retrieve Wallet"},{"location":"api/public-rest-api/endpoints/wallets/#transactions-wallet","text":"List All Transactions of a Wallet List All Sent Transactions of a Wallet List All Received Transactions of a Wallet GET : \"https://sxp.mainnet.sh/api/wallets/{walletId}/transactions?page=1&limit=100\" { \"title\" : \"List All Transactions of a Wallet\" , \"description\" : \"All transactions belonging to a wallet can be obtained using this API. Equivalent to `/transactions` with parameter `address`.\" , \"method\" : \"GET\" , \"path\" : \"wallets/{walletId}/transactions\" , \"parameters\" : { \"walletId\" : { \"type\" : \"path\" , \"description\" : \"The identifier of the wallet to be retrieved.\" , \"rules\" : [ \"required\" , \"string\" ] }, \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"example\" : 100 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"transform\" : { \"type\" : \"query\" , \"description\" : \"The structure of response to be retrieved.\" , \"rules\" : [ \"nullable\" , \"boolean\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] } } } GET : \"https://sxp.mainnet.sh/api/wallets/{id}/transactions/sent?page=1&limit=100\" { \"title\" : \"List All Sent Transactions of a Wallet\" , \"description\" : \"Outgoing transactions can be obtained as well, Equivalent to `/transactions` with parameter `senderId` set.\\n> Note that the balance of a wallet does not equal `totalIncoming - totalOutgoing` if the wallet is a Delegate. You must then also add the total reward from transaction fees and forged blocks to their balance.\" , \"method\" : \"GET\" , \"path\" : \"wallets/{id}/transactions/sent\" , \"parameters\" : { \"id\" : { \"type\" : \"path\" , \"description\" : \"The identifier of the wallet to be retrieved.\" , \"rules\" : [ \"required\" , \"string\" ] }, \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"example\" : 100 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"transform\" : { \"type\" : \"query\" , \"description\" : \"The structure of response to be retrieved.\" , \"rules\" : [ \"nullable\" , \"boolean\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] } } } GET : \"https://sxp.mainnet.sh/api/wallets/{id}/transactions/received?page=1&limit=100\" { \"title\" : \"List All Received Transactions of a Wallet\" , \"description\" : \"Incoming transactions can be obtained as well, Equivalent to `/transactions` with parameter `recipientId` set.\" , \"method\" : \"GET\" , \"path\" : \"wallets/{id}/transactions/received\" , \"parameters\" : { \"id\" : { \"type\" : \"path\" , \"description\" : \"The identifier of the wallet to be retrieved.\" , \"rules\" : [ \"required\" , \"string\" ] }, \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"example\" : 100 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"transform\" : { \"type\" : \"query\" , \"description\" : \"The structure of response to be retrieved.\" , \"rules\" : [ \"nullable\" , \"boolean\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] } } }","title":"Transactions Wallet"},{"location":"api/public-rest-api/endpoints/wallets/#votes-wallet","text":"List All Votes of a Wallet GET : \"https://sxp.mainnet.sh/api/wallets/{id}/votes?page=1&limit=100\" { \"title\" : \"List All Votes of a Wallet\" , \"description\" : \"Returns all votes made by the wallet. Often users create a new wallet instead of recasting their vote, as the former was historically cheaper. Equivalent to `/transactions` with parameter `senderId` and vote `type` set.\" , \"method\" : \"GET\" , \"path\" : \"wallets/{id}/votes\" , \"parameters\" : { \"id\" : { \"type\" : \"path\" , \"description\" : \"The identifier of the wallet to be retrieved.\" , \"rules\" : [ \"required\" , \"string\" ] }, \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"example\" : 100 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"transform\" : { \"type\" : \"query\" , \"description\" : \"The structure of response to be retrieved.\" , \"rules\" : [ \"nullable\" , \"boolean\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] } } }","title":"Votes Wallet"},{"location":"api/public-rest-api/endpoints/wallets/#locks-wallet","text":"List All Lock Transactions of a Wallet GET : \"https://sxp.mainnet.sh/api/wallets/{walletId}/locks?page=1&limit=100\" { \"title\" : \"List All Lock Transactions of a Wallet\" , \"description\" : \"All lock transactions belonging to a wallet can be obtained using this API. Equivalent to `/locks` with parameter `senderPublicKey`.\" , \"method\" : \"GET\" , \"path\" : \"wallets/{walletId}/locks\" , \"parameters\" : { \"walletId\" : { \"type\" : \"path\" , \"description\" : \"The identifier of the wallet to be retrieved.\" , \"rules\" : [ \"required\" , \"string\" ] }, \"page\" : { \"type\" : \"query\" , \"description\" : \"The number of the page that will be returned.\" , \"example\" : 1 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"limit\" : { \"type\" : \"query\" , \"description\" : \"The number of resources per page.\" , \"example\" : 100 , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"offset\" : { \"type\" : \"query\" , \"description\" : \"The number of resources to be skipped.\" , \"rules\" : [ \"nullable\" , \"integer\" ] }, \"orderBy\" : { \"type\" : \"query\" , \"description\" : \"The column by which the resources will be sorted.\" , \"rules\" : [ \"nullable\" , \"string\" ] } } }","title":"Locks Wallet"},{"location":"api/webhook-api/endpoints/","text":"Endpoints \u00b6 List All Webhooks \u00b6 The webhooks resource returns all enabled and disabled webhooks. There is thus no need to store all active webhooks client side; as the node maintains a register for you. Endpoint \u00b6 GET /api/webhooks Query Parameters \u00b6 Name Type Description Required page int The number of the page that will be returned. No limit int The number of resources per page. No Response \u00b6 { \"meta\" : { \"count\" : 29 , \"pageCount\" : 1 , \"totalCount\" : 29 , \"next\" : null , \"previous\" : null , \"self\" : \"/api/v2/webhooks?page=1&limit=100\" , \"first\" : \"/api/v2/webhooks?page=1&limit=100\" , \"last\" : \"/api/v2/webhooks?page=1&limit=100\" }, \"data\" : [ { \"id\" : \"4b255244-a535-4aca-aa92-9ff9e02c98dd\" , \"event\" : \"block.forged\" , \"target\" : \"https://httpbin.org/post\" , \"enabled\" : true , \"conditions\" : [ { \"key\" : \"generatorPublicKey\" , \"condition\" : \"eq\" , \"value\" : \"032fcfd19f0e095bf46bd3ada87e283720c405249b1be1a70bad1d5f20095a8515\" } ] } ] } Retrieve a Webhook \u00b6 It is possible to query for a specific webhook by ID, which has to be saved client-side or obtained from another API call. Endpoint \u00b6 GET /api/webhooks/ { id } Path Parameters \u00b6 Name Type Description Required id string The identifier of the webhook to be retrieved. Yes Response \u00b6 { \"data\" : { \"id\" : \"4b255244-a535-4aca-aa92-9ff9e02c98dd\" , \"event\" : \"block.forged\" , \"target\" : \"https://httpbin.org/post\" , \"enabled\" : true , \"conditions\" : [ { \"key\" : \"generatorPublicKey\" , \"condition\" : \"eq\" , \"value\" : \"032fcfd19f0e095bf46bd3ada87e283720c405249b1be1a70bad1d5f20095a8515\" } ] } } Create a Webhook \u00b6 It is recommended to have a backend service running that will handle your webhook calls, as you'll have to provide a target value when creating the webhook. To give you an idea of how this works, we created a couple of example setups that you can use or get inspiration from. A webhook may be triggered by multiple conditions; as long as one of the conditions evaluates to true , the webhook will fire. The returned token should be saved and used to validate the webhook origin. It is a secret value which should not be shared. For extra security, whitelist the IP of the node with your target service, ensuring other parties are not able to post webhook payloads. The conditions lists consists of an array of objects, with the following properties: key : the key used on the object that is passed along with the specified event condition : a condition used to check the value against value : (Optional) a value used to check the key against. This is not needed for the falsy and truthy conditions. In case of between and not-between , you'll have to provide an object like this: \"value\": { \"min\": \"someValue\", \"max\": \"someValue\" } Endpoint \u00b6 POST /api/webhooks Body Parameters \u00b6 Name Type Description Required event string The name of the event to be listened for. Yes target string The target URL for the HTTP payload. Yes enabled string The value to enable or disable the webhook. No conditions array The list of conditions required to trigger the webhook. Yes Response \u00b6 { \"data\" : { \"id\" : \"4b255244-a535-4aca-aa92-9ff9e02c98dd\" , \"event\" : \"block.forged\" , \"target\" : \"https://httpbin.org/post\" , \"token\" : \"7e66949f67b36c34a05eeb3a866957b3f1b6f8947fb215500b78e5091d4e484a\" , \"enabled\" : true , \"conditions\" : [ { \"key\" : \"generatorPublicKey\" , \"condition\" : \"eq\" , \"value\" : \"032fcfd19f0e095bf46bd3ada87e283720c405249b1be1a70bad1d5f20095a8515\" } ] } } Events \u00b6 Event Description Implemented block.applied Fires when a block is saved Yes block.disregarded Fires when a block is disregarded Yes block.forged Fires when a block is forged Yes block.received Fires when a block is incoming Yes block.reverted Fires when a block is removed from the database (e.g. on a rollback) Yes delegate.registered Fires when a new delegate is registered Yes delegate.resigned Fires when a delegate resigns Yes forger.failed Fires when the forger module fails to start Yes forger.missing Fires when it is detected that the forger module isn't running Yes forger.started Fires when the forger module forges a new block No peer.added Fires when a peer is added Yes peer.removed Fires when a peer is removed Yes round.created Fires when a new round is created and saved to the database Yes state:started No transaction.applied Fires when a transaction is saved Yes transaction.expired Fires when an unconfirmed transaction expires Yes transaction.forged Fires when a transaction is forged by a delegate Yes transaction.pool.added Fires when transactions are added to the transaction pool Yes transaction.pool.rejected Fires when transactions are rejected and not added to the transaction pool Yes transaction.pool.removed Fires when a transaction is removed from the transaction pool by its ID Yes transaction.reverted Fires when a transaction is removed from the database No wallet.saved Fires when a wallet is updated (e.g. its balance changed, voted etc) Yes wallet.created.cold Fires when a wallet that never existed before is saved (e.g. received its first tx) Yes Conditions \u00b6 Condition Description between Check if the given value is between min and max contains Check if A contains B eq Check if A equals B falsy Check if the given value is false gt Check if A is greater than B gte Check if A is greater than or equal to B lt Check if A is lesser than B lte Check if A is lesser than or equal to B ne Check if A does not equal B not-between Check if the given value is not between min and max regexp Check if the given value matches truthy Check if the given value is true Update a Webhook \u00b6 Existing webhooks may be updated. Note that this is the equivalent of deleting and creating a webhook; but retaining the same token . If you are often updating and creating webhooks; consider deleting and creating new webhooks instead of updating to rotate your validation token often. Endpoint \u00b6 PUT /api/webhooks/ { id } Path Parameters \u00b6 Name Type Description Required id string The identifier of the webhook to be updated. Yes Body Parameters \u00b6 Name Type Description Required event string The name of the event to be listened for. No target string The target URL for the HTTP payload. No enabled string The value to enable or disable the webhook. No conditions array The list of conditions required to trigger the webhook. No Response \u00b6 HTTP / 1.1 204 No Content {} Delete a Webhook \u00b6 A webhook may be deleted by ID. Delete unused webhooks to save machine resources. Endpoint \u00b6 DELETE /api/webhooks/ { id } Path Parameters \u00b6 Name Type Description Required id string The identifier of the webhook to be deleted. Yes Response \u00b6 HTTP / 1.1 204 No Content {}","title":"Endpoints"},{"location":"api/webhook-api/endpoints/#endpoints","text":"","title":"Endpoints"},{"location":"api/webhook-api/endpoints/#list-all-webhooks","text":"The webhooks resource returns all enabled and disabled webhooks. There is thus no need to store all active webhooks client side; as the node maintains a register for you.","title":"List All Webhooks"},{"location":"api/webhook-api/endpoints/#endpoint","text":"GET /api/webhooks","title":"Endpoint"},{"location":"api/webhook-api/endpoints/#query-parameters","text":"Name Type Description Required page int The number of the page that will be returned. No limit int The number of resources per page. No","title":"Query Parameters"},{"location":"api/webhook-api/endpoints/#response","text":"{ \"meta\" : { \"count\" : 29 , \"pageCount\" : 1 , \"totalCount\" : 29 , \"next\" : null , \"previous\" : null , \"self\" : \"/api/v2/webhooks?page=1&limit=100\" , \"first\" : \"/api/v2/webhooks?page=1&limit=100\" , \"last\" : \"/api/v2/webhooks?page=1&limit=100\" }, \"data\" : [ { \"id\" : \"4b255244-a535-4aca-aa92-9ff9e02c98dd\" , \"event\" : \"block.forged\" , \"target\" : \"https://httpbin.org/post\" , \"enabled\" : true , \"conditions\" : [ { \"key\" : \"generatorPublicKey\" , \"condition\" : \"eq\" , \"value\" : \"032fcfd19f0e095bf46bd3ada87e283720c405249b1be1a70bad1d5f20095a8515\" } ] } ] }","title":"Response"},{"location":"api/webhook-api/endpoints/#retrieve-a-webhook","text":"It is possible to query for a specific webhook by ID, which has to be saved client-side or obtained from another API call.","title":"Retrieve a Webhook"},{"location":"api/webhook-api/endpoints/#endpoint_1","text":"GET /api/webhooks/ { id }","title":"Endpoint"},{"location":"api/webhook-api/endpoints/#path-parameters","text":"Name Type Description Required id string The identifier of the webhook to be retrieved. Yes","title":"Path Parameters"},{"location":"api/webhook-api/endpoints/#response_1","text":"{ \"data\" : { \"id\" : \"4b255244-a535-4aca-aa92-9ff9e02c98dd\" , \"event\" : \"block.forged\" , \"target\" : \"https://httpbin.org/post\" , \"enabled\" : true , \"conditions\" : [ { \"key\" : \"generatorPublicKey\" , \"condition\" : \"eq\" , \"value\" : \"032fcfd19f0e095bf46bd3ada87e283720c405249b1be1a70bad1d5f20095a8515\" } ] } }","title":"Response"},{"location":"api/webhook-api/endpoints/#create-a-webhook","text":"It is recommended to have a backend service running that will handle your webhook calls, as you'll have to provide a target value when creating the webhook. To give you an idea of how this works, we created a couple of example setups that you can use or get inspiration from. A webhook may be triggered by multiple conditions; as long as one of the conditions evaluates to true , the webhook will fire. The returned token should be saved and used to validate the webhook origin. It is a secret value which should not be shared. For extra security, whitelist the IP of the node with your target service, ensuring other parties are not able to post webhook payloads. The conditions lists consists of an array of objects, with the following properties: key : the key used on the object that is passed along with the specified event condition : a condition used to check the value against value : (Optional) a value used to check the key against. This is not needed for the falsy and truthy conditions. In case of between and not-between , you'll have to provide an object like this: \"value\": { \"min\": \"someValue\", \"max\": \"someValue\" }","title":"Create a Webhook"},{"location":"api/webhook-api/endpoints/#endpoint_2","text":"POST /api/webhooks","title":"Endpoint"},{"location":"api/webhook-api/endpoints/#body-parameters","text":"Name Type Description Required event string The name of the event to be listened for. Yes target string The target URL for the HTTP payload. Yes enabled string The value to enable or disable the webhook. No conditions array The list of conditions required to trigger the webhook. Yes","title":"Body Parameters"},{"location":"api/webhook-api/endpoints/#response_2","text":"{ \"data\" : { \"id\" : \"4b255244-a535-4aca-aa92-9ff9e02c98dd\" , \"event\" : \"block.forged\" , \"target\" : \"https://httpbin.org/post\" , \"token\" : \"7e66949f67b36c34a05eeb3a866957b3f1b6f8947fb215500b78e5091d4e484a\" , \"enabled\" : true , \"conditions\" : [ { \"key\" : \"generatorPublicKey\" , \"condition\" : \"eq\" , \"value\" : \"032fcfd19f0e095bf46bd3ada87e283720c405249b1be1a70bad1d5f20095a8515\" } ] } }","title":"Response"},{"location":"api/webhook-api/endpoints/#events","text":"Event Description Implemented block.applied Fires when a block is saved Yes block.disregarded Fires when a block is disregarded Yes block.forged Fires when a block is forged Yes block.received Fires when a block is incoming Yes block.reverted Fires when a block is removed from the database (e.g. on a rollback) Yes delegate.registered Fires when a new delegate is registered Yes delegate.resigned Fires when a delegate resigns Yes forger.failed Fires when the forger module fails to start Yes forger.missing Fires when it is detected that the forger module isn't running Yes forger.started Fires when the forger module forges a new block No peer.added Fires when a peer is added Yes peer.removed Fires when a peer is removed Yes round.created Fires when a new round is created and saved to the database Yes state:started No transaction.applied Fires when a transaction is saved Yes transaction.expired Fires when an unconfirmed transaction expires Yes transaction.forged Fires when a transaction is forged by a delegate Yes transaction.pool.added Fires when transactions are added to the transaction pool Yes transaction.pool.rejected Fires when transactions are rejected and not added to the transaction pool Yes transaction.pool.removed Fires when a transaction is removed from the transaction pool by its ID Yes transaction.reverted Fires when a transaction is removed from the database No wallet.saved Fires when a wallet is updated (e.g. its balance changed, voted etc) Yes wallet.created.cold Fires when a wallet that never existed before is saved (e.g. received its first tx) Yes","title":"Events"},{"location":"api/webhook-api/endpoints/#conditions","text":"Condition Description between Check if the given value is between min and max contains Check if A contains B eq Check if A equals B falsy Check if the given value is false gt Check if A is greater than B gte Check if A is greater than or equal to B lt Check if A is lesser than B lte Check if A is lesser than or equal to B ne Check if A does not equal B not-between Check if the given value is not between min and max regexp Check if the given value matches truthy Check if the given value is true","title":"Conditions"},{"location":"api/webhook-api/endpoints/#update-a-webhook","text":"Existing webhooks may be updated. Note that this is the equivalent of deleting and creating a webhook; but retaining the same token . If you are often updating and creating webhooks; consider deleting and creating new webhooks instead of updating to rotate your validation token often.","title":"Update a Webhook"},{"location":"api/webhook-api/endpoints/#endpoint_3","text":"PUT /api/webhooks/ { id }","title":"Endpoint"},{"location":"api/webhook-api/endpoints/#path-parameters_1","text":"Name Type Description Required id string The identifier of the webhook to be updated. Yes","title":"Path Parameters"},{"location":"api/webhook-api/endpoints/#body-parameters_1","text":"Name Type Description Required event string The name of the event to be listened for. No target string The target URL for the HTTP payload. No enabled string The value to enable or disable the webhook. No conditions array The list of conditions required to trigger the webhook. No","title":"Body Parameters"},{"location":"api/webhook-api/endpoints/#response_3","text":"HTTP / 1.1 204 No Content {}","title":"Response"},{"location":"api/webhook-api/endpoints/#delete-a-webhook","text":"A webhook may be deleted by ID. Delete unused webhooks to save machine resources.","title":"Delete a Webhook"},{"location":"api/webhook-api/endpoints/#endpoint_4","text":"DELETE /api/webhooks/ { id }","title":"Endpoint"},{"location":"api/webhook-api/endpoints/#path-parameters_2","text":"Name Type Description Required id string The identifier of the webhook to be deleted. Yes","title":"Path Parameters"},{"location":"api/webhook-api/endpoints/#response_4","text":"HTTP / 1.1 204 No Content {}","title":"Response"},{"location":"api/webhook-api/getting-started/","text":"Getting Started \u00b6 The webhooks API allows you to register a webhook in a specific node, which will send a payload to a predefined target when certain conditions are met. Webhooks ensure that you do not need to poll the public API periodically and are a robust way to stay up-to-date with the blockchain state. All HTTP requests have to be sent with the Content-Type: application/json header. If the header is not present, it will result in malformed responses or request rejections. Installation \u00b6 The webhooks API comes by default with an installation of core. In case you don't have it installed, you can add it manually by running yarn global add @solar-network/core-webhooks . Alias \u00b6 webhooks Configuration \u00b6 The webhooks API requires the following configuration in your app.json file. Make sure to have this configuration listed after @solar-network/core-blockchain . { \"package\" : \"@solar-network/core-webhooks\" }, It is recommended to make configuration changes to these options by working with your .env file and the corresponding variables: Variable Description Type Default CORE_WEBHOOKS_ENABLED Enables or disabled the webhook API plugin boolean false CORE_WEBHOOKS_HOST The host to expose the API on string \"0.0.0.0\" CORE_WEBHOOKS_PORT The API port on which the plugin will listen integer 6004 The whitelist property can be changed directly in the app.json file and is an Array consisting of IP addresses that you allow to make connections to the webhook API. By default, only local access to the webhook API is allowed. This means that if you want to expose your webhook API to the outside, you'll need to explicitly add the IP addresses that you will use to this list (recommended approach). It is also possible to use wildcards to indicate a range of IPs (e.g. \"12.34.56.*\" ) or even to allow everyone (e.g. \"*\" ) (not recommended). { \"package\" : \"@solar-network/core-webhooks\" , \"options\" : { \"server\" : { \"whitelist\" : [ \"127.0.0.1\" , \"::ffff:127.0.0.1\" ] } } }, Remember that there is no further authentication on the webhooks API itself, meaning that everyone that can access it can add, edit and delete your webhooks. Note : due to the way the CORE_WEBHOOKS_ENABLED check is implemented, you will need to remove the entry from your .env file if you want to disabled it. Setting the property to CORE_WEBHOOKS_ENABLED=false will not disable the webhooks API. Final Checks \u00b6 After making changes to the webhooks API configuration, you will need to restart your relay process for the changes to take effect. If you want to check whether your webhook API is running, you should pay attention to the startup messages in the logs of your relay. It will print a line similar to INFO : Webhook API Server running at: http://0.0.0.0:6004 when it has successfully started the webhooks API. When you see INFO : Webhooks are disabled it means the webhooks API is currently disabled.","title":"Getting Started"},{"location":"api/webhook-api/getting-started/#getting-started","text":"The webhooks API allows you to register a webhook in a specific node, which will send a payload to a predefined target when certain conditions are met. Webhooks ensure that you do not need to poll the public API periodically and are a robust way to stay up-to-date with the blockchain state. All HTTP requests have to be sent with the Content-Type: application/json header. If the header is not present, it will result in malformed responses or request rejections.","title":"Getting Started"},{"location":"api/webhook-api/getting-started/#installation","text":"The webhooks API comes by default with an installation of core. In case you don't have it installed, you can add it manually by running yarn global add @solar-network/core-webhooks .","title":"Installation"},{"location":"api/webhook-api/getting-started/#alias","text":"webhooks","title":"Alias"},{"location":"api/webhook-api/getting-started/#configuration","text":"The webhooks API requires the following configuration in your app.json file. Make sure to have this configuration listed after @solar-network/core-blockchain . { \"package\" : \"@solar-network/core-webhooks\" }, It is recommended to make configuration changes to these options by working with your .env file and the corresponding variables: Variable Description Type Default CORE_WEBHOOKS_ENABLED Enables or disabled the webhook API plugin boolean false CORE_WEBHOOKS_HOST The host to expose the API on string \"0.0.0.0\" CORE_WEBHOOKS_PORT The API port on which the plugin will listen integer 6004 The whitelist property can be changed directly in the app.json file and is an Array consisting of IP addresses that you allow to make connections to the webhook API. By default, only local access to the webhook API is allowed. This means that if you want to expose your webhook API to the outside, you'll need to explicitly add the IP addresses that you will use to this list (recommended approach). It is also possible to use wildcards to indicate a range of IPs (e.g. \"12.34.56.*\" ) or even to allow everyone (e.g. \"*\" ) (not recommended). { \"package\" : \"@solar-network/core-webhooks\" , \"options\" : { \"server\" : { \"whitelist\" : [ \"127.0.0.1\" , \"::ffff:127.0.0.1\" ] } } }, Remember that there is no further authentication on the webhooks API itself, meaning that everyone that can access it can add, edit and delete your webhooks. Note : due to the way the CORE_WEBHOOKS_ENABLED check is implemented, you will need to remove the entry from your .env file if you want to disabled it. Setting the property to CORE_WEBHOOKS_ENABLED=false will not disable the webhooks API.","title":"Configuration"},{"location":"api/webhook-api/getting-started/#final-checks","text":"After making changes to the webhooks API configuration, you will need to restart your relay process for the changes to take effect. If you want to check whether your webhook API is running, you should pay attention to the startup messages in the logs of your relay. It will print a line similar to INFO : Webhook API Server running at: http://0.0.0.0:6004 when it has successfully started the webhooks API. When you see INFO : Webhooks are disabled it means the webhooks API is currently disabled.","title":"Final Checks"},{"location":"api/webhook-api/usage/","text":"Usage \u00b6 Introduction \u00b6 With the release of Solar Core 2.0, a new feature was introduced, called Webhooks which allows you to create more flexible and automated systems while also reducing traffic/load on your server. Authorization \u00b6 Before we start working on the implementation of a webhook handler, we will take a look at handling authorization. To guarantee that only your server is allowed to send data to your webhook handler, an authorization token is generated on creation of a webhook. The generated token will only be returned once and not be visible again. To generate an authorization token, you need to create a webhook . Lets take the following token as an example fe944e318edb02b979d6bf0c87978b640c8e74e1cbfe36404386d33a5bbd8b66 which is 64 characters long and breaks down into 2 parts at 32 characters length each. The first 32 characters will be stored in the database and sent to you as a header Authorization: fe944e318edb02b979d6bf0c87978b64 via a POST request. The last 32 characters 0c8e74e1cbfe36404386d33a5bbd8b66 need to be stored by you and will serve as a way for you to verify that the request is authorized. Handling Webhooks \u00b6 Now that we know how the token is structured and what it is used for we can continue with implementing a webhook handler. A webhook handler is just a simple POST endpoint that you need to implement at the URL you specified when creating a webhook. const webhookToken = \"fe944e318edb02b979d6bf0c87978b640c8e74e1cbfe36404386d33a5bbd8b66\" ; const verification = \"0c8e74e1cbfe36404386d33a5bbd8b66\" ; server . post ( \"/blocks\" , jsonParser , ( req , res ) => { // This will be fe944e318edb02b979d6bf0c87978b64 const authorization = req . headers [ \"authorization\" ]; // This will be authorization + verification const token = authorization + verification ; // Make sure we block access if the token is invalid... if ( token !== webhookToken ) { return res . status ( 401 ). send ( \"Unauthorized!\" ); } // the datetime of when the webhook was sent console . log ( req . body . created ); // the data the webhook transferred, e.g. a block struct console . log ( req . body . data ); // the type of event that was sent, e.g. block.forged console . log ( req . body . type ); // do something with the above req.body data return res . status ( 200 ). send ( \"Hello Webhook!\" ); }); package main import ( \"fmt\" \"log\" \"net/http\" ) const ( webhookToken = \"fe944e318edb02b979d6bf0c87978b640c8e74e1cbfe36404386d33a5bbd8b66\" verification = \"0c8e74e1cbfe36404386d33a5bbd8b66\" ) func validateOrigin ( next http . Handler ) http . Handler { return func ( w http . ResponseWriter , r * http . Request ) { if r . Header . Get ( \"authorization\" ) + verification != webhookToken { w . WriteHeader ( http . StatusUnauthorized ) w . Write ([] byte ( \"Unauthorized!\" )) return } return next ( w , r ) } } func handler ( w http . ResponseWriter , r * http . Request ) { decoder := json . NewDecoder ( r . Body ) var resp Response // some defined DTO err := decoder . Decode ( & resp ) if err != nil { handle ( w , err ) } // do something with the received block/transaction/wallet } func main () { http . HandleFunc ( \"/blocks\" , validateOrigin ( handler )) log . Fatal ( http . ListenAndServe ( \":8080\" , nil )) } import pickle import hashlib from flask import Flask , request from werkzeug.exceptions import Unauthorized from functools import wraps app = Flask ( __name__ ) def dump_webhook_token ( token ): authorization = token [: 32 ] # \"fe944e318edb02b979d6bf0c87978b64\" verification = token [ 32 :] # \"0c8e74e1cbfe36404386d33a5bbd8b66\" filename = hashlib . md5 ( authorization . encode ( \"utf-8\" )) . hexdigest () with open ( filename , \"wb\" ) as out : pickle . dump ( { \"verification\" : verification , \"hash\" : hashlib . sha256 ( token . encode ( \"utf-8\" )) . hexdigest () }, out ) def check_webhook_token ( authorization ): filename = hashlib . md5 ( authorization . encode ( \"utf-8\" )) . hexdigest () try : with open ( filename , \"rb\" ) as in_ : data = pickle . load ( in_ ) except Exception : return False else : token = authorization + data [ \"verification\" ] return hashlib . sha256 ( token . encode ( \"utf-8\" ) ) . hexdigest () == data [ \"hash\" ] # ... # Somewhere On Webhook Subscription dump_webhook_token ( \"fe944e318edb02b979d6bf0c87978b640c8e74e1cbfe36404386d33a5bbd8b66\" ) # verification = \"0c8e74e1cbfe36404386d33a5bbd8b66\" # token = \"fe944e318edb02b979d6bf0c87978b640c8e74e1cbfe36404386d33a5bbd8b66\" #... # This Should Be Middleware if This App Is Dedicated to Webhooks def token_required ( f ): @wraps ( f ) def decorated_function ( * args , ** kwargs ): # if request.headers.get(\"authorization\") + verification != token: if not check_webhook_token ( request . headers . get ( \"authorization\" )): raise Unauthorized ( \"Unauthorized!\" ) return f ( * args , ** kwargs ) return decorated_function @app . route ( \"/blocks\" ) @token_required def handle_block (): block = request . get_json () # do something with the block if __name__ == \"__main__\" : app . run ( debug = True , port = 5000 ) Let's break down the steps we took here: Grab the Authorization header. Create the full token based on the Authorization header and Verification string. Deny access if the full token does not equal the webhook token . Log and process the request body if the full token is valid. Authentication \u00b6 To communicate with the Webhooks API, you will need to provide the token you configured on your node through the Authorization header. Authenticating with an invalid token will return 401 Unauthorized . Headers \u00b6 Name Type Description Required Authorization string The webhook token defined in the node configuration. Yes","title":"Usage"},{"location":"api/webhook-api/usage/#usage","text":"","title":"Usage"},{"location":"api/webhook-api/usage/#introduction","text":"With the release of Solar Core 2.0, a new feature was introduced, called Webhooks which allows you to create more flexible and automated systems while also reducing traffic/load on your server.","title":"Introduction"},{"location":"api/webhook-api/usage/#authorization","text":"Before we start working on the implementation of a webhook handler, we will take a look at handling authorization. To guarantee that only your server is allowed to send data to your webhook handler, an authorization token is generated on creation of a webhook. The generated token will only be returned once and not be visible again. To generate an authorization token, you need to create a webhook . Lets take the following token as an example fe944e318edb02b979d6bf0c87978b640c8e74e1cbfe36404386d33a5bbd8b66 which is 64 characters long and breaks down into 2 parts at 32 characters length each. The first 32 characters will be stored in the database and sent to you as a header Authorization: fe944e318edb02b979d6bf0c87978b64 via a POST request. The last 32 characters 0c8e74e1cbfe36404386d33a5bbd8b66 need to be stored by you and will serve as a way for you to verify that the request is authorized.","title":"Authorization"},{"location":"api/webhook-api/usage/#handling-webhooks","text":"Now that we know how the token is structured and what it is used for we can continue with implementing a webhook handler. A webhook handler is just a simple POST endpoint that you need to implement at the URL you specified when creating a webhook. const webhookToken = \"fe944e318edb02b979d6bf0c87978b640c8e74e1cbfe36404386d33a5bbd8b66\" ; const verification = \"0c8e74e1cbfe36404386d33a5bbd8b66\" ; server . post ( \"/blocks\" , jsonParser , ( req , res ) => { // This will be fe944e318edb02b979d6bf0c87978b64 const authorization = req . headers [ \"authorization\" ]; // This will be authorization + verification const token = authorization + verification ; // Make sure we block access if the token is invalid... if ( token !== webhookToken ) { return res . status ( 401 ). send ( \"Unauthorized!\" ); } // the datetime of when the webhook was sent console . log ( req . body . created ); // the data the webhook transferred, e.g. a block struct console . log ( req . body . data ); // the type of event that was sent, e.g. block.forged console . log ( req . body . type ); // do something with the above req.body data return res . status ( 200 ). send ( \"Hello Webhook!\" ); }); package main import ( \"fmt\" \"log\" \"net/http\" ) const ( webhookToken = \"fe944e318edb02b979d6bf0c87978b640c8e74e1cbfe36404386d33a5bbd8b66\" verification = \"0c8e74e1cbfe36404386d33a5bbd8b66\" ) func validateOrigin ( next http . Handler ) http . Handler { return func ( w http . ResponseWriter , r * http . Request ) { if r . Header . Get ( \"authorization\" ) + verification != webhookToken { w . WriteHeader ( http . StatusUnauthorized ) w . Write ([] byte ( \"Unauthorized!\" )) return } return next ( w , r ) } } func handler ( w http . ResponseWriter , r * http . Request ) { decoder := json . NewDecoder ( r . Body ) var resp Response // some defined DTO err := decoder . Decode ( & resp ) if err != nil { handle ( w , err ) } // do something with the received block/transaction/wallet } func main () { http . HandleFunc ( \"/blocks\" , validateOrigin ( handler )) log . Fatal ( http . ListenAndServe ( \":8080\" , nil )) } import pickle import hashlib from flask import Flask , request from werkzeug.exceptions import Unauthorized from functools import wraps app = Flask ( __name__ ) def dump_webhook_token ( token ): authorization = token [: 32 ] # \"fe944e318edb02b979d6bf0c87978b64\" verification = token [ 32 :] # \"0c8e74e1cbfe36404386d33a5bbd8b66\" filename = hashlib . md5 ( authorization . encode ( \"utf-8\" )) . hexdigest () with open ( filename , \"wb\" ) as out : pickle . dump ( { \"verification\" : verification , \"hash\" : hashlib . sha256 ( token . encode ( \"utf-8\" )) . hexdigest () }, out ) def check_webhook_token ( authorization ): filename = hashlib . md5 ( authorization . encode ( \"utf-8\" )) . hexdigest () try : with open ( filename , \"rb\" ) as in_ : data = pickle . load ( in_ ) except Exception : return False else : token = authorization + data [ \"verification\" ] return hashlib . sha256 ( token . encode ( \"utf-8\" ) ) . hexdigest () == data [ \"hash\" ] # ... # Somewhere On Webhook Subscription dump_webhook_token ( \"fe944e318edb02b979d6bf0c87978b640c8e74e1cbfe36404386d33a5bbd8b66\" ) # verification = \"0c8e74e1cbfe36404386d33a5bbd8b66\" # token = \"fe944e318edb02b979d6bf0c87978b640c8e74e1cbfe36404386d33a5bbd8b66\" #... # This Should Be Middleware if This App Is Dedicated to Webhooks def token_required ( f ): @wraps ( f ) def decorated_function ( * args , ** kwargs ): # if request.headers.get(\"authorization\") + verification != token: if not check_webhook_token ( request . headers . get ( \"authorization\" )): raise Unauthorized ( \"Unauthorized!\" ) return f ( * args , ** kwargs ) return decorated_function @app . route ( \"/blocks\" ) @token_required def handle_block (): block = request . get_json () # do something with the block if __name__ == \"__main__\" : app . run ( debug = True , port = 5000 ) Let's break down the steps we took here: Grab the Authorization header. Create the full token based on the Authorization header and Verification string. Deny access if the full token does not equal the webhook token . Log and process the request body if the full token is valid.","title":"Handling Webhooks"},{"location":"api/webhook-api/usage/#authentication","text":"To communicate with the Webhooks API, you will need to provide the token you configured on your node through the Authorization header. Authenticating with an invalid token will return 401 Unauthorized .","title":"Authentication"},{"location":"api/webhook-api/usage/#headers","text":"Name Type Description Required Authorization string The webhook token defined in the node configuration. Yes","title":"Headers"},{"location":"brand/intro/","text":"This page is under construction and more content will be added over time. \u00b6 The Solar Network has a specific guideline on creating and managing the brand. Click on the items below to learn more. Brand-Guidelines Download Mediakit Download Github Banners","title":"Introduction"},{"location":"brand/intro/#this-page-is-under-construction-and-more-content-will-be-added-over-time","text":"The Solar Network has a specific guideline on creating and managing the brand. Click on the items below to learn more. Brand-Guidelines Download Mediakit Download Github Banners","title":"This page is under construction and more content will be added over time."},{"location":"core/intro/","text":"Welcome to Solar Core \u00b6 Please check the core release updates in the left sidebar.","title":"Welcome to Solar Core"},{"location":"core/intro/#welcome-to-solar-core","text":"Please check the core release updates in the left sidebar.","title":"Welcome to Solar Core"},{"location":"core/transactions/lifecycle/","text":"Understanding the Transaction Lifecycle \u00b6 Describing Transaction's Journey From Client to Core Server (Blockchain) \u2705 SUCCESS - A transaction is an atomic change in the state of the blockchain. The simplest form transfers value from address A to B, incorporating a fee for the processing. Transactions are bundled into a block. At that moment they are committed to the blockchain and become irreversible. All valid transactions are begin submitted as payload data via the Public REST API . This valid transactions end as immutable history on the blockchain (are included in blocks). While the implementation specifics will depend on the platform used to submit the transaction, SXP's extensive SDK coverage ensures that developers experience a unified workflow across languages and platforms. In the next sections we will look into the transaction lifecycle from creation to final inclusion in the blocks. Transaction Journey From Client To Blockchain \u00b6 1. Create and Sign Transaction Locally \u00b6 Transactions are generated and signed locally with one of many available SDK libraries . Locally generated and signed transactions are sent as a POST request with transaction data to the Core Server node. \ud83d\uded1 DANGER - Core Server (node) will accept a valid transaction, signed with a valid signature from a private key. Make sure you invoke the SDK builder's sign method on your transaction object using the sender's private key. 2. Receive and Validate Transaction on The Core Server \u00b6 Transactions are received at the POST transactions endpoint of the Public API. From there all requests are first validated by the API endpoint schema. Each endpoint schema defines the structure that requests should conform to. Transaction flow in short: Transaction Payload is received at the Core Server ( Public API Endpoint ) API Handler validates schema and sends transaction to the TransactionProcessor TransactionProcessor performs additional transaction payload checks in relation to the blockchain protocol. If all check are valid, transaction is added to the Transaction Pool \u2705 SUCCESS - All Client SDKs already create API requests to conform to this standard, so following the SDK guidelines will typically result in your transaction passing validation. Notably, no blockchain-level validation occurs at this earliest stage in the transaction lifecycle. Request validation ensures that your POST request can be understood by the network, not that the data it contains represents a valid transaction. This task falls to the next class to handle transaction requests: the TransactionProcessor from the core-transaction-pool package. Assuming validation is successful, the posted transactions are processed by the request handler, which passes the data to the TransactionProcessor for validation. All transactions submitted to the TransactionProcessor are returned in one of four arrays : accept broadcast excess invalid Internally, the TransactionProcessor processes transactions in its validate method by separating: transactions already in the pool transactions from blocked senders transactions from the future transactions with low fees for broadcast/pool inclusion transactions that fail to conform to their transaction type \u2139\ufe0f INFO - At this point, Core Server has a list of incoming transactions to add to the transaction pool. TransactionProcessor now checks the pool to see whether it is at capacity. If so, it compares the incoming transactions against the pooled transactions and removes the transactions with the lowest fees. 3. From TransactionPool To Transaction Inclusion Within Blocks \u00b6 Transactions move out of the pool once a forging Delegate (a forger) is ready and eligible to forge it. At the moment of forging, transactions in the forger's pool are grouped into a potential block and passed to the delegate's forge method for inclusion in a block. Inside the forge method, all transaction values, fees, and IDs within the block are added together. The values and fees are used to calculate block metadata, while the hashed IDs are concatenated and used as the block's payloadHash property. With this information in hand, the block data and sorted transactions are passed to the crypto library's Block.create method alongside the forging delegate's keys. 4. Block Creation \u00b6 A block is a collection of transactions, but also it is the incremental unit of the blockchain. Every eight seconds, a Delegate Node (Forging Node) creates a new block by bundling a bunch of transactions, verifying each transaction, and signing the block. Blocks hold quite a lot of metadata on the SXP blockchain, like: Height, an incremental ID. Timestamp. Transactions. Creator's signature. Total transfer amount. Total fee amount. The Block.create method uses the following algorithm to create a new block: Derive the delegate's public key from the function's keys parameter. Create a payload hash by serializing the block data into a binary-encoded format. Create a SHA256 hash by using the payload hash as input. Sign the SHA256 hash with the delegate's private key. Create a block ID using the hashed block data. Cast the data into a Block model using the new transaction and block ID. Return the cast Block object. Here, the cryptographic functions used by SXP to generate hashes are identical to those used by Bitcoin. These functions are battle-tested by years of use and analysis in Bitcoin. Resources to learn more about the block creation process can be found in Bitcoin educational materials as well as relevant SXP documentation on serialization. 5. Block Propagation \u00b6 With the forged block successfully returned to the forger library, the only remaining responsibility is to let the network know about the new block - block propagation. The forged block is relayed to peers through the P2P layer following blockchain protocol mechanics.","title":"Transactions - Understanding the Lifecycle"},{"location":"core/transactions/lifecycle/#understanding-the-transaction-lifecycle","text":"Describing Transaction's Journey From Client to Core Server (Blockchain) \u2705 SUCCESS - A transaction is an atomic change in the state of the blockchain. The simplest form transfers value from address A to B, incorporating a fee for the processing. Transactions are bundled into a block. At that moment they are committed to the blockchain and become irreversible. All valid transactions are begin submitted as payload data via the Public REST API . This valid transactions end as immutable history on the blockchain (are included in blocks). While the implementation specifics will depend on the platform used to submit the transaction, SXP's extensive SDK coverage ensures that developers experience a unified workflow across languages and platforms. In the next sections we will look into the transaction lifecycle from creation to final inclusion in the blocks.","title":"Understanding the Transaction Lifecycle"},{"location":"core/transactions/lifecycle/#transaction-journey-from-client-to-blockchain","text":"","title":"Transaction Journey From Client To Blockchain"},{"location":"core/transactions/lifecycle/#1-create-and-sign-transaction-locally","text":"Transactions are generated and signed locally with one of many available SDK libraries . Locally generated and signed transactions are sent as a POST request with transaction data to the Core Server node. \ud83d\uded1 DANGER - Core Server (node) will accept a valid transaction, signed with a valid signature from a private key. Make sure you invoke the SDK builder's sign method on your transaction object using the sender's private key.","title":"1. Create and Sign Transaction Locally"},{"location":"core/transactions/lifecycle/#2-receive-and-validate-transaction-on-the-core-server","text":"Transactions are received at the POST transactions endpoint of the Public API. From there all requests are first validated by the API endpoint schema. Each endpoint schema defines the structure that requests should conform to. Transaction flow in short: Transaction Payload is received at the Core Server ( Public API Endpoint ) API Handler validates schema and sends transaction to the TransactionProcessor TransactionProcessor performs additional transaction payload checks in relation to the blockchain protocol. If all check are valid, transaction is added to the Transaction Pool \u2705 SUCCESS - All Client SDKs already create API requests to conform to this standard, so following the SDK guidelines will typically result in your transaction passing validation. Notably, no blockchain-level validation occurs at this earliest stage in the transaction lifecycle. Request validation ensures that your POST request can be understood by the network, not that the data it contains represents a valid transaction. This task falls to the next class to handle transaction requests: the TransactionProcessor from the core-transaction-pool package. Assuming validation is successful, the posted transactions are processed by the request handler, which passes the data to the TransactionProcessor for validation. All transactions submitted to the TransactionProcessor are returned in one of four arrays : accept broadcast excess invalid Internally, the TransactionProcessor processes transactions in its validate method by separating: transactions already in the pool transactions from blocked senders transactions from the future transactions with low fees for broadcast/pool inclusion transactions that fail to conform to their transaction type \u2139\ufe0f INFO - At this point, Core Server has a list of incoming transactions to add to the transaction pool. TransactionProcessor now checks the pool to see whether it is at capacity. If so, it compares the incoming transactions against the pooled transactions and removes the transactions with the lowest fees.","title":"2. Receive and Validate Transaction on The Core Server"},{"location":"core/transactions/lifecycle/#3-from-transactionpool-to-transaction-inclusion-within-blocks","text":"Transactions move out of the pool once a forging Delegate (a forger) is ready and eligible to forge it. At the moment of forging, transactions in the forger's pool are grouped into a potential block and passed to the delegate's forge method for inclusion in a block. Inside the forge method, all transaction values, fees, and IDs within the block are added together. The values and fees are used to calculate block metadata, while the hashed IDs are concatenated and used as the block's payloadHash property. With this information in hand, the block data and sorted transactions are passed to the crypto library's Block.create method alongside the forging delegate's keys.","title":"3. From TransactionPool To Transaction Inclusion Within Blocks"},{"location":"core/transactions/lifecycle/#4-block-creation","text":"A block is a collection of transactions, but also it is the incremental unit of the blockchain. Every eight seconds, a Delegate Node (Forging Node) creates a new block by bundling a bunch of transactions, verifying each transaction, and signing the block. Blocks hold quite a lot of metadata on the SXP blockchain, like: Height, an incremental ID. Timestamp. Transactions. Creator's signature. Total transfer amount. Total fee amount. The Block.create method uses the following algorithm to create a new block: Derive the delegate's public key from the function's keys parameter. Create a payload hash by serializing the block data into a binary-encoded format. Create a SHA256 hash by using the payload hash as input. Sign the SHA256 hash with the delegate's private key. Create a block ID using the hashed block data. Cast the data into a Block model using the new transaction and block ID. Return the cast Block object. Here, the cryptographic functions used by SXP to generate hashes are identical to those used by Bitcoin. These functions are battle-tested by years of use and analysis in Bitcoin. Resources to learn more about the block creation process can be found in Bitcoin educational materials as well as relevant SXP documentation on serialization.","title":"4. Block Creation"},{"location":"core/transactions/lifecycle/#5-block-propagation","text":"With the forged block successfully returned to the forger library, the only remaining responsibility is to let the network know about the new block - block propagation. The forged block is relayed to peers through the P2P layer following blockchain protocol mechanics.","title":"5. Block Propagation"},{"location":"core/transactions/types/burn/","text":"Burn \u00b6 TypeGroup Type 2 0 This transaction type allows burning an arbirary amount of SXP tokens. The burned amount is deducted from the sender's wallet as well as from the chain's circulating supply. References API Endpoints Link AJV Schema Base | Burn Json \u00b6 { \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 2 , \"type\" : 0 , \"nonce\" : \"12\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"0\" , \"burnedFee\" : \"0\" , \"amount\" : \"100000000\" } Serialized \u00b6 ff033f0200000000000c00000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed19200000000000000000000e1f50500000000 Deserialized \u00b6 Key Pos. Size (bytes) Value (hex) Header Flag: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x02000000 Type: [7] 2 0x0000 Nonce: [9] 8 0x0c00000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x0000000000000000 VendorField Length: [58] 1 0x00 Amount: [59] 8 0x00e1f50500000000","title":"Transaction Types - Burn"},{"location":"core/transactions/types/burn/#burn","text":"TypeGroup Type 2 0 This transaction type allows burning an arbirary amount of SXP tokens. The burned amount is deducted from the sender's wallet as well as from the chain's circulating supply. References API Endpoints Link AJV Schema Base | Burn","title":"Burn"},{"location":"core/transactions/types/burn/#json","text":"{ \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 2 , \"type\" : 0 , \"nonce\" : \"12\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"0\" , \"burnedFee\" : \"0\" , \"amount\" : \"100000000\" }","title":"Json"},{"location":"core/transactions/types/burn/#serialized","text":"ff033f0200000000000c00000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed19200000000000000000000e1f50500000000","title":"Serialized"},{"location":"core/transactions/types/burn/#deserialized","text":"Key Pos. Size (bytes) Value (hex) Header Flag: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x02000000 Type: [7] 2 0x0000 Nonce: [9] 8 0x0c00000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x0000000000000000 VendorField Length: [58] 1 0x00 Amount: [59] 8 0x00e1f50500000000","title":"Deserialized"},{"location":"core/transactions/types/delegate-registration/","text":"Delegate Registration \u00b6 TypeGroup Type 1 3 A user or organization can register their address to become a delegate and secure the network. Upon accumulating sufficient vote weight, the delegate will begin forging transactions and receiving block rewards. The delegate assigns a custom name to their address to differentiate it from other delegates. References Improvement Proposal AIP11 API Endpoints Link AJV Schema Base | Delegate Registration Transaction Structure \u00b6 Json \u00b6 { \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 1 , \"nonce\" : \"3\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"7500000000\" , \"asset\" : { \"delegate\" : { \"username\" : \"sl33p\" } } } Serialized \u00b6 ff033f0100000002000300000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed19200eb08bf010000000005736c333370 Deserialized \u00b6 Key Pos. Size (bytes) Value (hex) Header Flag: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0200 Nonce: [9] 8 0x0300000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x00eb08bf01000000 VendorField Length: [58] 1 0x00 Username Length: [59] 1 0x05 Username: [60] 5 0x736c333370","title":"Transaction Types - Delegate Registration"},{"location":"core/transactions/types/delegate-registration/#delegate-registration","text":"TypeGroup Type 1 3 A user or organization can register their address to become a delegate and secure the network. Upon accumulating sufficient vote weight, the delegate will begin forging transactions and receiving block rewards. The delegate assigns a custom name to their address to differentiate it from other delegates. References Improvement Proposal AIP11 API Endpoints Link AJV Schema Base | Delegate Registration","title":"Delegate Registration"},{"location":"core/transactions/types/delegate-registration/#transaction-structure","text":"","title":"Transaction Structure"},{"location":"core/transactions/types/delegate-registration/#json","text":"{ \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 1 , \"nonce\" : \"3\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"7500000000\" , \"asset\" : { \"delegate\" : { \"username\" : \"sl33p\" } } }","title":"Json"},{"location":"core/transactions/types/delegate-registration/#serialized","text":"ff033f0100000002000300000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed19200eb08bf010000000005736c333370","title":"Serialized"},{"location":"core/transactions/types/delegate-registration/#deserialized","text":"Key Pos. Size (bytes) Value (hex) Header Flag: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0200 Nonce: [9] 8 0x0300000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x00eb08bf01000000 VendorField Length: [58] 1 0x00 Username Length: [59] 1 0x05 Username: [60] 5 0x736c333370","title":"Deserialized"},{"location":"core/transactions/types/delegate-resignation/","text":"Delegate Resignation \u00b6 TypeGroup Type 1 7 This transaction type enables delegates to block potential voters from voting for them if they choose to withdraw their status as delegates. A non-reversible transaction can be sent to the network to indicate that the delegate should no longer be included in any future forging rounds. This transaction acts as a \"kill command\" for delegates who wish to resign or retire their delegate. Activating a delegate resignation will mean delegates will no longer be able to receive any new votes. Plus, for actively forging delegates, enabling delegate resignation will mean they permanently drop out of the top 53. This provides a clean and simple way to retire a delegate. References Improvement Proposal AIP11 , AIP29 API Endpoints Link AJV Schema Base | Delegate Resignation Transaction Structure \u00b6 Json \u00b6 { \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 1 , \"nonce\" : \"9\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"50000000\" , } Serialized \u00b6 ff033f0100000002000900000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed19280f0fa020000000000eb08bf010000000005736c333370 Deserialized \u00b6 Key Pos. Size (bytes) Value (hex) Header Flag: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0700 Nonce: [9] 8 0x0900000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x80f0fa0200000000 VendorField Length: [58] 1 0x00","title":"Transaction Types - Delegate Resignation"},{"location":"core/transactions/types/delegate-resignation/#delegate-resignation","text":"TypeGroup Type 1 7 This transaction type enables delegates to block potential voters from voting for them if they choose to withdraw their status as delegates. A non-reversible transaction can be sent to the network to indicate that the delegate should no longer be included in any future forging rounds. This transaction acts as a \"kill command\" for delegates who wish to resign or retire their delegate. Activating a delegate resignation will mean delegates will no longer be able to receive any new votes. Plus, for actively forging delegates, enabling delegate resignation will mean they permanently drop out of the top 53. This provides a clean and simple way to retire a delegate. References Improvement Proposal AIP11 , AIP29 API Endpoints Link AJV Schema Base | Delegate Resignation","title":"Delegate Resignation"},{"location":"core/transactions/types/delegate-resignation/#transaction-structure","text":"","title":"Transaction Structure"},{"location":"core/transactions/types/delegate-resignation/#json","text":"{ \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 1 , \"nonce\" : \"9\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"50000000\" , }","title":"Json"},{"location":"core/transactions/types/delegate-resignation/#serialized","text":"ff033f0100000002000900000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed19280f0fa020000000000eb08bf010000000005736c333370","title":"Serialized"},{"location":"core/transactions/types/delegate-resignation/#deserialized","text":"Key Pos. Size (bytes) Value (hex) Header Flag: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0700 Nonce: [9] 8 0x0900000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x80f0fa0200000000 VendorField Length: [58] 1 0x00","title":"Deserialized"},{"location":"core/transactions/types/htlc-claim/","text":"HTLC Claim \u00b6 TypeGroup Type 1 9 A Hashed Time-Lock Contract (HTLC) is a set of transaction types that permits a designated party (the \"sender/seller\") to LOCK funds by disclosing the preimage (secret) of a hash. It also permits a second party (the \"recipient/buyer\") to CLAIM the funds, or after a timeout is reached enter a REFUND situation. The purpose of this transaction is for the recipient to CLAIM funds from the sender - if they know the shared secret. References Improvement Proposal AIP102 API Endpoints Link AJV Schema Base | HTLC Claim JSON \u00b6 { \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 9 , \"nonce\" : \"11\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"0\" , \"asset\" : { \"claim\" : { \"lockTransactionId\" : \"3aade2b98391ba7230252530cdd5124183a9f4e582660666ae873da48173ea5f\" , \"unlockSecret\" : \"c27f1ce845d8c29eebc9006be932b604fd06755521b1a8b0be4204c65377151a\" } } } Serialized \u00b6 ff033f0100000009000b00000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192000000000000000000003aade2b98391ba7230252530cdd5124183a9f4e582660666ae873da48173ea5f20c27f1ce845d8c29eebc9006be932b604fd06755521b1a8b0be4204c65377151a Deserialized \u00b6 Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f TypeGroup: [3] 4 0x01000000 Type: [7] 2 0x0900 Nonce: [9] 8 0x0b00000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x0000000000000000 VendorField Length: [58] 1 0x00 Hash Type: [59] 1 0x00 Lock Id: [60] 32 0x3aade2b98391ba7230252530cdd5124183a9f4e582660666ae873da48173ea5f Unlock Secret Length: [92] 1 0x20 Unlock Secret: [93] 32 0xc27f1ce845d8c29eebc9006be932b604fd06755521b1a8b0be4204c65377151a Supported Hash Types \u00b6 Hash Type Value SHA256 0 SHA384 1 SHA512 2 SHA3256 3 SHA3384 4 SHA3512 5 Keccak256 6 Keccak384 7 Keccak512 8","title":"Transaction Types - HTLC Claim"},{"location":"core/transactions/types/htlc-claim/#htlc-claim","text":"TypeGroup Type 1 9 A Hashed Time-Lock Contract (HTLC) is a set of transaction types that permits a designated party (the \"sender/seller\") to LOCK funds by disclosing the preimage (secret) of a hash. It also permits a second party (the \"recipient/buyer\") to CLAIM the funds, or after a timeout is reached enter a REFUND situation. The purpose of this transaction is for the recipient to CLAIM funds from the sender - if they know the shared secret. References Improvement Proposal AIP102 API Endpoints Link AJV Schema Base | HTLC Claim","title":"HTLC Claim"},{"location":"core/transactions/types/htlc-claim/#json","text":"{ \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 9 , \"nonce\" : \"11\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"0\" , \"asset\" : { \"claim\" : { \"lockTransactionId\" : \"3aade2b98391ba7230252530cdd5124183a9f4e582660666ae873da48173ea5f\" , \"unlockSecret\" : \"c27f1ce845d8c29eebc9006be932b604fd06755521b1a8b0be4204c65377151a\" } } }","title":"JSON"},{"location":"core/transactions/types/htlc-claim/#serialized","text":"ff033f0100000009000b00000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192000000000000000000003aade2b98391ba7230252530cdd5124183a9f4e582660666ae873da48173ea5f20c27f1ce845d8c29eebc9006be932b604fd06755521b1a8b0be4204c65377151a","title":"Serialized"},{"location":"core/transactions/types/htlc-claim/#deserialized","text":"Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f TypeGroup: [3] 4 0x01000000 Type: [7] 2 0x0900 Nonce: [9] 8 0x0b00000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x0000000000000000 VendorField Length: [58] 1 0x00 Hash Type: [59] 1 0x00 Lock Id: [60] 32 0x3aade2b98391ba7230252530cdd5124183a9f4e582660666ae873da48173ea5f Unlock Secret Length: [92] 1 0x20 Unlock Secret: [93] 32 0xc27f1ce845d8c29eebc9006be932b604fd06755521b1a8b0be4204c65377151a","title":"Deserialized"},{"location":"core/transactions/types/htlc-claim/#supported-hash-types","text":"Hash Type Value SHA256 0 SHA384 1 SHA512 2 SHA3256 3 SHA3384 4 SHA3512 5 Keccak256 6 Keccak384 7 Keccak512 8","title":"Supported Hash Types"},{"location":"core/transactions/types/htlc-lock/","text":"HTLC Lock \u00b6 TypeGroup Type 1 8 A Hashed Time-Lock Contract (HTLC) is a set of transaction types that permits a designated party (the \"sender/seller\") to LOCK funds by disclosing the preimage (secret) of a hash. It also permits a second party (the \"recipient/buyer\") to CLAIM the funds, or after a timeout is reached enter a REFUND situation. The purpose of this transaction is to LOCK funds of the sender and make them possible for retrieval by the recipient, if they know the shared secret. References Improvement Proposal AIP102 API Endpoints Link AJV Schema Base | HTLC Lock JSON \u00b6 { \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 8 , \"nonce\" : \"10\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"10000000\" , \"amount\" : \"1\" , \"recipientId\" : \"SNAgA2XCRZDKfm5Vu9h4KR1bZw5xn9EiC3\" , \"asset\" : { \"lock\" : { \"secretHash\" : \"9c1a3815d49e0c9f78b872bfb017e825ea2db708158b70815526a830c85912b4\" , \"expiration\" : { \"type\" : 1 , \"value\" : 78740307 } } } } Serialized \u00b6 ff033f0100000008000a00000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed1928096980000000000000100000000000000029c1a3815d49e0c9f78b872bfb017e825ea2db708158b70815526a830c85912b401537bb1043f0995750207ecaf0ccf251c1265b92ad84f553662 Deserialized \u00b6 Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0800 Nonce: [9] 8 0x0a00000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x8096980000000000 VendorField Length: [58] 1 0x00 Amount: [59] 8 0x0100000000000000 Secret Hash Length: [67] 8 0x20 Secret Hash: [68] 32 0x9c1a3815d49e0c9f78b872bfb017e825ea2db708158b70815526a830c85912b4 Expiration Type: [100] 1 0x01 Expiration Value: [101] 4 0x537bb104 Recipient: [105] 21 0x3f0995750207ecaf0ccf251c1265b92ad84f553662","title":"Transaction Types - HTLC Lock"},{"location":"core/transactions/types/htlc-lock/#htlc-lock","text":"TypeGroup Type 1 8 A Hashed Time-Lock Contract (HTLC) is a set of transaction types that permits a designated party (the \"sender/seller\") to LOCK funds by disclosing the preimage (secret) of a hash. It also permits a second party (the \"recipient/buyer\") to CLAIM the funds, or after a timeout is reached enter a REFUND situation. The purpose of this transaction is to LOCK funds of the sender and make them possible for retrieval by the recipient, if they know the shared secret. References Improvement Proposal AIP102 API Endpoints Link AJV Schema Base | HTLC Lock","title":"HTLC Lock"},{"location":"core/transactions/types/htlc-lock/#json","text":"{ \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 8 , \"nonce\" : \"10\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"10000000\" , \"amount\" : \"1\" , \"recipientId\" : \"SNAgA2XCRZDKfm5Vu9h4KR1bZw5xn9EiC3\" , \"asset\" : { \"lock\" : { \"secretHash\" : \"9c1a3815d49e0c9f78b872bfb017e825ea2db708158b70815526a830c85912b4\" , \"expiration\" : { \"type\" : 1 , \"value\" : 78740307 } } } }","title":"JSON"},{"location":"core/transactions/types/htlc-lock/#serialized","text":"ff033f0100000008000a00000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed1928096980000000000000100000000000000029c1a3815d49e0c9f78b872bfb017e825ea2db708158b70815526a830c85912b401537bb1043f0995750207ecaf0ccf251c1265b92ad84f553662","title":"Serialized"},{"location":"core/transactions/types/htlc-lock/#deserialized","text":"Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0800 Nonce: [9] 8 0x0a00000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x8096980000000000 VendorField Length: [58] 1 0x00 Amount: [59] 8 0x0100000000000000 Secret Hash Length: [67] 8 0x20 Secret Hash: [68] 32 0x9c1a3815d49e0c9f78b872bfb017e825ea2db708158b70815526a830c85912b4 Expiration Type: [100] 1 0x01 Expiration Value: [101] 4 0x537bb104 Recipient: [105] 21 0x3f0995750207ecaf0ccf251c1265b92ad84f553662","title":"Deserialized"},{"location":"core/transactions/types/htlc-refund/","text":"HTLC Refund \u00b6 TypeGroup Type 1 3 A Hashed Time-Lock Contract (HTLC) is a set of transaction types that permits a designated party (the \"sender/seller\") to LOCK funds by disclosing the preimage (secret) of a hash. It also permits a second party (the \"recipient/buyer\") to CLAIM the funds, or after a timeout is reached enter a REFUND situation. The purpose of this transaction is for the sender to retrieve their locked funds, in the case of the recipient not claiming them using a CLAIM transactions. References Improvement Proposal AIP102 API Endpoints Link AJV Schema Base | HTLC Refund JSON \u00b6 { \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 10 , \"nonce\" : \"11\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"0\" , \"amount\" : \"0\" , \"asset\" : { \"refund\" : { \"lockTransactionId\" : \"3aade2b98391ba7230252530cdd5124183a9f4e582660666ae873da48173ea5f\" } } } Serialized \u00b6 ff033f010000000a000b00000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed1920000000000000000003aade2b98391ba7230252530cdd5124183a9f4e582660666ae873da48173ea5f Deserialized \u00b6 Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f TypeGroup: [3] 4 0x01000000 Type: [7] 2 0x0a00 Nonce: [9] 8 0x0b00000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x0000000000000000 VendorField Length: [58] 1 0x00 Lock Id: [59] 32 0x3aade2b98391ba7230252530cdd5124183a9f4e582660666ae873da48173ea5f","title":"Transaction Types - HTLC Refund"},{"location":"core/transactions/types/htlc-refund/#htlc-refund","text":"TypeGroup Type 1 3 A Hashed Time-Lock Contract (HTLC) is a set of transaction types that permits a designated party (the \"sender/seller\") to LOCK funds by disclosing the preimage (secret) of a hash. It also permits a second party (the \"recipient/buyer\") to CLAIM the funds, or after a timeout is reached enter a REFUND situation. The purpose of this transaction is for the sender to retrieve their locked funds, in the case of the recipient not claiming them using a CLAIM transactions. References Improvement Proposal AIP102 API Endpoints Link AJV Schema Base | HTLC Refund","title":"HTLC Refund"},{"location":"core/transactions/types/htlc-refund/#json","text":"{ \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 10 , \"nonce\" : \"11\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"0\" , \"amount\" : \"0\" , \"asset\" : { \"refund\" : { \"lockTransactionId\" : \"3aade2b98391ba7230252530cdd5124183a9f4e582660666ae873da48173ea5f\" } } }","title":"JSON"},{"location":"core/transactions/types/htlc-refund/#serialized","text":"ff033f010000000a000b00000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed1920000000000000000003aade2b98391ba7230252530cdd5124183a9f4e582660666ae873da48173ea5f","title":"Serialized"},{"location":"core/transactions/types/htlc-refund/#deserialized","text":"Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f TypeGroup: [3] 4 0x01000000 Type: [7] 2 0x0a00 Nonce: [9] 8 0x0b00000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x0000000000000000 VendorField Length: [58] 1 0x00 Lock Id: [59] 32 0x3aade2b98391ba7230252530cdd5124183a9f4e582660666ae873da48173ea5f","title":"Deserialized"},{"location":"core/transactions/types/ipfs/","text":"IPFS \u00b6 TypeGroup Type 1 5 This transaction type utilizes a special data field similar to the vendor field to store Interplanetary File System data on the blockchain. This provides an easy way to timestamp and optionally encrypt and verify files. This implementation of the IPFS transaction type won\u2019t allow storing data on the blockchain - for that, special IPFS nodes are needed. References Improvement Proposal AIP11 , AIP29 API Endpoints Link AJV Schema Base | IPFS JSON \u00b6 { \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 5 , \"nonce\" : \"7\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"500000000\" , \"asset\" : { \"ipfs\" : \"QmYSK2JyM3RyDyB52caZCTKFR3HKniEcMnNJYdk8DQ6KKB\" } } Serialized \u00b6 ff033f0100000005000700000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed1920065cd1d000000000012209608184d6cee2b9af8e6c2a46fc9318adf73329aeb8a86cf8472829fff5bb89e Deserialized \u00b6 Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f TypeGroup: [3] 4 0x01000000 Type: [7] 2 0x0500 Nonce: [9] 8 0x0700000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x0065cd1d00000000 VendorField Length: [58] 1 0x00 IPFS Hash: [59] 34 0x12209608184d6cee2b9af8e6c2a46fc9318adf73329aeb8a86cf8472829fff5bb89e IPFS Hash \u00b6 Item Length (chars) Value IPFS Hash 46 QmYSK2JyM3RyDyB52caZCTKFR3HKniEcMnNJYdk8DQ6KKB Decoded Base58 34 0x12209608184d6cee2b9af8e6c2a46fc9318adf73329aeb8a86cf8472829fff5bb89e Hash Type 1 0x12 Hash Length 1 0x20 32-Byte Hash 32 0x9608184d6cee2b9af8e6c2a46fc9318adf73329aeb8a86cf8472829fff5bb89e","title":"Transaction Types - IPFS"},{"location":"core/transactions/types/ipfs/#ipfs","text":"TypeGroup Type 1 5 This transaction type utilizes a special data field similar to the vendor field to store Interplanetary File System data on the blockchain. This provides an easy way to timestamp and optionally encrypt and verify files. This implementation of the IPFS transaction type won\u2019t allow storing data on the blockchain - for that, special IPFS nodes are needed. References Improvement Proposal AIP11 , AIP29 API Endpoints Link AJV Schema Base | IPFS","title":"IPFS"},{"location":"core/transactions/types/ipfs/#json","text":"{ \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 5 , \"nonce\" : \"7\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"500000000\" , \"asset\" : { \"ipfs\" : \"QmYSK2JyM3RyDyB52caZCTKFR3HKniEcMnNJYdk8DQ6KKB\" } }","title":"JSON"},{"location":"core/transactions/types/ipfs/#serialized","text":"ff033f0100000005000700000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed1920065cd1d000000000012209608184d6cee2b9af8e6c2a46fc9318adf73329aeb8a86cf8472829fff5bb89e","title":"Serialized"},{"location":"core/transactions/types/ipfs/#deserialized","text":"Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f TypeGroup: [3] 4 0x01000000 Type: [7] 2 0x0500 Nonce: [9] 8 0x0700000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x0065cd1d00000000 VendorField Length: [58] 1 0x00 IPFS Hash: [59] 34 0x12209608184d6cee2b9af8e6c2a46fc9318adf73329aeb8a86cf8472829fff5bb89e","title":"Deserialized"},{"location":"core/transactions/types/ipfs/#ipfs-hash","text":"Item Length (chars) Value IPFS Hash 46 QmYSK2JyM3RyDyB52caZCTKFR3HKniEcMnNJYdk8DQ6KKB Decoded Base58 34 0x12209608184d6cee2b9af8e6c2a46fc9318adf73329aeb8a86cf8472829fff5bb89e Hash Type 1 0x12 Hash Length 1 0x20 32-Byte Hash 32 0x9608184d6cee2b9af8e6c2a46fc9318adf73329aeb8a86cf8472829fff5bb89e","title":"IPFS Hash"},{"location":"core/transactions/types/multipayment/","text":"Multi-Payment \u00b6 TypeGroup Type 1 6 This type is designed to reduce the payload on the blockchain by enabling multiple payments to be combined and broadcast to the network as a single transaction. This benefits the end user and delegates by lowering transaction fees per payment and reducing congestion. Initially and depending on testing, the Solar Core will allow at least 64 payments to be combined within a single transaction for APN/Mainnet. Eventually, the number of payments per transaction will be able to scale as needed. References Improvement Proposal AIP11 , AIP29 API Endpoints Link AJV Schema Base | Multi-Payment JSON \u00b6 { \"version\" : 3 , \"network\" : 63 , \"type\" : 6 , \"nonce\" : \"8\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"10000000\" , \"amount\" : \"0\" , \"asset\" : { \"payments\" : [ { \"amount\" : \"1\" , \"recipientId\" : \"SNAgA2XCRZDKfm5Vu9h4KR1bZw5xn9EiC3\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SjHT1fxVsW75eaQUPN4U2SEgFVU8ZqSVgk\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SVzKH9r6u8UGcd2Ki7tAzQtB5Pa6FRn4GA\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SVhLL7NR8WhkKRfYDzSmGxUH4Gg5k3uis7\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SeznGToSzxw7maHDWXD2eRoTBSS2BmK8nU\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SfVFPA5e2JYcgJeUmVBEsFCYCWpt5xkZ5o\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SQEDRvC79Tqqmv85FrnqG4AxAxFoYPADCa\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SX87pA6bJdQQf57JnUUkzVJxZ2n9jxDgeN\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SMMJgffKfvtERv3d4MFeypAg53UcxJ9dE1\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SefdTc8Sjx5pqSUu3TpfjFw6epyPYWoooQ\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SSB1coESUy1GHsXjxd1Qzw5e1HqMUNQzRG\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SNtHvv7fr23EcKHkXeSwCYz6w2ZLaT7y9y\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SUogQH6n5EjwFnXwDapkJ1jri13Hrj1Ppz\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SY4RAvsUTZ5q9PR9Df28vguH6LfRFrgB3a\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SPZynxFxAtSBVKQWQW8LQPtrt87CBqpn7i\" }, { \"amount\" : \"1\" , \"recipientId\" : \"Sj6YjvZYDH4xh8HsRiYzWLBpeAkx65Nc1W\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SX3XMHrMSbXLLNGcRVbMBy4WgQbS3MZzWV\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SYqJcLu2wWYHDYvSomgsDPtnteCVhpNCTQ\" }, { \"amount\" : \"1\" , \"recipientId\" : \"Sa1v9xUZaniWKiCGzEV7qYXt1pW3G3XJbi\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SQVwXdWCqouKWQhaAJMsNieZmjE3GLYYiz\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SR1ZhBPLnSvrq3SQt8zeqBshemiudGb9fe\" }, { \"amount\" : \"1\" , \"recipientId\" : \"Sd1beR5X9pKKEYSxYWc7XXozC52y8QGJSt\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SScQEYdkr5mPGD9uwFrdk15KjyKAfwHZFc\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SRMhbyiuDa14kQKE7g8NB9jrBE8Jh9NwPv\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SUwp9puY8x9GYbvq8X4eYE5UjQxCgmNJMJ\" }, { \"amount\" : \"1\" , \"recipientId\" : \"ShomZcGU7c15EUXTUAfZB2QHw17UsHxxyf\" }, { \"amount\" : \"1\" , \"recipientId\" : \"ScCTPEwY4Bz2cTJJxL4Fy388zRTrAKmV8m\" }, { \"amount\" : \"1\" , \"recipientId\" : \"ShqpcENQP4gSqRcrC1oqAzSiNscvutyQ3B\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SjcaXuPypJxUv8qg4z7SaAry9ipqkVZsV2\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SZk35koLSrjSetXda5toYEhNNv3GNbosDN\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SVBBoMW8u2TiH4C59yi5wxk5mis81NJupL\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SgZEJxkDxfDSWP38QjkDkAf9uQLwb4XL8N\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SgE9Mqj1ZX9ziL9bJUUaRXzwNibEocJm5s\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SYkqTvG2n54Fbg1hAiZDeK33DYwCYZWcuC\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SjUcnukBRT6qxLRbbyrsQxVjbMdVLYRi5a\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SNSmzTzFPmzSmaKgcDj32nz7aJp1dJqJ5a\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SRdLAGYYk8HVeL3iJxRmYxZ9qvGUdRBiub\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SQf1Dpta8b94FYjKDBu2dfFF4EdUfLMnoU\" }, { \"amount\" : \"1\" , \"recipientId\" : \"Si5KNcn97V6TZYH1ccZZpyMvCJZmKuLEzv\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SfxX8nJVJ5rUbAXPVgFMXhpEbXXp1P3aWc\" } ] } } Serialized \u00b6 ff033f0100000006000800000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192809698000000000000280001000000000000003f0995750207ecaf0ccf251c1265b92ad84f55366201000000000000003ff13809c4c5fb2b3967a9b40efc70843f7db462ad01000000000000003f5f60e0594115b71d5b136cf929c8504082ac199d01000000000000003f5c2aaead4ce542788406c54e1ae31f1afdb7f08101000000000000003fc2308975254751ead4df705fc76aa84116c5e34e01000000000000003fc792d1958bb950596d0e7cd0bef325062009684801000000000000003f2031100e628422b8409810fdb438e874765846ba01000000000000003f6bd2c24bded5fdfd7888a28b3c6990503699b5e801000000000000003f009ffbb10efc47ad00a0a29cc2ef6e6c83d8c6ec01000000000000003fbe9147febbfe462cdbfda8575c18dabe85db4f5b01000000000000003f358634b58d88abf4aef3a6fe264b4ad18b74e98b01000000000000003f11745fc47a9c58c4e6f5a74eb59411ac102c6a8801000000000000003f5265ceb5d6102474ea7d0f401d6e6b9f13864a0501000000000000003f7617b5f3b82f153e388b4b200abd8636fff73dd501000000000000003f18f5df4fe3108277bfa4e39071fead9d59b35b8f01000000000000003fef283e95c3fdf0e2df9ba8321407c5621f98687601000000000000003f6af453a17439c9c258c25c707aa9fc1f3b59d9b401000000000000003f7e94f3954665ebd80ced3d434c67cd4351966f2b01000000000000003f8b8ee88e27291e33ce5403ea9b159235887dcfa901000000000000003f232a71b6b2586d5b02b6a72db08759066ba2a92b01000000000000003f28c4b220f14f3745f3fff6d3c066ba2353393eb601000000000000003fac67d5bfbef4a7ed8149727b93a01e903d84ee0c01000000000000003f3a537bef2ed296a54adc354967efe3a5e52cdfb801000000000000003f2c939e4633bd96ccc1d1509dbe794299603aad9901000000000000003f53ef9af027797e4827d708d9ed47c511f4ea552401000000000000003fe103c02fc06140aeac275f8e579f3397d041f81701000000000000003fa37d6366d765f5e446fc18ddcc3da3fa300cf6bb01000000000000003fe1671fea563be042824751a3465a7dbbc482794201000000000000003ff4d63847bf07a9faad83bd69fed408b3b734dce801000000000000003f888e092eba4cbd5eab9e10646661f5a440915f9d01000000000000003f5677152f9d640b175894c8da0b9f30bad3801aff01000000000000003fd34bb692e52d515398d00fd57ce2c8bfd348055401000000000000003fcfafad73ebddc38d53317c80cdbf6d343c331d6201000000000000003f7dbca0c01f96de655cf41eb53e1b8d5e2ffa260701000000000000003ff354c71350a110a7b45b5095ed0a4601bf4bbf9d01000000000000003f0ca0fbbfb8e3f615ec4eedaef6281d4d60a8f2b201000000000000003f2f885faaf6a3fcc38b1f35c652bf72f0fd7ac60301000000000000003f24e14548f3874b9413a28f258c2b73d35ec2b2f901000000000000003fe3f48b5211d1f21034bc15908259901ecf972be801000000000000003fccbb32ea36fad927cb2c46cbc63930db6cda829d Deserialized \u00b6 Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f TypeGroup: [3] 4 0x01000000 Type: [7] 2 0x0600 Nonce: [9] 8 0x0800000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x8096980000000000 VendorField Length: [58] 1 0x00 Number of Payments: [59] 2 0x2800 Amount 1: [61] 8 0x0100000000000000 Recipient 1: [69] 21 0x3f0995750207ecaf0ccf251c1265b92ad84f553662 ............ .... .. .................. Amount 40: [1192] 8 0x0100000000000000 Recipient 40: [1200] 21 0x3fccbb32ea36fad927cb2c46cbc63930db6cda829d","title":"Transaction Types - Multi-Payment"},{"location":"core/transactions/types/multipayment/#multi-payment","text":"TypeGroup Type 1 6 This type is designed to reduce the payload on the blockchain by enabling multiple payments to be combined and broadcast to the network as a single transaction. This benefits the end user and delegates by lowering transaction fees per payment and reducing congestion. Initially and depending on testing, the Solar Core will allow at least 64 payments to be combined within a single transaction for APN/Mainnet. Eventually, the number of payments per transaction will be able to scale as needed. References Improvement Proposal AIP11 , AIP29 API Endpoints Link AJV Schema Base | Multi-Payment","title":"Multi-Payment"},{"location":"core/transactions/types/multipayment/#json","text":"{ \"version\" : 3 , \"network\" : 63 , \"type\" : 6 , \"nonce\" : \"8\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"10000000\" , \"amount\" : \"0\" , \"asset\" : { \"payments\" : [ { \"amount\" : \"1\" , \"recipientId\" : \"SNAgA2XCRZDKfm5Vu9h4KR1bZw5xn9EiC3\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SjHT1fxVsW75eaQUPN4U2SEgFVU8ZqSVgk\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SVzKH9r6u8UGcd2Ki7tAzQtB5Pa6FRn4GA\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SVhLL7NR8WhkKRfYDzSmGxUH4Gg5k3uis7\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SeznGToSzxw7maHDWXD2eRoTBSS2BmK8nU\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SfVFPA5e2JYcgJeUmVBEsFCYCWpt5xkZ5o\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SQEDRvC79Tqqmv85FrnqG4AxAxFoYPADCa\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SX87pA6bJdQQf57JnUUkzVJxZ2n9jxDgeN\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SMMJgffKfvtERv3d4MFeypAg53UcxJ9dE1\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SefdTc8Sjx5pqSUu3TpfjFw6epyPYWoooQ\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SSB1coESUy1GHsXjxd1Qzw5e1HqMUNQzRG\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SNtHvv7fr23EcKHkXeSwCYz6w2ZLaT7y9y\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SUogQH6n5EjwFnXwDapkJ1jri13Hrj1Ppz\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SY4RAvsUTZ5q9PR9Df28vguH6LfRFrgB3a\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SPZynxFxAtSBVKQWQW8LQPtrt87CBqpn7i\" }, { \"amount\" : \"1\" , \"recipientId\" : \"Sj6YjvZYDH4xh8HsRiYzWLBpeAkx65Nc1W\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SX3XMHrMSbXLLNGcRVbMBy4WgQbS3MZzWV\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SYqJcLu2wWYHDYvSomgsDPtnteCVhpNCTQ\" }, { \"amount\" : \"1\" , \"recipientId\" : \"Sa1v9xUZaniWKiCGzEV7qYXt1pW3G3XJbi\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SQVwXdWCqouKWQhaAJMsNieZmjE3GLYYiz\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SR1ZhBPLnSvrq3SQt8zeqBshemiudGb9fe\" }, { \"amount\" : \"1\" , \"recipientId\" : \"Sd1beR5X9pKKEYSxYWc7XXozC52y8QGJSt\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SScQEYdkr5mPGD9uwFrdk15KjyKAfwHZFc\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SRMhbyiuDa14kQKE7g8NB9jrBE8Jh9NwPv\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SUwp9puY8x9GYbvq8X4eYE5UjQxCgmNJMJ\" }, { \"amount\" : \"1\" , \"recipientId\" : \"ShomZcGU7c15EUXTUAfZB2QHw17UsHxxyf\" }, { \"amount\" : \"1\" , \"recipientId\" : \"ScCTPEwY4Bz2cTJJxL4Fy388zRTrAKmV8m\" }, { \"amount\" : \"1\" , \"recipientId\" : \"ShqpcENQP4gSqRcrC1oqAzSiNscvutyQ3B\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SjcaXuPypJxUv8qg4z7SaAry9ipqkVZsV2\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SZk35koLSrjSetXda5toYEhNNv3GNbosDN\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SVBBoMW8u2TiH4C59yi5wxk5mis81NJupL\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SgZEJxkDxfDSWP38QjkDkAf9uQLwb4XL8N\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SgE9Mqj1ZX9ziL9bJUUaRXzwNibEocJm5s\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SYkqTvG2n54Fbg1hAiZDeK33DYwCYZWcuC\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SjUcnukBRT6qxLRbbyrsQxVjbMdVLYRi5a\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SNSmzTzFPmzSmaKgcDj32nz7aJp1dJqJ5a\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SRdLAGYYk8HVeL3iJxRmYxZ9qvGUdRBiub\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SQf1Dpta8b94FYjKDBu2dfFF4EdUfLMnoU\" }, { \"amount\" : \"1\" , \"recipientId\" : \"Si5KNcn97V6TZYH1ccZZpyMvCJZmKuLEzv\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SfxX8nJVJ5rUbAXPVgFMXhpEbXXp1P3aWc\" } ] } }","title":"JSON"},{"location":"core/transactions/types/multipayment/#serialized","text":"ff033f0100000006000800000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192809698000000000000280001000000000000003f0995750207ecaf0ccf251c1265b92ad84f55366201000000000000003ff13809c4c5fb2b3967a9b40efc70843f7db462ad01000000000000003f5f60e0594115b71d5b136cf929c8504082ac199d01000000000000003f5c2aaead4ce542788406c54e1ae31f1afdb7f08101000000000000003fc2308975254751ead4df705fc76aa84116c5e34e01000000000000003fc792d1958bb950596d0e7cd0bef325062009684801000000000000003f2031100e628422b8409810fdb438e874765846ba01000000000000003f6bd2c24bded5fdfd7888a28b3c6990503699b5e801000000000000003f009ffbb10efc47ad00a0a29cc2ef6e6c83d8c6ec01000000000000003fbe9147febbfe462cdbfda8575c18dabe85db4f5b01000000000000003f358634b58d88abf4aef3a6fe264b4ad18b74e98b01000000000000003f11745fc47a9c58c4e6f5a74eb59411ac102c6a8801000000000000003f5265ceb5d6102474ea7d0f401d6e6b9f13864a0501000000000000003f7617b5f3b82f153e388b4b200abd8636fff73dd501000000000000003f18f5df4fe3108277bfa4e39071fead9d59b35b8f01000000000000003fef283e95c3fdf0e2df9ba8321407c5621f98687601000000000000003f6af453a17439c9c258c25c707aa9fc1f3b59d9b401000000000000003f7e94f3954665ebd80ced3d434c67cd4351966f2b01000000000000003f8b8ee88e27291e33ce5403ea9b159235887dcfa901000000000000003f232a71b6b2586d5b02b6a72db08759066ba2a92b01000000000000003f28c4b220f14f3745f3fff6d3c066ba2353393eb601000000000000003fac67d5bfbef4a7ed8149727b93a01e903d84ee0c01000000000000003f3a537bef2ed296a54adc354967efe3a5e52cdfb801000000000000003f2c939e4633bd96ccc1d1509dbe794299603aad9901000000000000003f53ef9af027797e4827d708d9ed47c511f4ea552401000000000000003fe103c02fc06140aeac275f8e579f3397d041f81701000000000000003fa37d6366d765f5e446fc18ddcc3da3fa300cf6bb01000000000000003fe1671fea563be042824751a3465a7dbbc482794201000000000000003ff4d63847bf07a9faad83bd69fed408b3b734dce801000000000000003f888e092eba4cbd5eab9e10646661f5a440915f9d01000000000000003f5677152f9d640b175894c8da0b9f30bad3801aff01000000000000003fd34bb692e52d515398d00fd57ce2c8bfd348055401000000000000003fcfafad73ebddc38d53317c80cdbf6d343c331d6201000000000000003f7dbca0c01f96de655cf41eb53e1b8d5e2ffa260701000000000000003ff354c71350a110a7b45b5095ed0a4601bf4bbf9d01000000000000003f0ca0fbbfb8e3f615ec4eedaef6281d4d60a8f2b201000000000000003f2f885faaf6a3fcc38b1f35c652bf72f0fd7ac60301000000000000003f24e14548f3874b9413a28f258c2b73d35ec2b2f901000000000000003fe3f48b5211d1f21034bc15908259901ecf972be801000000000000003fccbb32ea36fad927cb2c46cbc63930db6cda829d","title":"Serialized"},{"location":"core/transactions/types/multipayment/#deserialized","text":"Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f TypeGroup: [3] 4 0x01000000 Type: [7] 2 0x0600 Nonce: [9] 8 0x0800000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x8096980000000000 VendorField Length: [58] 1 0x00 Number of Payments: [59] 2 0x2800 Amount 1: [61] 8 0x0100000000000000 Recipient 1: [69] 21 0x3f0995750207ecaf0ccf251c1265b92ad84f553662 ............ .... .. .................. Amount 40: [1192] 8 0x0100000000000000 Recipient 40: [1200] 21 0x3fccbb32ea36fad927cb2c46cbc63930db6cda829d","title":"Deserialized"},{"location":"core/transactions/types/multisignature-registration/","text":"MultiSignature Registration \u00b6 TypeGroup Type 1 4 Multiple publicKeys can be aggregated into one creating a unique publicKey and address. This enables the creation of transactions that must be authorized by a minimum number of participants (signatures). References Improvement Proposal AIP18 API Endpoints Link AJV Schema Base | MultiSignature JSON \u00b6 { \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 4 , \"nonce\" : \"6\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"2000000000\" , \"amount\" : \"0\" , \"asset\" : { \"multiSignature\" : { \"publicKeys\" : [ \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"03df0a1eb42d99b5de395cead145ba1ec2ea837be308c7ce3a4e8018b7efc7fdb8\" , \"03860d76b1df09659ac282cea3da5bd84fc45729f348a4a8e5f802186be72dc17f\" ], \"min\" : 2 } } } Serialized \u00b6 ff033f0100000004000600000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed1920094357700000000000203034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed19203df0a1eb42d99b5de395cead145ba1ec2ea837be308c7ce3a4e8018b7efc7fdb803860d76b1df09659ac282cea3da5bd84fc45729f348a4a8e5f802186be72dc17f Deserialized \u00b6 Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0400 Nonce: [9] 8 0x0600000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x0094357700000000 VendorField Length: [58] 1 0x00 Key Min: [59] 1 0x02 Key Count: [60] 1 0x03 Key 1: [61] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Key 2: [94] 33 0x03df0a1eb42d99b5de395cead145ba1ec2ea837be308c7ce3a4e8018b7efc7fdb8 Key 3: [127] 33 0x03860d76b1df09659ac282cea3da5bd84fc45729f348a4a8e5f802186be72dc17f","title":"Transaction Types - Multisignature Registration"},{"location":"core/transactions/types/multisignature-registration/#multisignature-registration","text":"TypeGroup Type 1 4 Multiple publicKeys can be aggregated into one creating a unique publicKey and address. This enables the creation of transactions that must be authorized by a minimum number of participants (signatures). References Improvement Proposal AIP18 API Endpoints Link AJV Schema Base | MultiSignature","title":"MultiSignature Registration"},{"location":"core/transactions/types/multisignature-registration/#json","text":"{ \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 4 , \"nonce\" : \"6\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"2000000000\" , \"amount\" : \"0\" , \"asset\" : { \"multiSignature\" : { \"publicKeys\" : [ \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"03df0a1eb42d99b5de395cead145ba1ec2ea837be308c7ce3a4e8018b7efc7fdb8\" , \"03860d76b1df09659ac282cea3da5bd84fc45729f348a4a8e5f802186be72dc17f\" ], \"min\" : 2 } } }","title":"JSON"},{"location":"core/transactions/types/multisignature-registration/#serialized","text":"ff033f0100000004000600000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed1920094357700000000000203034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed19203df0a1eb42d99b5de395cead145ba1ec2ea837be308c7ce3a4e8018b7efc7fdb803860d76b1df09659ac282cea3da5bd84fc45729f348a4a8e5f802186be72dc17f","title":"Serialized"},{"location":"core/transactions/types/multisignature-registration/#deserialized","text":"Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0400 Nonce: [9] 8 0x0600000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x0094357700000000 VendorField Length: [58] 1 0x00 Key Min: [59] 1 0x02 Key Count: [60] 1 0x03 Key 1: [61] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Key 2: [94] 33 0x03df0a1eb42d99b5de395cead145ba1ec2ea837be308c7ce3a4e8018b7efc7fdb8 Key 3: [127] 33 0x03860d76b1df09659ac282cea3da5bd84fc45729f348a4a8e5f802186be72dc17f","title":"Deserialized"},{"location":"core/transactions/types/overview/","text":"Solar Core v3 Transaction Types Overview \u00b6 This sections describes Mainnet Transaction Types and its structure related to the serde process (serialization and deserialization of transactions). \u2139\ufe0f INFO - Transactions are the heart of any blockchain, cryptocurrency or otherwise. They represent a transfer of value from one network participant to another. In SXP, transactions can be of one of multiple types, specified in AIP11, which can affect the content and data structure of each transaction's payload. Using the SXP SDKs , developers can employ the programming language of their choice to build applications utilizing the SXP blockchain. The SXP SDKs are split into two packages for each language: Client and Cryptography. Client SDKs help developers fetch information from the SXP blockchain about its current state: which delegates are currently forging, what transactions are associated with a given wallet, and so on. Cryptography SDKs, by contrast, assist developers in working with transactions: signing, serializing, deserializing, etc. For more information about SDK implementations visit SXP SDKs hub . List of Transaction Types \u00b6 TypeGroup 1 Type 0: Transfer Type 1: Second Signature Registration Type 2: Delegate Registration Type 3: Vote Type 4: MultiSignature Registration Type 5: IPFS Type 6: Multi-Payment Type 7: Delegate Resignation Type 8: HTLC Lock Type 9: HTLC Claim Type 10: HTLC Refund TypeGroup 2 Type 0: Burn","title":"Transaction Types - Overview"},{"location":"core/transactions/types/overview/#solar-core-v3-transaction-types-overview","text":"This sections describes Mainnet Transaction Types and its structure related to the serde process (serialization and deserialization of transactions). \u2139\ufe0f INFO - Transactions are the heart of any blockchain, cryptocurrency or otherwise. They represent a transfer of value from one network participant to another. In SXP, transactions can be of one of multiple types, specified in AIP11, which can affect the content and data structure of each transaction's payload. Using the SXP SDKs , developers can employ the programming language of their choice to build applications utilizing the SXP blockchain. The SXP SDKs are split into two packages for each language: Client and Cryptography. Client SDKs help developers fetch information from the SXP blockchain about its current state: which delegates are currently forging, what transactions are associated with a given wallet, and so on. Cryptography SDKs, by contrast, assist developers in working with transactions: signing, serializing, deserializing, etc. For more information about SDK implementations visit SXP SDKs hub .","title":"Solar Core v3 Transaction Types Overview"},{"location":"core/transactions/types/overview/#list-of-transaction-types","text":"TypeGroup 1 Type 0: Transfer Type 1: Second Signature Registration Type 2: Delegate Registration Type 3: Vote Type 4: MultiSignature Registration Type 5: IPFS Type 6: Multi-Payment Type 7: Delegate Resignation Type 8: HTLC Lock Type 9: HTLC Claim Type 10: HTLC Refund TypeGroup 2 Type 0: Burn","title":"List of Transaction Types"},{"location":"core/transactions/types/second-signature/","text":"Second Signature Registration \u00b6 TypeGroup Type 1 1 This transaction type enables a user to add an extra layer of security to their address by creating a second passphrase, using mnemonic code for generating deterministic keys via BIP-39 to produce an additional mnemonic. Once a second signature has been registered to a wallet, the owner of the wallet will then be required to input their primary and secondary passphrase when sending a transaction to the network. References Improvement Proposal AIP11 , AIP29 API Endpoints Link AJV Schema Base | Second Signature Json \u00b6 { \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 1 , \"nonce\" : \"2\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"2500000\" , \"asset\" : { \"signature\" : { \"publicKey\" : \"02877e4f35c76abaeb152b128670db0a7ae10b3999afcd28a42938b653fbf87ae9\" } } } Serialized \u00b6 ff033f0100000001000200000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192a0252600000000000002877e4f35c76abaeb152b128670db0a7ae10b3999afcd28a42938b653fbf87ae9 Deserialized \u00b6 Key Pos. Size (bytes) Value (hex) Header Flag: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0100 Nonce: [9] 8 0x0200000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0xa025260000000000 VendorField Length: [58] 1 0x00 Second PublicKey: [59] 33 0x02877e4f35c76abaeb152b128670db0a7ae10b3999afcd28a42938b653fbf87ae9","title":"Transaction Types - Second Signature Registration"},{"location":"core/transactions/types/second-signature/#second-signature-registration","text":"TypeGroup Type 1 1 This transaction type enables a user to add an extra layer of security to their address by creating a second passphrase, using mnemonic code for generating deterministic keys via BIP-39 to produce an additional mnemonic. Once a second signature has been registered to a wallet, the owner of the wallet will then be required to input their primary and secondary passphrase when sending a transaction to the network. References Improvement Proposal AIP11 , AIP29 API Endpoints Link AJV Schema Base | Second Signature","title":"Second Signature Registration"},{"location":"core/transactions/types/second-signature/#json","text":"{ \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 1 , \"nonce\" : \"2\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"2500000\" , \"asset\" : { \"signature\" : { \"publicKey\" : \"02877e4f35c76abaeb152b128670db0a7ae10b3999afcd28a42938b653fbf87ae9\" } } }","title":"Json"},{"location":"core/transactions/types/second-signature/#serialized","text":"ff033f0100000001000200000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192a0252600000000000002877e4f35c76abaeb152b128670db0a7ae10b3999afcd28a42938b653fbf87ae9","title":"Serialized"},{"location":"core/transactions/types/second-signature/#deserialized","text":"Key Pos. Size (bytes) Value (hex) Header Flag: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0100 Nonce: [9] 8 0x0200000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0xa025260000000000 VendorField Length: [58] 1 0x00 Second PublicKey: [59] 33 0x02877e4f35c76abaeb152b128670db0a7ae10b3999afcd28a42938b653fbf87ae9","title":"Deserialized"},{"location":"core/transactions/types/transfer/","text":"Transfer \u00b6 TypeGroup Type 1 0 The transfer transaction enables a user to broadcast a transaction to the network sending SXP tokens from one SXP wallet to another. This transaction type provides the utility of store-of-value and value transfer. It also contains a special data field of 255 bytes called the vendor field, allowing raw data, code or plain text to be stored on the blockchain. The vendor field is public and immutable, and is also utilized in SXP SmartBridge Technology. References Improvement Proposal AIP11 , AIP29 API Endpoints Link AJV Schema Base | Transfer Json \u00b6 { \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 0 , \"nonce\" : \"1\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"2500000\" , \"vendorField\" : \"This is a test vendorfield.\" , \"amount\" : \"100000000\" , \"expiration\" : 0 , \"recipientId\" : \"SNAgA2XCRZDKfm5Vu9h4KR1bZw5xn9EiC3\" } Serialized \u00b6 ff033f0100000000000100000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192a0252600000000001b54686973206973206120746573742076656e646f726669656c642e00e1f50500000000000000003f0995750207ecaf0ccf251c1265b92ad84f553662 Deserialized \u00b6 Key Pos. Size (bytes) Value (hex) Header Flag: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0000 Nonce: [9] 8 0x0100000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0xa025260000000000 VendorField Length: [58] 1 0x1b VendorField: [59] 26 0x54686973206973206120746573742076656e646f726669656c642e Amount: [85] 8 0x00e1f50500000000 Expiration: [93] 4 0x00000000 Recipient: [97] 21 0x3f0995750207ecaf0ccf251c1265b92ad84f553662","title":"Transaction Types - Transfer"},{"location":"core/transactions/types/transfer/#transfer","text":"TypeGroup Type 1 0 The transfer transaction enables a user to broadcast a transaction to the network sending SXP tokens from one SXP wallet to another. This transaction type provides the utility of store-of-value and value transfer. It also contains a special data field of 255 bytes called the vendor field, allowing raw data, code or plain text to be stored on the blockchain. The vendor field is public and immutable, and is also utilized in SXP SmartBridge Technology. References Improvement Proposal AIP11 , AIP29 API Endpoints Link AJV Schema Base | Transfer","title":"Transfer"},{"location":"core/transactions/types/transfer/#json","text":"{ \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 0 , \"nonce\" : \"1\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"2500000\" , \"vendorField\" : \"This is a test vendorfield.\" , \"amount\" : \"100000000\" , \"expiration\" : 0 , \"recipientId\" : \"SNAgA2XCRZDKfm5Vu9h4KR1bZw5xn9EiC3\" }","title":"Json"},{"location":"core/transactions/types/transfer/#serialized","text":"ff033f0100000000000100000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192a0252600000000001b54686973206973206120746573742076656e646f726669656c642e00e1f50500000000000000003f0995750207ecaf0ccf251c1265b92ad84f553662","title":"Serialized"},{"location":"core/transactions/types/transfer/#deserialized","text":"Key Pos. Size (bytes) Value (hex) Header Flag: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0000 Nonce: [9] 8 0x0100000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0xa025260000000000 VendorField Length: [58] 1 0x1b VendorField: [59] 26 0x54686973206973206120746573742076656e646f726669656c642e Amount: [85] 8 0x00e1f50500000000 Expiration: [93] 4 0x00000000 Recipient: [97] 21 0x3f0995750207ecaf0ccf251c1265b92ad84f553662","title":"Deserialized"},{"location":"core/transactions/types/vote-unvote/","text":"Vote / Unvote / Switchvote \u00b6 TypeGroup Type 1 3 A key feature of the SXP DPoS model is that each address can vote for one delegate of their choosing to secure the network. A vote and unvote transaction type is therefore necessary to enable this functionality. Once an address votes for a delegate, funds can enter and leave the address as needed, and vote weight adjusts automatically. Voting does not send funds to the delegate\u2019s SXP address in question - it only assigns vote weight Holders of SXP vote through their wallets for delegates who secure the network, insert blocks into the ledger, and create new SXP. The top 53 vote earners are named elected forging delegates. Number of delegates is related to DPOS mechanism configuration. References Improvement Proposal AIP11 , AIP29 API Endpoints Link AJV Schema Base | Vote / Unvote / Switchvote Vote \u00b6 JSON \u00b6 { \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 3 , \"nonce\" : \"4\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"10000000\" , \"asset\" : { \"count\" : 1 , \"votes\" : [ \"+cactus1549\" ] } } Serialized \u00b6 ff033f0100000003000400000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192809698000000000000010b0163616374757331353439 Deserialized \u00b6 Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0300 Nonce: [9] 8 0x0400000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x8096980000000000 VendorField Length: [58] 1 0x00 Vote Count: [59] 1 0x01 Vote Length: [60] 1 0x0b Vote Type: [61] 1 0x01 Vote: [62] 5 0x63616374757331353439 Unvote \u00b6 JSON \u00b6 { \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 3 , \"nonce\" : \"5\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"10000000\" , \"asset\" : { \"count\" : 1 , \"votes\" : [ \"-cactus1549\" ] } } Serialized \u00b6 ff033f0100000003000500000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192809698000000000000010b0063616374757331353439 Deserialized \u00b6 Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0300 Nonce: [9] 8 0x0400000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x8096980000000000 VendorField Length: [58] 1 0x00 Vote Count: [59] 1 0x01 Vote Length: [60] 1 0x0b Vote Type: [61] 1 0x00 Vote: [62] 5 0x63616374757331353439 Switch Vote \u00b6 JSON \u00b6 { \"version\" : 3 , \"network\" : 63 , \"type\" : 3 , \"nonce\" : \"5\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"10000000\" , \"asset\" : { \"count\" : 2 , \"votes\" : [ \"-cactus1549\" , \"+sl33p\" ] } } Serialized \u00b6 ff033f0100000003000500000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192809698000000000000020b00636163747573313534390601736c333370 Deserialized \u00b6 Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0300 Nonce: [9] 8 0x0200000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x8096980000000000 VendorField Length: [58] 1 0x00 Vote Count: [59] 1 0x02 Vote 1 Length: [60] 1 0x0b Vote 1 Type: [61] 1 0x00 Vote 1: [62] 10 0x63616374757331353439 Vote 2 Length: [72] 1 0x06 Vote 2 Type: [73] 1 0x01 Vote 2: [74] 10 0x736C333370","title":"Transaction Types - Vote / Unvote / Switchvote"},{"location":"core/transactions/types/vote-unvote/#vote-unvote-switchvote","text":"TypeGroup Type 1 3 A key feature of the SXP DPoS model is that each address can vote for one delegate of their choosing to secure the network. A vote and unvote transaction type is therefore necessary to enable this functionality. Once an address votes for a delegate, funds can enter and leave the address as needed, and vote weight adjusts automatically. Voting does not send funds to the delegate\u2019s SXP address in question - it only assigns vote weight Holders of SXP vote through their wallets for delegates who secure the network, insert blocks into the ledger, and create new SXP. The top 53 vote earners are named elected forging delegates. Number of delegates is related to DPOS mechanism configuration. References Improvement Proposal AIP11 , AIP29 API Endpoints Link AJV Schema Base | Vote / Unvote / Switchvote","title":"Vote / Unvote / Switchvote"},{"location":"core/transactions/types/vote-unvote/#vote","text":"","title":"Vote"},{"location":"core/transactions/types/vote-unvote/#json","text":"{ \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 3 , \"nonce\" : \"4\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"10000000\" , \"asset\" : { \"count\" : 1 , \"votes\" : [ \"+cactus1549\" ] } }","title":"JSON"},{"location":"core/transactions/types/vote-unvote/#serialized","text":"ff033f0100000003000400000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192809698000000000000010b0163616374757331353439","title":"Serialized"},{"location":"core/transactions/types/vote-unvote/#deserialized","text":"Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0300 Nonce: [9] 8 0x0400000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x8096980000000000 VendorField Length: [58] 1 0x00 Vote Count: [59] 1 0x01 Vote Length: [60] 1 0x0b Vote Type: [61] 1 0x01 Vote: [62] 5 0x63616374757331353439","title":"Deserialized"},{"location":"core/transactions/types/vote-unvote/#unvote","text":"","title":"Unvote"},{"location":"core/transactions/types/vote-unvote/#json_1","text":"{ \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 3 , \"nonce\" : \"5\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"10000000\" , \"asset\" : { \"count\" : 1 , \"votes\" : [ \"-cactus1549\" ] } }","title":"JSON"},{"location":"core/transactions/types/vote-unvote/#serialized_1","text":"ff033f0100000003000500000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192809698000000000000010b0063616374757331353439","title":"Serialized"},{"location":"core/transactions/types/vote-unvote/#deserialized_1","text":"Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0300 Nonce: [9] 8 0x0400000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x8096980000000000 VendorField Length: [58] 1 0x00 Vote Count: [59] 1 0x01 Vote Length: [60] 1 0x0b Vote Type: [61] 1 0x00 Vote: [62] 5 0x63616374757331353439","title":"Deserialized"},{"location":"core/transactions/types/vote-unvote/#switch-vote","text":"","title":"Switch Vote"},{"location":"core/transactions/types/vote-unvote/#json_2","text":"{ \"version\" : 3 , \"network\" : 63 , \"type\" : 3 , \"nonce\" : \"5\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"10000000\" , \"asset\" : { \"count\" : 2 , \"votes\" : [ \"-cactus1549\" , \"+sl33p\" ] } }","title":"JSON"},{"location":"core/transactions/types/vote-unvote/#serialized_2","text":"ff033f0100000003000500000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192809698000000000000020b00636163747573313534390601736c333370","title":"Serialized"},{"location":"core/transactions/types/vote-unvote/#deserialized_2","text":"Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0300 Nonce: [9] 8 0x0200000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x8096980000000000 VendorField Length: [58] 1 0x00 Vote Count: [59] 1 0x02 Vote 1 Length: [60] 1 0x0b Vote 1 Type: [61] 1 0x00 Vote 1: [62] 10 0x63616374757331353439 Vote 2 Length: [72] 1 0x06 Vote 2 Type: [73] 1 0x01 Vote 2: [74] 10 0x736C333370","title":"Deserialized"},{"location":"core/updates/3.3.0/","text":"Release 3.3.0 \u00b6 \u26a0\ufe0f Note that the command is not the usual solar update ! \u26a0\ufe0f \u2757 Time critical update - This new release will activate new milestones at block height 671,988 (estimated at around 30 th May 2022 at 00:00 UTC). \u2757 Changes since 3.2.5: \u00b6 New Features \u00b6 automatic allocation of 5% of forging rewards for development funding following a governance vote on the issue bip340 schnorr signatures now used for improved security and less technical debt empty but valid wallets now show as empty wallets rather than returning an error via the api last block id string is now returned in the delegate attribute and in the api rather than the whole block more hashing algorithms included for hashed timelock contract transactions for better interoperability new voters attribute added to the api response for delegates to show how many voters each delegate has p2p port of a node can now be freely changed without any problems vendorfield is now supported in every transaction type Bug Fixes \u00b6 correct fee burning database index is now dropped last block data is correctly updated in the delegate attribute following a rollback more resilient fork recovery updater reruns pnpm install after building to resolve some dependency issues Maintenance \u00b6 added filtering by transaction version to the swagger page on the api block headers now only include specific properties blocks are now broadcasted to all peers rather than just a few blocks are only broadcasted if there are >= 2 seconds remaining in the slot core transaction handlers have been unified delegate name now used in the vote attribute rather than the public key legacy code removed or fixed where appropriate multisignature registrations reactivated and no longer use participant signatures in the registration transaction peers are always polled for blocks in case a node does not receive a block normally removed the incompatible transaction handler inherited from upstream code as it does not apply here serialised vote payloads no longer have 0xff padding in v3 transactions for the delegate name upstream wallet support is now removed due to breaking changes in core voting using the public key asset is disabled in v3 transactions Update Instructions \u00b6 Please update your mainnet node with the following command. solar plugin:update @alessiodf/rocket-boot && solar rocket:purge --force && solar update","title":"3.3.0"},{"location":"core/updates/3.3.0/#release-330","text":"\u26a0\ufe0f Note that the command is not the usual solar update ! \u26a0\ufe0f \u2757 Time critical update - This new release will activate new milestones at block height 671,988 (estimated at around 30 th May 2022 at 00:00 UTC). \u2757","title":"Release 3.3.0"},{"location":"core/updates/3.3.0/#changes-since-325","text":"","title":"Changes since 3.2.5:"},{"location":"core/updates/3.3.0/#new-features","text":"automatic allocation of 5% of forging rewards for development funding following a governance vote on the issue bip340 schnorr signatures now used for improved security and less technical debt empty but valid wallets now show as empty wallets rather than returning an error via the api last block id string is now returned in the delegate attribute and in the api rather than the whole block more hashing algorithms included for hashed timelock contract transactions for better interoperability new voters attribute added to the api response for delegates to show how many voters each delegate has p2p port of a node can now be freely changed without any problems vendorfield is now supported in every transaction type","title":"New Features"},{"location":"core/updates/3.3.0/#bug-fixes","text":"correct fee burning database index is now dropped last block data is correctly updated in the delegate attribute following a rollback more resilient fork recovery updater reruns pnpm install after building to resolve some dependency issues","title":"Bug Fixes"},{"location":"core/updates/3.3.0/#maintenance","text":"added filtering by transaction version to the swagger page on the api block headers now only include specific properties blocks are now broadcasted to all peers rather than just a few blocks are only broadcasted if there are >= 2 seconds remaining in the slot core transaction handlers have been unified delegate name now used in the vote attribute rather than the public key legacy code removed or fixed where appropriate multisignature registrations reactivated and no longer use participant signatures in the registration transaction peers are always polled for blocks in case a node does not receive a block normally removed the incompatible transaction handler inherited from upstream code as it does not apply here serialised vote payloads no longer have 0xff padding in v3 transactions for the delegate name upstream wallet support is now removed due to breaking changes in core voting using the public key asset is disabled in v3 transactions","title":"Maintenance"},{"location":"core/updates/3.3.0/#update-instructions","text":"Please update your mainnet node with the following command. solar plugin:update @alessiodf/rocket-boot && solar rocket:purge --force && solar update","title":"Update Instructions"},{"location":"core/updates/4.0.1/","text":"Release 4.0.1 Nebula \u00b6 \u2757 Time-critical update - The new voting mechanism, new transfers, and temporary delegate resignations will be available from block 1,175,000 on 15 th July 2022.\u2757 This page will provide information and guidance on the following: Changes since 3.3.0 Core 4.x Requirements Core 4.x Update Instructions v3 Transaction Changes The 'Memo' Transfer Vote Delegate Resignation Changes since 3.3.0 \u00b6 This is the first major update of Solar Core since the launch of Mainnet. Click on the following link to read a full summary of the 4.x release: https://github.com/Solar-network/core/pull/97 Highlights \u00b6 Introduction of v3 transactions, featuring: Combined Transfer and MultiPayment transactions New Vote transaction type New 'Temporary' and 'Permanent' 'Delegate Resignation' types Optional Transaction Memos Improved Core Crypto web browser compatibility Tighter schema validation Near-instantaneous fork recovery CPU count-based service worker allocation Improved logging and errors descriptions See all of the changes -- including hundreds of improvements, optimisations, and bug fixes -- here: https://github.com/Solar-network/core/compare/3.3.0...4.0.1 Requirements \u00b6 Supported OS Release Ubuntu >= 20.x Debian >= 10.x \u2757 Note that Ubuntu <= 18.x and Debian <= 9 are no longer supported. \u2757 Relay Requirements Recommended Minimum CPUs 4 2 RAM 8GB 4GB HDD 100GB - 120GB 80GB Forger Requirements Recommended Minimum CPUs 4 ( dedicated ) 2 ( dedicated ) RAM 16GB 8GB HDD 100GB - 120GB ( SSD ) 80GB ( SSD ) Update Instructions \u00b6 \u26a0\ufe0f Note that the command is not the usual solar update ! \u26a0\ufe0f Update your Mainnet node with the following command: wget -4O- https://gist.githubusercontent.com/alessiodf/4faa98978ce547c1d8e96696f1d84e97/raw/cd9e7b83de0e5ac26a2e745d9452c9ed1d5c5195/update.sh | bash v3 Transaction Changes \u00b6 There are several key transaction changes to be aware of in Solar Core 4.x . The 'Memo' \u00b6 All Solar transactions now contain a special 255-byte data field known as a 'Memo' and allows raw data, code, or plain text to be stored on the blockchain. The Memo is optional, public, and immutable. This was previously known as the vendorField and was only available on certain transaction types. v3 Transfer \u00b6 TypeGroup Type 1 6 One of the most important changes is the introduction of the new Transfer transaction type. Formerly, a single send transaction made use of v2-style Transfers (Type 0) whereas two or more sends required using a v2 MultiPayment transaction (Type 6). Under Solar Core 4.x , these have been combined under the MultiPayment pattern and are now known simply as 'Transfer' (Type 6), removing the unnecessary requirement of two separate transaction types. Visit Solar Core's documentation to see an example of the v3 Transfer structure here . TypeScript Code Example: const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://sxp.testnet.sh/api\" ); // Set the network configuration Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . Transfer () . version ( 3 ) . nonce ( senderNonce . toFixed ()) . memo ( \"This is an example memo\" ) . addTransfer ( \"Address of Recipient Wallet 1\" , 1 * 1e8 ) . addTransfer ( \"Address of Recipient Wallet 2\" , 1 * 1e8 ) . addTransfer ( \"Address of Recipient Wallet 3\" , 1 * 1e8 ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); See the Python code example here . v3 Vote \u00b6 TypeGroup Type 2 2 Voting has undergone a significant conceptual change in Core 4.x . Previously, a wallet could vote for only one delegate at a time. Under the new scheme, a wallet can vote for up to 53 delegates in total as well as optionally customise the distribution of their vote weight. For instance, the default behaviour of voting for three delegates where no custom distribution is specified would look as follows: { ... \"votes\" : { \"cactus1549\" : 33.34 , \"gym\" : 33.33 , \"sl33p\" : 33.33 } ... } Note that the vote weight is distributed evenly and uses a natural sorting order. Because the vote weight must total 100%, the remaining 0.01% is subsequently distributed in ascending order. When manually specifying vote weight distribution, natural sorting is still used; however, vote weight is prioritised while determining the list's order. For example: { ... \"votes\" : { \"sl33p\" : 40.50 , \"cactus1549\" : 29.75 , \"gym\" : 29.75 } ... } Visit Solar Core's documentation to see an example of the v3 Vote structure here . v3 Delegate Resignation Types \u00b6 TypeGroup Type 1 7 Previously, v2-style Delegate Resignation was a permanent action. There was no way for a resigned delegate to reinstate their eligibility to receive votes and produce blocks. This was only useful in cases where a delegate no longer wanted to participate in network consensus. Solar Core 4.x adds a new 'Temporary' resignation option where their resigned status may be 'Revoked' after at least two rounds (~106 blocks). This is useful when a delegate may only wish to resign for a short time without negatively impacting the network (e.g., missing blocks) and can be for a variety of reasons, from temporary node maintenance to personal/private matters. Resignation Type Value Description Temporary 0 Resign only for a short time. Delegate will be temporarily blocked from receiving votes or forging. (the default when no resign type is declared) Permanent 1 Irreversible. Delegate will no longer be allowed to receive votes or forge. Revoke 2 Reverses a temporary resignation. Visit Solar Core's documentation to see an example of the v3 Delegate Resignation structure here .","title":"Release 4.0.1 Nebula"},{"location":"core/updates/4.0.1/#release-401-nebula","text":"\u2757 Time-critical update - The new voting mechanism, new transfers, and temporary delegate resignations will be available from block 1,175,000 on 15 th July 2022.\u2757 This page will provide information and guidance on the following: Changes since 3.3.0 Core 4.x Requirements Core 4.x Update Instructions v3 Transaction Changes The 'Memo' Transfer Vote Delegate Resignation","title":"Release 4.0.1 Nebula"},{"location":"core/updates/4.0.1/#changes-since-330","text":"This is the first major update of Solar Core since the launch of Mainnet. Click on the following link to read a full summary of the 4.x release: https://github.com/Solar-network/core/pull/97","title":"Changes since 3.3.0"},{"location":"core/updates/4.0.1/#highlights","text":"Introduction of v3 transactions, featuring: Combined Transfer and MultiPayment transactions New Vote transaction type New 'Temporary' and 'Permanent' 'Delegate Resignation' types Optional Transaction Memos Improved Core Crypto web browser compatibility Tighter schema validation Near-instantaneous fork recovery CPU count-based service worker allocation Improved logging and errors descriptions See all of the changes -- including hundreds of improvements, optimisations, and bug fixes -- here: https://github.com/Solar-network/core/compare/3.3.0...4.0.1","title":"Highlights"},{"location":"core/updates/4.0.1/#requirements","text":"Supported OS Release Ubuntu >= 20.x Debian >= 10.x \u2757 Note that Ubuntu <= 18.x and Debian <= 9 are no longer supported. \u2757 Relay Requirements Recommended Minimum CPUs 4 2 RAM 8GB 4GB HDD 100GB - 120GB 80GB Forger Requirements Recommended Minimum CPUs 4 ( dedicated ) 2 ( dedicated ) RAM 16GB 8GB HDD 100GB - 120GB ( SSD ) 80GB ( SSD )","title":"Requirements"},{"location":"core/updates/4.0.1/#update-instructions","text":"\u26a0\ufe0f Note that the command is not the usual solar update ! \u26a0\ufe0f Update your Mainnet node with the following command: wget -4O- https://gist.githubusercontent.com/alessiodf/4faa98978ce547c1d8e96696f1d84e97/raw/cd9e7b83de0e5ac26a2e745d9452c9ed1d5c5195/update.sh | bash","title":"Update Instructions"},{"location":"core/updates/4.0.1/#v3-transaction-changes","text":"There are several key transaction changes to be aware of in Solar Core 4.x .","title":"v3 Transaction Changes"},{"location":"core/updates/4.0.1/#the-memo","text":"All Solar transactions now contain a special 255-byte data field known as a 'Memo' and allows raw data, code, or plain text to be stored on the blockchain. The Memo is optional, public, and immutable. This was previously known as the vendorField and was only available on certain transaction types.","title":"The 'Memo'"},{"location":"core/updates/4.0.1/#v3-transfer","text":"TypeGroup Type 1 6 One of the most important changes is the introduction of the new Transfer transaction type. Formerly, a single send transaction made use of v2-style Transfers (Type 0) whereas two or more sends required using a v2 MultiPayment transaction (Type 6). Under Solar Core 4.x , these have been combined under the MultiPayment pattern and are now known simply as 'Transfer' (Type 6), removing the unnecessary requirement of two separate transaction types. Visit Solar Core's documentation to see an example of the v3 Transfer structure here . TypeScript Code Example: const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://sxp.testnet.sh/api\" ); // Set the network configuration Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . Transfer () . version ( 3 ) . nonce ( senderNonce . toFixed ()) . memo ( \"This is an example memo\" ) . addTransfer ( \"Address of Recipient Wallet 1\" , 1 * 1e8 ) . addTransfer ( \"Address of Recipient Wallet 2\" , 1 * 1e8 ) . addTransfer ( \"Address of Recipient Wallet 3\" , 1 * 1e8 ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); See the Python code example here .","title":"v3 Transfer"},{"location":"core/updates/4.0.1/#v3-vote","text":"TypeGroup Type 2 2 Voting has undergone a significant conceptual change in Core 4.x . Previously, a wallet could vote for only one delegate at a time. Under the new scheme, a wallet can vote for up to 53 delegates in total as well as optionally customise the distribution of their vote weight. For instance, the default behaviour of voting for three delegates where no custom distribution is specified would look as follows: { ... \"votes\" : { \"cactus1549\" : 33.34 , \"gym\" : 33.33 , \"sl33p\" : 33.33 } ... } Note that the vote weight is distributed evenly and uses a natural sorting order. Because the vote weight must total 100%, the remaining 0.01% is subsequently distributed in ascending order. When manually specifying vote weight distribution, natural sorting is still used; however, vote weight is prioritised while determining the list's order. For example: { ... \"votes\" : { \"sl33p\" : 40.50 , \"cactus1549\" : 29.75 , \"gym\" : 29.75 } ... } Visit Solar Core's documentation to see an example of the v3 Vote structure here .","title":"v3 Vote"},{"location":"core/updates/4.0.1/#v3-delegate-resignation-types","text":"TypeGroup Type 1 7 Previously, v2-style Delegate Resignation was a permanent action. There was no way for a resigned delegate to reinstate their eligibility to receive votes and produce blocks. This was only useful in cases where a delegate no longer wanted to participate in network consensus. Solar Core 4.x adds a new 'Temporary' resignation option where their resigned status may be 'Revoked' after at least two rounds (~106 blocks). This is useful when a delegate may only wish to resign for a short time without negatively impacting the network (e.g., missing blocks) and can be for a variety of reasons, from temporary node maintenance to personal/private matters. Resignation Type Value Description Temporary 0 Resign only for a short time. Delegate will be temporarily blocked from receiving votes or forging. (the default when no resign type is declared) Permanent 1 Irreversible. Delegate will no longer be allowed to receive votes or forge. Revoke 2 Reverses a temporary resignation. Visit Solar Core's documentation to see an example of the v3 Delegate Resignation structure here .","title":"v3 Delegate Resignation Types"},{"location":"desktop-wallet/intro/","text":"Introduction \u00b6 What Is It? \u00b6 The SXP Desktop Wallet is an application which allows you to manage SXP transactions. It provides an extensive set of functionalities, including management of profiles and wallets, the creation of both online and offline transactions, wallet summary, stylistic customizations, multilingual support, various currency integrations including BTC and much more! Getting Started \u00b6 To get started with the SXP Desktop Wallet, follow the documentation below for guides on Installation, Wallet Navigation, Creating Wallets and more... Transactions \u00b6 The SXP Desktop Wallet enables you to send a wide variety of transactions on the SXP Blockchain and other Solar Core based blockchains. Follow the guides below for information on each transaction. Developer Guides \u00b6 The SXP Desktop Wallet offers a wide range of customization which empowers developers to create Plugins to enhance the experience within the Wallet from Games, Utilities and Theme's. Follow the guides below to get started with development within the SXP Desktop Wallet. Support \u00b6","title":"Introduction"},{"location":"desktop-wallet/intro/#introduction","text":"","title":"Introduction"},{"location":"desktop-wallet/intro/#what-is-it","text":"The SXP Desktop Wallet is an application which allows you to manage SXP transactions. It provides an extensive set of functionalities, including management of profiles and wallets, the creation of both online and offline transactions, wallet summary, stylistic customizations, multilingual support, various currency integrations including BTC and much more!","title":"What Is It?"},{"location":"desktop-wallet/intro/#getting-started","text":"To get started with the SXP Desktop Wallet, follow the documentation below for guides on Installation, Wallet Navigation, Creating Wallets and more...","title":"Getting Started"},{"location":"desktop-wallet/intro/#transactions","text":"The SXP Desktop Wallet enables you to send a wide variety of transactions on the SXP Blockchain and other Solar Core based blockchains. Follow the guides below for information on each transaction.","title":"Transactions"},{"location":"desktop-wallet/intro/#developer-guides","text":"The SXP Desktop Wallet offers a wide range of customization which empowers developers to create Plugins to enhance the experience within the Wallet from Games, Utilities and Theme's. Follow the guides below to get started with development within the SXP Desktop Wallet.","title":"Developer Guides"},{"location":"desktop-wallet/intro/#support","text":"","title":"Support"},{"location":"desktop-wallet/introduction-to-solar-rewards/","text":"An Introduction to SXP Rewards (Staking) \u00b6 Solar is a sovereign blockchain with a native cryptoasset called SXP. It is based on the Delegated-Proof-of-Stake (DPoS) consensus mechanism and has 53 active Delegates (Validators) who secure the network. In this article, we will discuss how block rewards work within the Solar blockchain and how you can earn a portion of the rewards by becoming an active delegate or voting with your SXP coins. Staking Considerations \u00b6 SXP Staking is unique in that user funds are not required to be sent or locked. When a user casts a vote, their vote-weight is assigned to the network Validator (Delegate) of their choice. A user\u2019s vote-weight adjusts automatically as funds are sent and received, and there is no need to re-vote or un-stake. To change a vote, a user simply un-votes their current Validator and elects another by casting a new vote transaction. For more information about voting and unvoting, please visit: How to Vote or Unvote a Delegate Staking Fees \u00b6 The cost of a vote covers the transaction itself. There is no requirement to send or lock additional funds in order to participate in consensus. This transaction fee is awarded to the Validator who forges the transaction in a given block. For more information about fees, please visit: Transaction Fees Block Rewards \u00b6 Solar is a sovereign blockchain that is validated by 53 active Delegates. Each Delegate will submit (1) block per round. A round consists of 53 blocks. Each block on Solar has a block time of 8 seconds. Each block awards the active delegate who submits the block a dynamic and rank-based block reward with the 10% any transaction fees from that block. Block Rewards are inflationary coins, meaning the total SXP supply is increased by between x and x SXP every block. This serves as a form of consistent inflation that reduces over time due to the non-fluctuating rate of rewards. On Solar, 100% of the block reward goes to the Validator. Note: There are no \"halvenings\" of block rewards on Solar . Reward Sharing on Solar \u00b6 As previously stated, block rewards and transaction fees are awarded to the active delegate responsible for reporting a given block. We call this combination of the block reward and 10% of any fees the total reward. On Solar, many of these delegates choose to take a small commission from the total reward and share the remaining after commission reward (ACR) with their voters. This form of reward sharing is completely optional and not all delegates will share their rewards. Reward sharing can vary wildly with delegates taking commissions of anywhere from 0-100% of the total rewards. You can also view current Solar delegates on the Delegates page inside the SXP Explorer . Contact Us \u00b6 If you still have questions or need more information, please feel free to ask the community .","title":"An Introduction to SXP Rewards (Staking)"},{"location":"desktop-wallet/introduction-to-solar-rewards/#an-introduction-to-sxp-rewards-staking","text":"Solar is a sovereign blockchain with a native cryptoasset called SXP. It is based on the Delegated-Proof-of-Stake (DPoS) consensus mechanism and has 53 active Delegates (Validators) who secure the network. In this article, we will discuss how block rewards work within the Solar blockchain and how you can earn a portion of the rewards by becoming an active delegate or voting with your SXP coins.","title":"An Introduction to SXP Rewards (Staking)"},{"location":"desktop-wallet/introduction-to-solar-rewards/#staking-considerations","text":"SXP Staking is unique in that user funds are not required to be sent or locked. When a user casts a vote, their vote-weight is assigned to the network Validator (Delegate) of their choice. A user\u2019s vote-weight adjusts automatically as funds are sent and received, and there is no need to re-vote or un-stake. To change a vote, a user simply un-votes their current Validator and elects another by casting a new vote transaction. For more information about voting and unvoting, please visit: How to Vote or Unvote a Delegate","title":"Staking Considerations"},{"location":"desktop-wallet/introduction-to-solar-rewards/#staking-fees","text":"The cost of a vote covers the transaction itself. There is no requirement to send or lock additional funds in order to participate in consensus. This transaction fee is awarded to the Validator who forges the transaction in a given block. For more information about fees, please visit: Transaction Fees","title":"Staking Fees"},{"location":"desktop-wallet/introduction-to-solar-rewards/#block-rewards","text":"Solar is a sovereign blockchain that is validated by 53 active Delegates. Each Delegate will submit (1) block per round. A round consists of 53 blocks. Each block on Solar has a block time of 8 seconds. Each block awards the active delegate who submits the block a dynamic and rank-based block reward with the 10% any transaction fees from that block. Block Rewards are inflationary coins, meaning the total SXP supply is increased by between x and x SXP every block. This serves as a form of consistent inflation that reduces over time due to the non-fluctuating rate of rewards. On Solar, 100% of the block reward goes to the Validator. Note: There are no \"halvenings\" of block rewards on Solar .","title":"Block Rewards"},{"location":"desktop-wallet/introduction-to-solar-rewards/#reward-sharing-on-solar","text":"As previously stated, block rewards and transaction fees are awarded to the active delegate responsible for reporting a given block. We call this combination of the block reward and 10% of any fees the total reward. On Solar, many of these delegates choose to take a small commission from the total reward and share the remaining after commission reward (ACR) with their voters. This form of reward sharing is completely optional and not all delegates will share their rewards. Reward sharing can vary wildly with delegates taking commissions of anywhere from 0-100% of the total rewards. You can also view current Solar delegates on the Delegates page inside the SXP Explorer .","title":"Reward Sharing on Solar"},{"location":"desktop-wallet/introduction-to-solar-rewards/#contact-us","text":"If you still have questions or need more information, please feel free to ask the community .","title":"Contact Us"},{"location":"desktop-wallet/support/troubleshooting/","text":"title: Troubleshooting # Troubleshooting This page will cover common issues related to the SXP Desktop Wallet v2.x . If your issue is not covered here, ask the community here ! ## Getting Started A user experiencing unexpected errors should first check that their apps and software are up-to-date. ### Desktop Wallet Software First, check that the latest version of the SXP Desktop Wallet is installed. All official Desktop Wallet releases can be found here If your issue is not covered here, please contact us using the \u2018Technical Support\u2019 form found here !","title":"Troubleshooting"},{"location":"desktop-wallet/user-guides/how-to-add-a-contact/","text":"How to Add a Contact? \u00b6 The application provides you a neat interface to add addresses to your contact list. This feature enables you to aggregate all of the addresses which you may transact with or be interested in. Adding a Contact \u00b6","title":"How to Add a Contact?"},{"location":"desktop-wallet/user-guides/how-to-add-a-contact/#how-to-add-a-contact","text":"The application provides you a neat interface to add addresses to your contact list. This feature enables you to aggregate all of the addresses which you may transact with or be interested in.","title":"How to Add a Contact?"},{"location":"desktop-wallet/user-guides/how-to-add-a-contact/#adding-a-contact","text":"","title":"Adding a Contact"},{"location":"desktop-wallet/user-guides/how-to-create-or-import-wallets/","text":"How to Create or Import a Wallet? \u00b6 The SXP Desktop Wallet allows you to both create new wallets and import existing ones. You can begin either process by clicking the appropriate button at the top of the sidebar when on the app dashboard. Creating a New Wallet \u00b6 Go to your Portfolio Click on \"Create\" button Select SXP as Cryptoasset Save your passphrase. Be sure it's a safe place! Confirm your passphrase, by selecting the prompted words. Great! You created a new wallet. Importing Your Wallet \u00b6 Provide the mnemonic of the wallet Click on continue, and your wallet is imported!","title":"How to Create or Import a Wallet?"},{"location":"desktop-wallet/user-guides/how-to-create-or-import-wallets/#how-to-create-or-import-a-wallet","text":"The SXP Desktop Wallet allows you to both create new wallets and import existing ones. You can begin either process by clicking the appropriate button at the top of the sidebar when on the app dashboard.","title":"How to Create or Import a Wallet?"},{"location":"desktop-wallet/user-guides/how-to-create-or-import-wallets/#creating-a-new-wallet","text":"Go to your Portfolio Click on \"Create\" button Select SXP as Cryptoasset Save your passphrase. Be sure it's a safe place! Confirm your passphrase, by selecting the prompted words. Great! You created a new wallet.","title":"Creating a New Wallet"},{"location":"desktop-wallet/user-guides/how-to-create-or-import-wallets/#importing-your-wallet","text":"Provide the mnemonic of the wallet Click on continue, and your wallet is imported!","title":"Importing Your Wallet"},{"location":"desktop-wallet/user-guides/how-to-register-or-resign-delegate/","text":"How to Register or Resign a Delegate? \u00b6 Register as a Delegate \u00b6 Registering as a delegate is a simple transaction. It provides network nodes with a record of the sending address opening itself to accept votes from other wallets. You can only vote for an address that was registered in this fashion. Click on the circle on the top-right Click on \"Delegate Registration\" Enter your mnemonic or password Minimum fee for delegate registration is 75 SXP! For more information about fees, please visit: Transaction Fees Resign your Delegate \u00b6 Delegate Resignation is a new transaction type being offered in Solar Core v2.6 that gives delegates the ability to resign and exclude themselves from the delegate rankings. Open the SXP Desktop Wallet and select the vertical ellipsis icon next to the right of the send button. Select the dropdown menu under Registration and select \"Resign Delegate\" Enter your wallet\u2019s passphrase (or password if you are using encrypted option) and confirm the transaction. Refresh your wallet and you will see that after the next round of forging, your delegate will be marked resigned and no longer counted in the Active Delegate Rankings (Top 51).","title":"How to Register or Resign a Delegate?"},{"location":"desktop-wallet/user-guides/how-to-register-or-resign-delegate/#how-to-register-or-resign-a-delegate","text":"","title":"How to Register or Resign a Delegate?"},{"location":"desktop-wallet/user-guides/how-to-register-or-resign-delegate/#register-as-a-delegate","text":"Registering as a delegate is a simple transaction. It provides network nodes with a record of the sending address opening itself to accept votes from other wallets. You can only vote for an address that was registered in this fashion. Click on the circle on the top-right Click on \"Delegate Registration\" Enter your mnemonic or password Minimum fee for delegate registration is 75 SXP! For more information about fees, please visit: Transaction Fees","title":"Register as a Delegate"},{"location":"desktop-wallet/user-guides/how-to-register-or-resign-delegate/#resign-your-delegate","text":"Delegate Resignation is a new transaction type being offered in Solar Core v2.6 that gives delegates the ability to resign and exclude themselves from the delegate rankings. Open the SXP Desktop Wallet and select the vertical ellipsis icon next to the right of the send button. Select the dropdown menu under Registration and select \"Resign Delegate\" Enter your wallet\u2019s passphrase (or password if you are using encrypted option) and confirm the transaction. Refresh your wallet and you will see that after the next round of forging, your delegate will be marked resigned and no longer counted in the Active Delegate Rankings (Top 51).","title":"Resign your Delegate"},{"location":"desktop-wallet/user-guides/how-to-register-second-passphrase/","text":"How to Register a Second Passphrase? \u00b6 Security is critical. By issuing a second signature transaction, you tell network nodes to verify that every transaction coming from your wallet is also signed by another Passphrase. Register a Second Passphrase \u00b6 For more information about fees, please visit: Transaction Fees","title":"How to Register a Second Passphrase?"},{"location":"desktop-wallet/user-guides/how-to-register-second-passphrase/#how-to-register-a-second-passphrase","text":"Security is critical. By issuing a second signature transaction, you tell network nodes to verify that every transaction coming from your wallet is also signed by another Passphrase.","title":"How to Register a Second Passphrase?"},{"location":"desktop-wallet/user-guides/how-to-register-second-passphrase/#register-a-second-passphrase","text":"For more information about fees, please visit: Transaction Fees","title":"Register a Second Passphrase"},{"location":"desktop-wallet/user-guides/how-to-send/","text":"How to Send an SXP Transfer? \u00b6 Transferring SXP from your wallet is the most common type of transaction. You can quickly send a transfer by clicking on the Send button in the header of the wallet detail page. This will bring up a prompt, on which you can fill in the required information to create a transfer transaction. For more information about fees, please visit: Transaction Fees Upon clicking Next , you will have to review the transfer transaction's details and can proceed by clicking the \"Continue\" button. Enter your mnemonic or passsword and voila!","title":"How to Send an SXP Transfer?"},{"location":"desktop-wallet/user-guides/how-to-send/#how-to-send-an-sxp-transfer","text":"Transferring SXP from your wallet is the most common type of transaction. You can quickly send a transfer by clicking on the Send button in the header of the wallet detail page. This will bring up a prompt, on which you can fill in the required information to create a transfer transaction. For more information about fees, please visit: Transaction Fees Upon clicking Next , you will have to review the transfer transaction's details and can proceed by clicking the \"Continue\" button. Enter your mnemonic or passsword and voila!","title":"How to Send an SXP Transfer?"},{"location":"desktop-wallet/user-guides/how-to-sign-and-verify/","text":"How to Sign and Verify Messages? \u00b6 The wallet allows you to create and sign a message that other users will be able to verify as authentically yours. Message signing and verifying is all done under the Sign tab of the wallet detail page. Signing a Message \u00b6 With a signed message, others can verify that a given message and signature combination originate from you. Verifying a Message \u00b6 To verify a message that was signed by a different wallet, you need the wallet's public key, the original message, and the resulting signature. The public key of a wallet is much like the address, except it doesn't follow the same format and is not shown by default in the Desktop Wallet. You can view your wallet's public key by clicking the key icon next to your wallet's address in the wallet detail page's header. The SXP network will only know your public key once you have sent a transaction. For demonstration purposes, the images below are shown from the perspective of a second wallet, assuming the necessary details to verify the message were provided to the verifying user.","title":"How to Sign and Verify Messages?"},{"location":"desktop-wallet/user-guides/how-to-sign-and-verify/#how-to-sign-and-verify-messages","text":"The wallet allows you to create and sign a message that other users will be able to verify as authentically yours. Message signing and verifying is all done under the Sign tab of the wallet detail page.","title":"How to Sign and Verify Messages?"},{"location":"desktop-wallet/user-guides/how-to-sign-and-verify/#signing-a-message","text":"With a signed message, others can verify that a given message and signature combination originate from you.","title":"Signing a Message"},{"location":"desktop-wallet/user-guides/how-to-sign-and-verify/#verifying-a-message","text":"To verify a message that was signed by a different wallet, you need the wallet's public key, the original message, and the resulting signature. The public key of a wallet is much like the address, except it doesn't follow the same format and is not shown by default in the Desktop Wallet. You can view your wallet's public key by clicking the key icon next to your wallet's address in the wallet detail page's header. The SXP network will only know your public key once you have sent a transaction. For demonstration purposes, the images below are shown from the perspective of a second wallet, assuming the necessary details to verify the message were provided to the verifying user.","title":"Verifying a Message"},{"location":"desktop-wallet/user-guides/how-to-vote/","text":"How to Vote in the Desktop Wallet? \u00b6 General Information \u00b6 You can use your SXP to vote or a delegate. Some basic voting info: 1 SXP address can vote for only one delegate at a time \u00b6 If you wish to vote for more than one delegate you can create multiple wallets, split your SXP among those wallets and vote for a different delegate with each wallet. For example, if you have 1000 SXP, you can vote for one delegate with all of your SXP in one wallet, or you can divide your SXP into two wallets of 500 SXP each and vote for two different delegates. You can create as many wallets as you want and divide your SXP among them in any proportion you choose. 1 SXP equals a voting weight of 1 \u00b6 The more SXP you hold, the more voting weight you possess. If you split your SXP into multiple wallets, your voting power divides proportionally among those wallets. For example, if you have 1,000 SXP your voting power is equal to 1,000 SXP. If you split your SXP into two wallets, each will have a voting power of 500 SXP. Each vote or comes with a fee \u00b6 Each transaction in the SXP network costs a certain amount of SXP. With the implementation of dynamic fees, this cost will become adjustable. You can choose how much you want to spend for each specific transaction, even for voting and for un-voting. For more information about staking, please visit: SXP Rewards (Staking) Whom to Vote For? \u00b6 Visit SXP Delegates , our community-run delegate resource, for more information on delegate proposals. From the current list of delegates, vote according to your preferences. You can also see the list of currently active delegates on our delegate monitor . Voting for a Delegate \u00b6 For more information about fees, please visit: Transaction Fees Remember that you can always change your vote!","title":"How to Vote or Unvote in the Desktop Wallet?"},{"location":"desktop-wallet/user-guides/how-to-vote/#how-to-vote-in-the-desktop-wallet","text":"","title":"How to Vote in the Desktop Wallet?"},{"location":"desktop-wallet/user-guides/how-to-vote/#general-information","text":"You can use your SXP to vote or a delegate. Some basic voting info:","title":"General Information"},{"location":"desktop-wallet/user-guides/how-to-vote/#1-sxp-address-can-vote-for-only-one-delegate-at-a-time","text":"If you wish to vote for more than one delegate you can create multiple wallets, split your SXP among those wallets and vote for a different delegate with each wallet. For example, if you have 1000 SXP, you can vote for one delegate with all of your SXP in one wallet, or you can divide your SXP into two wallets of 500 SXP each and vote for two different delegates. You can create as many wallets as you want and divide your SXP among them in any proportion you choose.","title":"1 SXP address can vote for only one delegate at a time"},{"location":"desktop-wallet/user-guides/how-to-vote/#1-sxp-equals-a-voting-weight-of-1","text":"The more SXP you hold, the more voting weight you possess. If you split your SXP into multiple wallets, your voting power divides proportionally among those wallets. For example, if you have 1,000 SXP your voting power is equal to 1,000 SXP. If you split your SXP into two wallets, each will have a voting power of 500 SXP.","title":"1 SXP equals a voting weight of 1"},{"location":"desktop-wallet/user-guides/how-to-vote/#each-vote-or-comes-with-a-fee","text":"Each transaction in the SXP network costs a certain amount of SXP. With the implementation of dynamic fees, this cost will become adjustable. You can choose how much you want to spend for each specific transaction, even for voting and for un-voting. For more information about staking, please visit: SXP Rewards (Staking)","title":"Each vote or comes with a fee"},{"location":"desktop-wallet/user-guides/how-to-vote/#whom-to-vote-for","text":"Visit SXP Delegates , our community-run delegate resource, for more information on delegate proposals. From the current list of delegates, vote according to your preferences. You can also see the list of currently active delegates on our delegate monitor .","title":"Whom to Vote For?"},{"location":"desktop-wallet/user-guides/how-to-vote/#voting-for-a-delegate","text":"For more information about fees, please visit: Transaction Fees Remember that you can always change your vote!","title":"Voting for a Delegate"},{"location":"desktop-wallet/user-guides/ledger-doc/","text":"Solar (SXP) \u00b6 Install the Solar app on your Ledger device to manage and stake your SXP using the Solar Desktop Wallet . The Solar app is developed and supported by the Solar community . SXP accounts cannot be added to Ledger Live. Before you start \u00b6 Set up Ledger Live with your Ledger device. Update the firmware of your Ledger Nano S / Nano S Plus / Nano X . Install the Solar app on your Ledger device \u00b6 Open the Manager in Ledger Live. Connect and unlock your Ledger device. If asked, allow the manager on your device. Find the Solar app in the app catalog. Click the Install button of the app. An installation window appears. Your device will display Processing... The app installation is confirmed. Next steps \u00b6 Check the user guide for step by step instructions. Reach out to the Solar community for support.","title":"Solar (SXP)"},{"location":"desktop-wallet/user-guides/ledger-doc/#solar-sxp","text":"Install the Solar app on your Ledger device to manage and stake your SXP using the Solar Desktop Wallet . The Solar app is developed and supported by the Solar community . SXP accounts cannot be added to Ledger Live.","title":"Solar (SXP)"},{"location":"desktop-wallet/user-guides/ledger-doc/#before-you-start","text":"Set up Ledger Live with your Ledger device. Update the firmware of your Ledger Nano S / Nano S Plus / Nano X .","title":"Before you start"},{"location":"desktop-wallet/user-guides/ledger-doc/#install-the-solar-app-on-your-ledger-device","text":"Open the Manager in Ledger Live. Connect and unlock your Ledger device. If asked, allow the manager on your device. Find the Solar app in the app catalog. Click the Install button of the app. An installation window appears. Your device will display Processing... The app installation is confirmed.","title":"Install the Solar app on your Ledger device"},{"location":"desktop-wallet/user-guides/ledger-doc/#next-steps","text":"Check the user guide for step by step instructions. Reach out to the Solar community for support.","title":"Next steps"},{"location":"desktop-wallet/user-guides/ledger/","text":"Solar Ledger App Guide \u00b6 Introduction \u00b6 This guide will help you get started in using your Ledger hardware wallet with the Solar Desktop Wallet software. Your Ledger device uses an offline, or cold storage, method of generating private keys, making it among the most secure ways to store cryptoassets, including Solar (SXP). It enables you to sign transactions securely, so you can send SXP or vote for your favourite delegates without the need to enter your mnemonic recovery passphrase. This guide covers the following topics: Solar Ledger App Guide Introduction Before you start Installing the Solar Ledger App Viewing Solar (SXP) Ledger Wallets Creating Multiple Solar (SXP) Ledger Wallets Receiving and Sending Solar (SXP) Receiving Solar (SXP) Sending Solar (SXP) Voting / Staking Solar (SXP) Troubleshooting My Solar Desktop Wallet does not show any Ledger wallets Support For any questions, please reach out to the Solar community on Telegram or Discord. Links to both are at the bottom of this guide. Before you start \u00b6 This guide assumes you have the following set up, updated to the latest versions, and ready to use: A Ledger hardware wallet (Nano S/X/S Plus) - https://shop.ledger.com Ledger Live - https://www.ledger.com/ledger-live/download Solar Desktop Wallet - https://solar.org/desktop-wallet Installing the Solar Ledger App \u00b6 You can find and install the Solar Ledger app using Ledger Live. 1. Open Ledger Live Desktop To get started installing the Solar Ledger app, open Ledger Live Desktop and click ' Manager ' in the sidebar menu. 2. Connect your Ledger device Next, connect your Ledger device to your computer and unlock it using your PIN. If asked, follow the on-screen instructions on your Ledger device to \u2018Allow Ledger Manager.' 3. Install the Solar app Using Ledger Live\u2019s App catalog, search for \" Solar \" and click \u2018 Install .\u2019 The Solar app will then be installed on your Ledger device. 4. Close Ledger Live Viewing Solar (SXP) Ledger Wallets \u00b6 After having installed the Solar app, your Ledger device is ready to be used with the Solar Desktop Wallet. 1. Close Ledger Live Desktop Having multiple Ledger-supported applications opened at the same time on your computer can interfere with the connection to your Ledger device, so you'll want to make sure Ledger Live, or any other software that connects to Ledger devices, is closed. 2. Connect your Ledger device If not already connected and unlocked, connect your Ledger device to your computer and unlock it using your PIN. 3. Open the Solar Ledger app Next, open the Solar Ledger app on your Ledger device. Your device should now display \"_Solar is ready \" as shown above._ 4. Open the Solar Desktop Wallet Once initialised, the Solar Desktop Wallet will load and display your Ledger wallets and their SXP balances. Ledger wallets are marked with a red \u2018Ledger\u2019 label. Creating Multiple Solar (SXP) Ledger Wallets \u00b6 Your Ledger device can manage multiple SXP wallet addresses using the \u2018Ledger Options\u2019 menu of the Solar Desktop Wallet. 1. Click \u2018My wallets\u2019 In the Solar Desktop Wallet, click on 'My Wallets.' 2. Click \u2018Ledger Options\u2019 Using the \u2018 Ledger Options \u2019 menu of the Solar Desktop Wallet, click \u2018 Load Additional Ledger Wallets .' 3. Click \u2018Load Wallets\u2019 Finally, type in however many Solar Ledger wallets you'd like to have displayed and click ' Load Wallets .' Receiving and Sending Solar (SXP) \u00b6 A Solar Ledger wallet works just like a traditional passphrase-protected Solar wallet. Receiving Solar (SXP) \u00b6 Receive SXP from anyone by sharing your unique Solar (SXP) Ledger wallet address(es) with them. You can find a wallet's unique address in its banner as seen below. Sending Solar (SXP) \u00b6 Send SXP using your Ledger device and the Solar Desktop Wallet. 1. Open a Solar (SXP) Ledger wallet Using the Solar Desktop Wallet, open the Solar (SXP) Ledger address from which you'd like to send funds, then click ' Send .' Make sure your Ledger device is connected and unlocked and that the Solar app is opened. 2. Enter the Transfer Details Enter the recipient's wallet address (or pick one from your address book) and the amount of SXP you'd like to send. After entering and reviewing the information, click ' Next ' to proceed. 3. Confirm using your Ledger Device You will now be required to review the transaction details using your Ledger device. Take your time clicking through to verify that the transaction details are correct, pay close attention to the recipient\u2019s Solar address and the amount of SXP you're being shown. Make sure that it matches what you entered using the Solar Desktop Wallet. If everything looks correct and you'd like to proceed with sending the transaction, click ' Approve ' using your Ledger device. If the details don't match, you'd like to make a change before sending, or you've simply changed your mind and no longer wish to proceed with the transaction, click ' Reject ' using your Ledger device. 4. Confirm and Send After reviewing and approving the transaction details using your Ledger device, you'll have a third and final opportunity to review the transaction details before broadcasting it to the network. If everything looks good and you'd like to proceed with the transaction, click the \u2018 Send \u2019 button as shown below. Voting / Staking Solar (SXP) \u00b6 You can perform nearly any transaction using your Solar Ledger wallet as you could using a traditional Solar (SXP) wallet, including voting for your favourite delegates to stake your SXP. Learn more about delegates and their proposals and contributions here: https://delegates.solar.org 1. Open a Solar (SXP) Ledger wallet Using the Solar Desktop Wallet, open the Solar (SXP) Ledger address from which you'd like to vote. Then click the ' Delegates ' tab. Make sure your Ledger device is connected and unlocked and that the Solar app is opened. 2. Select your Favourite Delegates Select your favourite delegates from the list--or search for them by name. 3. Confirm the Vote Details After reviewing the vote details, click ' Vote '. 4. Confirm the Vote Fee You'll now be asked to confirm the vote fee. It's recommended to leave this set to the default (\"Average\") fee, there's no need to adjust it at this time. Click ' Next ' to proceed. 5. Confirm using your Ledger Device You will now be required to review the vote details using your Ledger device. Take your time clicking through to verify that the vote details are correct. Make sure that the delegate's username matches the one selected using the Solar Desktop Wallet exactly. If everything looks correct and you'd like to proceed with voting, click ' Approve ' using your Ledger device. If the details don't match, you'd like to change your vote before sending, or you've simply changed your mind and no longer wish to proceed with voting, click ' Reject ' using your Ledger device. 6. Confirm and Send After reviewing and approving the vote details using your Ledger device, you'll have a third and final opportunity to review the vote transaction details before broadcasting it to the network. If everything looks good and you'd like to proceed with voting, click the \u2018 Send \u2019 button as shown below. Troubleshooting \u00b6 My Solar Desktop Wallet does not show any Ledger wallets \u00b6 Make sure your Ledger device is connected to your computer, that it is unlocked, and that the Solar Ledger app is opened. The screen of your Ledger device should say \u2018 Solar is ready .\u2019 Make sure Ledger Live, or any other software that connects to Ledger devices, is not opened as this can interfere with a Ledger device's connection. Make sure you have installed the latest version of the Solar Desktop Wallet, available here: https://solar.org/desktop-wallet . Restart the Solar Desktop Wallet or 'Force Reload' it using CTRL + SHIFT + R (Windows) or CMD + SHIFT + R (Linux, macOS) Support \u00b6 If you have any questions, please reach out to the Solar community on the official Solar channels: Discord: https://discord.solar.org Telegram: https://telegram.solar.org","title":"Solar Ledger App Guide"},{"location":"desktop-wallet/user-guides/ledger/#solar-ledger-app-guide","text":"","title":"Solar Ledger App Guide"},{"location":"desktop-wallet/user-guides/ledger/#introduction","text":"This guide will help you get started in using your Ledger hardware wallet with the Solar Desktop Wallet software. Your Ledger device uses an offline, or cold storage, method of generating private keys, making it among the most secure ways to store cryptoassets, including Solar (SXP). It enables you to sign transactions securely, so you can send SXP or vote for your favourite delegates without the need to enter your mnemonic recovery passphrase. This guide covers the following topics: Solar Ledger App Guide Introduction Before you start Installing the Solar Ledger App Viewing Solar (SXP) Ledger Wallets Creating Multiple Solar (SXP) Ledger Wallets Receiving and Sending Solar (SXP) Receiving Solar (SXP) Sending Solar (SXP) Voting / Staking Solar (SXP) Troubleshooting My Solar Desktop Wallet does not show any Ledger wallets Support For any questions, please reach out to the Solar community on Telegram or Discord. Links to both are at the bottom of this guide.","title":"Introduction"},{"location":"desktop-wallet/user-guides/ledger/#before-you-start","text":"This guide assumes you have the following set up, updated to the latest versions, and ready to use: A Ledger hardware wallet (Nano S/X/S Plus) - https://shop.ledger.com Ledger Live - https://www.ledger.com/ledger-live/download Solar Desktop Wallet - https://solar.org/desktop-wallet","title":"Before you start"},{"location":"desktop-wallet/user-guides/ledger/#installing-the-solar-ledger-app","text":"You can find and install the Solar Ledger app using Ledger Live. 1. Open Ledger Live Desktop To get started installing the Solar Ledger app, open Ledger Live Desktop and click ' Manager ' in the sidebar menu. 2. Connect your Ledger device Next, connect your Ledger device to your computer and unlock it using your PIN. If asked, follow the on-screen instructions on your Ledger device to \u2018Allow Ledger Manager.' 3. Install the Solar app Using Ledger Live\u2019s App catalog, search for \" Solar \" and click \u2018 Install .\u2019 The Solar app will then be installed on your Ledger device. 4. Close Ledger Live","title":"Installing the Solar Ledger App"},{"location":"desktop-wallet/user-guides/ledger/#viewing-solar-sxp-ledger-wallets","text":"After having installed the Solar app, your Ledger device is ready to be used with the Solar Desktop Wallet. 1. Close Ledger Live Desktop Having multiple Ledger-supported applications opened at the same time on your computer can interfere with the connection to your Ledger device, so you'll want to make sure Ledger Live, or any other software that connects to Ledger devices, is closed. 2. Connect your Ledger device If not already connected and unlocked, connect your Ledger device to your computer and unlock it using your PIN. 3. Open the Solar Ledger app Next, open the Solar Ledger app on your Ledger device. Your device should now display \"_Solar is ready \" as shown above._ 4. Open the Solar Desktop Wallet Once initialised, the Solar Desktop Wallet will load and display your Ledger wallets and their SXP balances. Ledger wallets are marked with a red \u2018Ledger\u2019 label.","title":"Viewing Solar (SXP) Ledger Wallets"},{"location":"desktop-wallet/user-guides/ledger/#creating-multiple-solar-sxp-ledger-wallets","text":"Your Ledger device can manage multiple SXP wallet addresses using the \u2018Ledger Options\u2019 menu of the Solar Desktop Wallet. 1. Click \u2018My wallets\u2019 In the Solar Desktop Wallet, click on 'My Wallets.' 2. Click \u2018Ledger Options\u2019 Using the \u2018 Ledger Options \u2019 menu of the Solar Desktop Wallet, click \u2018 Load Additional Ledger Wallets .' 3. Click \u2018Load Wallets\u2019 Finally, type in however many Solar Ledger wallets you'd like to have displayed and click ' Load Wallets .'","title":"Creating Multiple Solar (SXP) Ledger Wallets"},{"location":"desktop-wallet/user-guides/ledger/#receiving-and-sending-solar-sxp","text":"A Solar Ledger wallet works just like a traditional passphrase-protected Solar wallet.","title":"Receiving and Sending Solar (SXP)"},{"location":"desktop-wallet/user-guides/ledger/#receiving-solar-sxp","text":"Receive SXP from anyone by sharing your unique Solar (SXP) Ledger wallet address(es) with them. You can find a wallet's unique address in its banner as seen below.","title":"Receiving Solar (SXP)"},{"location":"desktop-wallet/user-guides/ledger/#sending-solar-sxp","text":"Send SXP using your Ledger device and the Solar Desktop Wallet. 1. Open a Solar (SXP) Ledger wallet Using the Solar Desktop Wallet, open the Solar (SXP) Ledger address from which you'd like to send funds, then click ' Send .' Make sure your Ledger device is connected and unlocked and that the Solar app is opened. 2. Enter the Transfer Details Enter the recipient's wallet address (or pick one from your address book) and the amount of SXP you'd like to send. After entering and reviewing the information, click ' Next ' to proceed. 3. Confirm using your Ledger Device You will now be required to review the transaction details using your Ledger device. Take your time clicking through to verify that the transaction details are correct, pay close attention to the recipient\u2019s Solar address and the amount of SXP you're being shown. Make sure that it matches what you entered using the Solar Desktop Wallet. If everything looks correct and you'd like to proceed with sending the transaction, click ' Approve ' using your Ledger device. If the details don't match, you'd like to make a change before sending, or you've simply changed your mind and no longer wish to proceed with the transaction, click ' Reject ' using your Ledger device. 4. Confirm and Send After reviewing and approving the transaction details using your Ledger device, you'll have a third and final opportunity to review the transaction details before broadcasting it to the network. If everything looks good and you'd like to proceed with the transaction, click the \u2018 Send \u2019 button as shown below.","title":"Sending Solar (SXP)"},{"location":"desktop-wallet/user-guides/ledger/#voting-staking-solar-sxp","text":"You can perform nearly any transaction using your Solar Ledger wallet as you could using a traditional Solar (SXP) wallet, including voting for your favourite delegates to stake your SXP. Learn more about delegates and their proposals and contributions here: https://delegates.solar.org 1. Open a Solar (SXP) Ledger wallet Using the Solar Desktop Wallet, open the Solar (SXP) Ledger address from which you'd like to vote. Then click the ' Delegates ' tab. Make sure your Ledger device is connected and unlocked and that the Solar app is opened. 2. Select your Favourite Delegates Select your favourite delegates from the list--or search for them by name. 3. Confirm the Vote Details After reviewing the vote details, click ' Vote '. 4. Confirm the Vote Fee You'll now be asked to confirm the vote fee. It's recommended to leave this set to the default (\"Average\") fee, there's no need to adjust it at this time. Click ' Next ' to proceed. 5. Confirm using your Ledger Device You will now be required to review the vote details using your Ledger device. Take your time clicking through to verify that the vote details are correct. Make sure that the delegate's username matches the one selected using the Solar Desktop Wallet exactly. If everything looks correct and you'd like to proceed with voting, click ' Approve ' using your Ledger device. If the details don't match, you'd like to change your vote before sending, or you've simply changed your mind and no longer wish to proceed with voting, click ' Reject ' using your Ledger device. 6. Confirm and Send After reviewing and approving the vote details using your Ledger device, you'll have a third and final opportunity to review the vote transaction details before broadcasting it to the network. If everything looks good and you'd like to proceed with voting, click the \u2018 Send \u2019 button as shown below.","title":"Voting / Staking Solar (SXP)"},{"location":"desktop-wallet/user-guides/ledger/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"desktop-wallet/user-guides/ledger/#my-solar-desktop-wallet-does-not-show-any-ledger-wallets","text":"Make sure your Ledger device is connected to your computer, that it is unlocked, and that the Solar Ledger app is opened. The screen of your Ledger device should say \u2018 Solar is ready .\u2019 Make sure Ledger Live, or any other software that connects to Ledger devices, is not opened as this can interfere with a Ledger device's connection. Make sure you have installed the latest version of the Solar Desktop Wallet, available here: https://solar.org/desktop-wallet . Restart the Solar Desktop Wallet or 'Force Reload' it using CTRL + SHIFT + R (Windows) or CMD + SHIFT + R (Linux, macOS)","title":"My Solar Desktop Wallet does not show any Ledger wallets"},{"location":"desktop-wallet/user-guides/ledger/#support","text":"If you have any questions, please reach out to the Solar community on the official Solar channels: Discord: https://discord.solar.org Telegram: https://telegram.solar.org","title":"Support"},{"location":"desktop-wallet/user-guides/transaction-fees/","text":"SXP Transaction Fees \u00b6 The fee associated with a transaction is awarded to the Validator who forges the transaction in a given block. Though dynamic fees allow setting a custom amount, there is no reason to increase a transaction fee above the \u2018average\u2019 at this time. A user may enter a lower fee if desired, though there is no guarantee the transaction will be forged. Fortunately, rejected transactions do not forfeit the fee as with Ethereum and its \"gas fee\". Since the SXP transaction failed and funds never technically left the user's wallet, the Desktop Wallet and Solar simply behave as if the transaction never existed.","title":"Transaction Fees"},{"location":"desktop-wallet/user-guides/transaction-fees/#sxp-transaction-fees","text":"The fee associated with a transaction is awarded to the Validator who forges the transaction in a given block. Though dynamic fees allow setting a custom amount, there is no reason to increase a transaction fee above the \u2018average\u2019 at this time. A user may enter a lower fee if desired, though there is no guarantee the transaction will be forged. Fortunately, rejected transactions do not forfeit the fee as with Ethereum and its \"gas fee\". Since the SXP transaction failed and funds never technically left the user's wallet, the Desktop Wallet and Solar simply behave as if the transaction never existed.","title":"SXP Transaction Fees"},{"location":"exchanges/configuring-rate-limits/","text":"Configuring Rate Limits \u00b6 Solar Core is mainly used in the context of public services, providing desktop wallets with the necessary endpoints to function. Since they serve anonymous users and to protect against DDoS attacks, Solar Core nodes have strict rate limits. Enterprise users (such as exchanges) might encounter a problem creating large batches of transactions and broadcasting them. The rate limit can be configured in multiple ways to solve these problems. Exceeding the Rate Limit \u00b6 By default, rate limits are enabled on Solar Core nodes. When the rate limit is exceeded; a 429 HTTP status is returned. Configuring the Rate Limit \u00b6 You can fine tune or completely disable the node's rate limit by editing the .env file found at ~/.config/solar-core/{network}/.env . Find most important parameters below: file: ~/.config/solar-core/{network}/.env \u00b6 CORE_API_RATE_LIMIT_DISABLED = true CORE_API_RATE_LIMIT_USER_LIMIT = 300 CORE_API_RATE_LIMIT_WHITELIST = 127.0.0.1 , 192.168.1.1 , 172.31.255.1 Setting CORE_API_RATE_LIMIT_DISABLED=true will globally disable all rate limits. For internal use this is safe. More fine-grained control may be exerted by using CORE_API_RATE_LIMIT_USER_LIMIT , which uses IP addresses to assign rate limits. The unit is requests/minute (default: 100 requests/per minute/per IP). Excluding certain IP addresses from rate limiting can be achieved by setting CORE_API_RATE_LIMIT_WHITELIST= followed by comma separated list of IP addresses (default: 172.0.0.1). Use case 1: Disable Rate Limits \u00b6 WARNING: Make sure API is accessible only to your internal network and not visible to the outside world. CORE_API_RATE_LIMIT_DISABLED = true Use case 2: White Listing \u00b6 INFO: Instead of globally disabling rate limits it is possible to exclude certain IP addresses from rate limits and raise the global limits. CORE_API_RATE_LIMIT_WHITELIST = 127.0.0.1 , 192.168.1.1 , 172.31.255.1 CORE_API_RATE_LIMIT_USER_LIMIT = 300","title":"Configuring Rate Limits"},{"location":"exchanges/configuring-rate-limits/#configuring-rate-limits","text":"Solar Core is mainly used in the context of public services, providing desktop wallets with the necessary endpoints to function. Since they serve anonymous users and to protect against DDoS attacks, Solar Core nodes have strict rate limits. Enterprise users (such as exchanges) might encounter a problem creating large batches of transactions and broadcasting them. The rate limit can be configured in multiple ways to solve these problems.","title":"Configuring Rate Limits"},{"location":"exchanges/configuring-rate-limits/#exceeding-the-rate-limit","text":"By default, rate limits are enabled on Solar Core nodes. When the rate limit is exceeded; a 429 HTTP status is returned.","title":"Exceeding the Rate Limit "},{"location":"exchanges/configuring-rate-limits/#configuring-the-rate-limit","text":"You can fine tune or completely disable the node's rate limit by editing the .env file found at ~/.config/solar-core/{network}/.env . Find most important parameters below:","title":"Configuring the Rate Limit "},{"location":"exchanges/configuring-rate-limits/#file-configsolar-corenetworkenv","text":"CORE_API_RATE_LIMIT_DISABLED = true CORE_API_RATE_LIMIT_USER_LIMIT = 300 CORE_API_RATE_LIMIT_WHITELIST = 127.0.0.1 , 192.168.1.1 , 172.31.255.1 Setting CORE_API_RATE_LIMIT_DISABLED=true will globally disable all rate limits. For internal use this is safe. More fine-grained control may be exerted by using CORE_API_RATE_LIMIT_USER_LIMIT , which uses IP addresses to assign rate limits. The unit is requests/minute (default: 100 requests/per minute/per IP). Excluding certain IP addresses from rate limiting can be achieved by setting CORE_API_RATE_LIMIT_WHITELIST= followed by comma separated list of IP addresses (default: 172.0.0.1).","title":"file: ~/.config/solar-core/{network}/.env "},{"location":"exchanges/configuring-rate-limits/#use-case-1-disable-rate-limits","text":"WARNING: Make sure API is accessible only to your internal network and not visible to the outside world. CORE_API_RATE_LIMIT_DISABLED = true","title":"Use case 1: Disable Rate Limits  "},{"location":"exchanges/configuring-rate-limits/#use-case-2-white-listing","text":"INFO: Instead of globally disabling rate limits it is possible to exclude certain IP addresses from rate limits and raise the global limits. CORE_API_RATE_LIMIT_WHITELIST = 127.0.0.1 , 192.168.1.1 , 172.31.255.1 CORE_API_RATE_LIMIT_USER_LIMIT = 300","title":"Use case 2: White Listing  "},{"location":"exchanges/intro/","text":"Introduction \u00b6 This section is tailored for institutional/production usage of Solar Core. Most exchanges and third-party services are familiar with Bitcoind-RPC when listing or adding a new cryptocurrency. Since SXP is a custom blockchain, some companies have had difficulty navigating through our GitHub and integrating Solar into their platform. The two most popular means of accessing the Solar blockchain are via the Public API and the JSON-RPC . Though the JSON-RPC is the recommended approach, we include instructions here on how to accomplish the most common tasks on both API surfaces. We have added \"quick guides\" to walk you through the process of interacting with the Solar blockchain in each API. Use the sidebar to navigate this section. A dedicated Promised NodeJS Module is available for exchanges that wish to you use a secure Public API for the exchange operations. Click here for more information. The endpoint for mainnet is https://sxp.mainnet.sh , please use https://sxp.testnet.sh \" for the development network.","title":"Introduction"},{"location":"exchanges/intro/#introduction","text":"This section is tailored for institutional/production usage of Solar Core. Most exchanges and third-party services are familiar with Bitcoind-RPC when listing or adding a new cryptocurrency. Since SXP is a custom blockchain, some companies have had difficulty navigating through our GitHub and integrating Solar into their platform. The two most popular means of accessing the Solar blockchain are via the Public API and the JSON-RPC . Though the JSON-RPC is the recommended approach, we include instructions here on how to accomplish the most common tasks on both API surfaces. We have added \"quick guides\" to walk you through the process of interacting with the Solar blockchain in each API. Use the sidebar to navigate this section. A dedicated Promised NodeJS Module is available for exchanges that wish to you use a secure Public API for the exchange operations. Click here for more information. The endpoint for mainnet is https://sxp.mainnet.sh , please use https://sxp.testnet.sh \" for the development network.","title":"Introduction"},{"location":"exchanges/public-api-guide/","text":"Exchanges API Guide \u00b6 For exchanges we recommend the usage of JSON-RPC server with optimized methods for client and crypto functionality. Best practice is to install a Relay Node and JSON-RPC in a secure environment. If really necessary then follow the basic instructions for connection via Public REST API. Connecting to the PUBLIC API is done via the Crypto and Client SDKs . Many queries can be performed using the Client SDK alone, while the Crypto SDK performs any actions requiring cryptographic functionality (i.e., signing transactions). At a surface level, the two SDKs are separated by their functions and intended use cases: The Crypto SDK provides the cryptographic functions necessary to authenticate and validate Solar transactions. The Client SDK provides wrapper functions to unify and streamline API calls between your application and the Solar blockchain. Put another way, the Crypto SDK structures your data in a format that all Solar nodes can understand, while the Client SDK handles the actual communication between your application and an Solar node. Where the Crypto SDK is internal, the Client SDK is external, as the below diagram illustrates: Note that the Public API is only available after a node has fully synced. This ensures your data on the blockchain is up to date. Setup \u00b6 These quick actions will all assume you've loaded a Client instance with the IP address of your node and the API version you're requesting. Solar Node (v1) has been deprecated. Some references to V1 client constructors may remain for legacy purposes. However, no current clients require you to specify the API Version (defaults to v2). const Client = require ( \"@solar/client\" ); const exchangeClient = new Client ( \"YOUR.NODE.IP\" , 2 ); HashMap < String , Object > map = new HashMap <> (); map . put ( \"host\" , \"http://node-ip:port/api/\" ); map . put ( \"API-Version\" , 2 ); Connection < Two > connection = new Connection ( map ); package main import ( sxp \"github.com/solar/go-client/client\" \"net/url\" ) func main () { client := sxp . NewClient ( nil ) client . BaseURL , _ = url . Parse ( \"http://{NODE_IP}:{NODE_HOST}/api\" ) from client import ArkClient client = ArkClient ( 'http://127.0.0.1:6003/api' ) Check Wallet Balance \u00b6 Checking a wallet balance involves using the wallets resource to GET the wallet corresponding to a given Solar address. const walletAddress = \"ARyNwFj7nQUCip5gYt4gSWG6F8evL93eBL\" ; let wallet ; exchangeClient . resource ( \"wallets\" ) . get ( walletAddress ) . then ( response => { wallet = response . data . data ; }) . catch ( error => { console . log ( error ); }); console . log ( wallet . balance ); ... import \"github.com/davecgh/go-spew/spew\" func main () { ... responseStruct , _ , err := client . Wallets . Get ( context . TODO (), \"ARyNwFj7nQUCip5gYt4gSWG6F8evL93eBL\" ) if err != nil { log . Panic ( err ) } spew . Dump ( responseStruct ) } from pprint import pprint pprint ( client . wallets . get ( wallet_id = 'ARyNwFj7nQUCip5gYt4gSWG6F8evL93eBL' )) Find Block Information \u00b6 If you know the ID of the block you are looking for, you can use the GET method on the blocks resource to return information on that block. const blockId = 4439278960598580069 ; let block ; exchangeClient . resource ( \"blocks\" ) . get ( blockId ) . then ( response => { block = response . data . data ; }) . catch ( error => { console . log ( error ); }); console . log ( block ); func main () { ... responseStruct , _ , err := client . Blocks . Get ( context . TODO (), 4439278960598580069 ) if err != nil { log . Panic ( err ) } spew . Dump ( responseStruct ) } pprint ( client . blocks . get ( block_id = '4439278960598580069' )) Alternatively, if you are not sure of the block ID, or if you want to find all wallets in a range, you can make use of the wallets.search method. This endpoint accepts a JSON object representing the search parameters to use when narrowing down a list of blocks. The following block properties can be used to create your range: timestamp height numberOfTransactions totalAmount totalFee reward payloadLength To use any of these properties as a range, include the relevant key in your request as an object containing from and to specifiers. For example, this code can be used to search all blocks between blockchain heights 720 and 735 with total fees between 0 and 2000 arktoshi: exchangeClient . resource ( \"blocks\" ) . search ({ height : { from : 720 , to : 735 }, totalFee : { from : 0 , to : 2000 } }) . then ( response => { console . log ( response . data ); // all blocks matching the search criteria }); func main () { ... responseStruct , _ , err := client . Blocks . Search ( context . TODO (), sxp . BlocksSearchRequest { Height : sxp . FromTo { From : 720 , To : 735 }, TotalFee : sxp . FromTo { From : 0 , To : 2000 }, }) if err != nil { log . Panic ( err ) } spew . Dump ( responseStruct ) } pprint ( client . blocks . search ({ \"height\" : { \"from\" : 720 , \"to\" : 735 }, \"totalFee\" : { \"from\" : 0 , \"to\" : 2000 }, })) Create and Broadcast Transactions \u00b6 To create transactions, make use of the transactionBuilder module of @solar/crypto . First, install the package from npm or your language's equivalent: yarn add @solar/crypto go get -u github.com/solar/go-crypto/crypto pip install solar-crypto The crypto package functionality we'll use here is the transactionBuilder, which provides a series of \"chainable\" methods that can be called, one after another, to produce a transaction object. These methods create and define your transaction: its type, its amount in arktoshi, its signature, and more. Regardless of which SDK you use, every transactionBuilder contains a similar function to getStruct , which will return a completed transaction object. After making one or more of these transaction objects, you can combine them into an array to use as the transactions key in your request. With all the steps together, here is an example of how to send a transaction for approval: const crypto = require ( \"@solar/crypto\" ); const transactionBuilder = crypto . transactionBuilder ; const transaction = transactionBuilder . transfer () . amount ( 2 * Math . pow ( 10 , 8 )) . recipientId ( recipientId ) . sign ( passphrase ) . getStruct (); exchangeClient . resource ( \"transactions\" ) . create ({ transactions : [ transaction ] }) . then ( response => { console . log ( response . data ); if ( response . data . errors ) { errors . forEach ( error => { console . log ( error ); }); } }) . catch ( error => { console . log ( error ); }); ... import ark_crypto \"github.com/solar/go-crypto/crypto\" func main () { ... transaction := ark_crypto . BuildTransfer ( recipientId , uint64 ( amount ), \"Hello World\" , passphrase , ) // cast is a fictitious helper function which alters ark_crypto.Transaction // into an ark_client.CreateTransactionRequest. responseStruct , _ , err := client . Transaction . Create ( context . TODO (), cast ( transaction )) if err != nil { log . Panic ( err ) } spew . Dump ( responseStruct ) } ... from crypto.transactions.builder.transfer import Transfer tx = Transfer ( recipientId = recipientId , amount = 1000 ) tx . sign ( passphrase ) pprint ( client . transactions . create ([ tx ])) There are a few things worth noticing about the above code. Firstly, the code assumes that you have declared two variables already: passphrase - the passphrase of the sending account, used to sign the transaction. This should come from somewhere secure, such as a .env file. recipientId - the Solar address of the receiving account. Should be provided by the exchange user when submitting withdrawal requests. Second, when sending your request using the exchangeClient , ensure that the value of transactions is an array, even if you have only one transaction object. If your request is successful, you will receive a response with the following data key: { data : { accept : [ '96e3952b66a370d8145055b55cedc6f1435b3a71cb17334aa954f8844ad1202f' ], broadcast : [ '96e3952b66a370d8145055b55cedc6f1435b3a71cb17334aa954f8844ad1202f' ], excess : [], invalid : [] }, errors : null } Let us look at the returned data object in more depth. It is composed of four arrays, each holding zero or more transaction IDs: accept - a list of all accepted transactions broadcast - a list of all transactions broadcast to the network excess - if the node's transaction pool is full, this lists all excess transactions invalid - a list of all transactions deemed invalid by the node Our sample code above submitted one transaction, which the node accepted and broadcast and thus the accept and broadcast arrays contain precisely one item each: the ID of the transaction we submitted. If we had submitted any invalid transactions, the invalid list would have contained their IDs, and the errors key would have been populated with one error per invalid transaction. The diagram below offers a top-level overview of the transaction submission process: Check Transaction Confirmations \u00b6 Once a transaction has been created and added to the blockchain, you can access the number of confirmations it has by using the transactions resource to get the value matching the transaction ID. const transactionId = \"9085b309dd0c20c12c1a00c40e1c71cdadaa74476b669e9f8a632db337fb6915\" ; exchangeClient . resource ( \"transactions\" ) . get ( transactionId ) . then ( response => { console . log ( response . data ); }); ... func main () { ... txID := \"9085b309dd0c20c12c1a00c40e1c71cdadaa74476b669e9f8a632db337fb6915\" responseStruct , _ , err := client . Transactions . Get ( context . TODO (), txID ) if err != nil { log . Panic ( err ) } spew . Dump ( responseStruct ) } txID = \"9085b309dd0c20c12c1a00c40e1c71cdadaa74476b669e9f8a632db337fb6915\" pprint ( client . transactions . get ( transaction_id = txID )) If the transaction has been added to the blockchain, you'll receive the following data structure in your console: { data : { id : 'a4d3d3ab059b8445894805c1158f06049a4200b2878892e18d95b88fc57d0ae5' , blockId : '7236620515792246272' , version : 1 , type : 0 , amount : 200000000 , fee : 10000000 , sender : 'ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo' , recipient : 'AbfQq8iRSf9TFQRzQWo33dHYU7HFMS17Zd' , signature : '304402206f1a45d0e8fadf033bfd539ddf05aa33ca296813f30a72a0e17d560e2d04ba8e02204a2525972d14bb3da407a04f2b9d797747a4eb99ff547e4803f60143f6a68543' , confirmations : 0 , timestamp : { epoch : 54759242 , unix : 1544860442 , human : '2018-12-15T07:54:02.000Z' } } } You can see that the confirmations key holds the number of confirmations this transaction has received from the network, in the above case 0. As the average block takes 8 seconds to forge, finality is typically established within a minute following a transaction's addition to the blockchain. Check Node Status \u00b6 Checking node status can be done by using the node resource's status method: exchangeClient . resource ( \"node\" ) . status () . then ( response => { console . log ( response . data ); }); ... func main () { ... responseStruct , _ , err := client . Node . Status ( context . TODO ()) if err != nil { log . Panic ( err ) } spew . Dump ( responseStruct ) } pprint ( client . node . status ()) By running this code, you'd see the output in your console resembling the following object: { data : { synced : true , // whether this node is fully synchronized with the network now : 14468 , // the current network height of this node's blockchain blocksCount : 0 // if not synced, the number of blocks yet to be synced } } If synced is true, your node is operating as expected and fully synced with the Solar network. Otherwise, use the blocksCount key to get an estimation of how long your node will take to sync.","title":"Public API quick guide"},{"location":"exchanges/public-api-guide/#exchanges-api-guide","text":"For exchanges we recommend the usage of JSON-RPC server with optimized methods for client and crypto functionality. Best practice is to install a Relay Node and JSON-RPC in a secure environment. If really necessary then follow the basic instructions for connection via Public REST API. Connecting to the PUBLIC API is done via the Crypto and Client SDKs . Many queries can be performed using the Client SDK alone, while the Crypto SDK performs any actions requiring cryptographic functionality (i.e., signing transactions). At a surface level, the two SDKs are separated by their functions and intended use cases: The Crypto SDK provides the cryptographic functions necessary to authenticate and validate Solar transactions. The Client SDK provides wrapper functions to unify and streamline API calls between your application and the Solar blockchain. Put another way, the Crypto SDK structures your data in a format that all Solar nodes can understand, while the Client SDK handles the actual communication between your application and an Solar node. Where the Crypto SDK is internal, the Client SDK is external, as the below diagram illustrates: Note that the Public API is only available after a node has fully synced. This ensures your data on the blockchain is up to date.","title":"Exchanges API Guide"},{"location":"exchanges/public-api-guide/#setup","text":"These quick actions will all assume you've loaded a Client instance with the IP address of your node and the API version you're requesting. Solar Node (v1) has been deprecated. Some references to V1 client constructors may remain for legacy purposes. However, no current clients require you to specify the API Version (defaults to v2). const Client = require ( \"@solar/client\" ); const exchangeClient = new Client ( \"YOUR.NODE.IP\" , 2 ); HashMap < String , Object > map = new HashMap <> (); map . put ( \"host\" , \"http://node-ip:port/api/\" ); map . put ( \"API-Version\" , 2 ); Connection < Two > connection = new Connection ( map ); package main import ( sxp \"github.com/solar/go-client/client\" \"net/url\" ) func main () { client := sxp . NewClient ( nil ) client . BaseURL , _ = url . Parse ( \"http://{NODE_IP}:{NODE_HOST}/api\" ) from client import ArkClient client = ArkClient ( 'http://127.0.0.1:6003/api' )","title":"Setup"},{"location":"exchanges/public-api-guide/#check-wallet-balance","text":"Checking a wallet balance involves using the wallets resource to GET the wallet corresponding to a given Solar address. const walletAddress = \"ARyNwFj7nQUCip5gYt4gSWG6F8evL93eBL\" ; let wallet ; exchangeClient . resource ( \"wallets\" ) . get ( walletAddress ) . then ( response => { wallet = response . data . data ; }) . catch ( error => { console . log ( error ); }); console . log ( wallet . balance ); ... import \"github.com/davecgh/go-spew/spew\" func main () { ... responseStruct , _ , err := client . Wallets . Get ( context . TODO (), \"ARyNwFj7nQUCip5gYt4gSWG6F8evL93eBL\" ) if err != nil { log . Panic ( err ) } spew . Dump ( responseStruct ) } from pprint import pprint pprint ( client . wallets . get ( wallet_id = 'ARyNwFj7nQUCip5gYt4gSWG6F8evL93eBL' ))","title":"Check Wallet Balance"},{"location":"exchanges/public-api-guide/#find-block-information","text":"If you know the ID of the block you are looking for, you can use the GET method on the blocks resource to return information on that block. const blockId = 4439278960598580069 ; let block ; exchangeClient . resource ( \"blocks\" ) . get ( blockId ) . then ( response => { block = response . data . data ; }) . catch ( error => { console . log ( error ); }); console . log ( block ); func main () { ... responseStruct , _ , err := client . Blocks . Get ( context . TODO (), 4439278960598580069 ) if err != nil { log . Panic ( err ) } spew . Dump ( responseStruct ) } pprint ( client . blocks . get ( block_id = '4439278960598580069' )) Alternatively, if you are not sure of the block ID, or if you want to find all wallets in a range, you can make use of the wallets.search method. This endpoint accepts a JSON object representing the search parameters to use when narrowing down a list of blocks. The following block properties can be used to create your range: timestamp height numberOfTransactions totalAmount totalFee reward payloadLength To use any of these properties as a range, include the relevant key in your request as an object containing from and to specifiers. For example, this code can be used to search all blocks between blockchain heights 720 and 735 with total fees between 0 and 2000 arktoshi: exchangeClient . resource ( \"blocks\" ) . search ({ height : { from : 720 , to : 735 }, totalFee : { from : 0 , to : 2000 } }) . then ( response => { console . log ( response . data ); // all blocks matching the search criteria }); func main () { ... responseStruct , _ , err := client . Blocks . Search ( context . TODO (), sxp . BlocksSearchRequest { Height : sxp . FromTo { From : 720 , To : 735 }, TotalFee : sxp . FromTo { From : 0 , To : 2000 }, }) if err != nil { log . Panic ( err ) } spew . Dump ( responseStruct ) } pprint ( client . blocks . search ({ \"height\" : { \"from\" : 720 , \"to\" : 735 }, \"totalFee\" : { \"from\" : 0 , \"to\" : 2000 }, }))","title":"Find Block Information"},{"location":"exchanges/public-api-guide/#create-and-broadcast-transactions","text":"To create transactions, make use of the transactionBuilder module of @solar/crypto . First, install the package from npm or your language's equivalent: yarn add @solar/crypto go get -u github.com/solar/go-crypto/crypto pip install solar-crypto The crypto package functionality we'll use here is the transactionBuilder, which provides a series of \"chainable\" methods that can be called, one after another, to produce a transaction object. These methods create and define your transaction: its type, its amount in arktoshi, its signature, and more. Regardless of which SDK you use, every transactionBuilder contains a similar function to getStruct , which will return a completed transaction object. After making one or more of these transaction objects, you can combine them into an array to use as the transactions key in your request. With all the steps together, here is an example of how to send a transaction for approval: const crypto = require ( \"@solar/crypto\" ); const transactionBuilder = crypto . transactionBuilder ; const transaction = transactionBuilder . transfer () . amount ( 2 * Math . pow ( 10 , 8 )) . recipientId ( recipientId ) . sign ( passphrase ) . getStruct (); exchangeClient . resource ( \"transactions\" ) . create ({ transactions : [ transaction ] }) . then ( response => { console . log ( response . data ); if ( response . data . errors ) { errors . forEach ( error => { console . log ( error ); }); } }) . catch ( error => { console . log ( error ); }); ... import ark_crypto \"github.com/solar/go-crypto/crypto\" func main () { ... transaction := ark_crypto . BuildTransfer ( recipientId , uint64 ( amount ), \"Hello World\" , passphrase , ) // cast is a fictitious helper function which alters ark_crypto.Transaction // into an ark_client.CreateTransactionRequest. responseStruct , _ , err := client . Transaction . Create ( context . TODO (), cast ( transaction )) if err != nil { log . Panic ( err ) } spew . Dump ( responseStruct ) } ... from crypto.transactions.builder.transfer import Transfer tx = Transfer ( recipientId = recipientId , amount = 1000 ) tx . sign ( passphrase ) pprint ( client . transactions . create ([ tx ])) There are a few things worth noticing about the above code. Firstly, the code assumes that you have declared two variables already: passphrase - the passphrase of the sending account, used to sign the transaction. This should come from somewhere secure, such as a .env file. recipientId - the Solar address of the receiving account. Should be provided by the exchange user when submitting withdrawal requests. Second, when sending your request using the exchangeClient , ensure that the value of transactions is an array, even if you have only one transaction object. If your request is successful, you will receive a response with the following data key: { data : { accept : [ '96e3952b66a370d8145055b55cedc6f1435b3a71cb17334aa954f8844ad1202f' ], broadcast : [ '96e3952b66a370d8145055b55cedc6f1435b3a71cb17334aa954f8844ad1202f' ], excess : [], invalid : [] }, errors : null } Let us look at the returned data object in more depth. It is composed of four arrays, each holding zero or more transaction IDs: accept - a list of all accepted transactions broadcast - a list of all transactions broadcast to the network excess - if the node's transaction pool is full, this lists all excess transactions invalid - a list of all transactions deemed invalid by the node Our sample code above submitted one transaction, which the node accepted and broadcast and thus the accept and broadcast arrays contain precisely one item each: the ID of the transaction we submitted. If we had submitted any invalid transactions, the invalid list would have contained their IDs, and the errors key would have been populated with one error per invalid transaction. The diagram below offers a top-level overview of the transaction submission process:","title":"Create and Broadcast Transactions"},{"location":"exchanges/public-api-guide/#check-transaction-confirmations","text":"Once a transaction has been created and added to the blockchain, you can access the number of confirmations it has by using the transactions resource to get the value matching the transaction ID. const transactionId = \"9085b309dd0c20c12c1a00c40e1c71cdadaa74476b669e9f8a632db337fb6915\" ; exchangeClient . resource ( \"transactions\" ) . get ( transactionId ) . then ( response => { console . log ( response . data ); }); ... func main () { ... txID := \"9085b309dd0c20c12c1a00c40e1c71cdadaa74476b669e9f8a632db337fb6915\" responseStruct , _ , err := client . Transactions . Get ( context . TODO (), txID ) if err != nil { log . Panic ( err ) } spew . Dump ( responseStruct ) } txID = \"9085b309dd0c20c12c1a00c40e1c71cdadaa74476b669e9f8a632db337fb6915\" pprint ( client . transactions . get ( transaction_id = txID )) If the transaction has been added to the blockchain, you'll receive the following data structure in your console: { data : { id : 'a4d3d3ab059b8445894805c1158f06049a4200b2878892e18d95b88fc57d0ae5' , blockId : '7236620515792246272' , version : 1 , type : 0 , amount : 200000000 , fee : 10000000 , sender : 'ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo' , recipient : 'AbfQq8iRSf9TFQRzQWo33dHYU7HFMS17Zd' , signature : '304402206f1a45d0e8fadf033bfd539ddf05aa33ca296813f30a72a0e17d560e2d04ba8e02204a2525972d14bb3da407a04f2b9d797747a4eb99ff547e4803f60143f6a68543' , confirmations : 0 , timestamp : { epoch : 54759242 , unix : 1544860442 , human : '2018-12-15T07:54:02.000Z' } } } You can see that the confirmations key holds the number of confirmations this transaction has received from the network, in the above case 0. As the average block takes 8 seconds to forge, finality is typically established within a minute following a transaction's addition to the blockchain.","title":"Check Transaction Confirmations"},{"location":"exchanges/public-api-guide/#check-node-status","text":"Checking node status can be done by using the node resource's status method: exchangeClient . resource ( \"node\" ) . status () . then ( response => { console . log ( response . data ); }); ... func main () { ... responseStruct , _ , err := client . Node . Status ( context . TODO ()) if err != nil { log . Panic ( err ) } spew . Dump ( responseStruct ) } pprint ( client . node . status ()) By running this code, you'd see the output in your console resembling the following object: { data : { synced : true , // whether this node is fully synchronized with the network now : 14468 , // the current network height of this node's blockchain blocksCount : 0 // if not synced, the number of blocks yet to be synced } } If synced is true, your node is operating as expected and fully synced with the Solar network. Otherwise, use the blocksCount key to get an estimation of how long your node will take to sync.","title":"Check Node Status"},{"location":"exchanges/json-rpc/examples/","text":"Examples \u00b6 All HTTP requests have to be sent with the Content-Type: application/vnd.api+json header. If the header is not present, it will result in malformed responses or request rejections. const axios = require ( 'axios' ) // install using npm: `npm install axios` const url = \"http://0.0.0.0:8080\" // http://${NODE_IP}:${JSON-RPC_PORT} const headers = { \"Content-Type\" : \"application/json\" } const body = {} // this object is unique to each method described below axios . post ( url , body , headers ) . then ( response => { console . log ( response . result ) } . catch ( error => { console . log ( error ) }) package main import ( \"bytes\" \"encoding/json\" \"net/http\" ) func post ( URL string , body interface {}) ( * http . Response , error ) { b := new ( bytes . Buffer ) err := json . NewEncoder ( b ). Encode ( u ) if err != nil { return nil , err } return http . Post ( URL , \"application/json\" , b ) } type request struct { Jsonrpc string `json:\"jsonrpc\"` Method string `json:\"method\"` ID int `json:\"id\"` Params interface {} `json:\"params\"` } func main () { resp , err := post ( \"http://0.0.0.0:8080\" , request {}, ) } import requests r = requests . post ( \"http://0.0.0.0:8080\" ) print ( r ) To complete the template, replace the empty body object with the objects provided in each quick action. The blocks.latest method, for example, can be accessed by the following script: const axios = require ( 'axios' ) // install from npm with `npm install axios` const url = \"http://0.0.0.0:8080\" // http://${NODE_ID}:${JSON-RPC-PORT} const headers = { \"Content-Type\" : \"application/json\" } const body = { jsonrpc : \"2.0\" , // JSON-RPC API version. method : \"blocks.latest\" , // RPC method. id : 31 // internal ID to track responses. } axios . post ( url , body , headers ) . then ( response => { console . log ( response . data ) } . catch ( error => { console . log ( error ) }) package main import ( \"bytes\" \"encoding/json\" \"net/http\" ) func post ( URL string , body interface {}) ( * http . Response , error ) { b := new ( bytes . Buffer ) err := json . NewEncoder ( b ). Encode ( u ) if err != nil { return nil , err } return http . Post ( URL , \"application/json; charset=utf-8\" , b ) } type request struct { Jsonrpc string `json:\"jsonrpc\"` Method string `json:\"method\"` ID int `json:\"id\"` Params interface {} `json:\"params\"` } func main () { resp , err := post ( \"http://0.0.0.0:8080\" , request { Jsonrpc : \"2.0\" , Method : \"blocks.latest\" , ID : 31 , Params : nil , }, ) } import requests r = requests . post ( \"http://0.0.0.0:8080\" , json = { \"jsonrpc\" : \"2.0\" , \"method\" : \"blocks.latest\" , \"id\" : 31 } ) print ( r ) Check Wallet Balance \u00b6 This method can be used to check the account balance associated with a particular Solar address. To utilize it, use the following body payload: const body = { jsonrpc : \"2.0\" , method : \"wallets.info\" , id : 31 // internal ID to track responses params : { address : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" // the address of the wallet being queried. } } package main ... type walletInfoParams struct { Address string `json:\"address\"` } func main () { resp , err := post ( \"http://0.0.0.0:8080\" , request { Jsonrpc : \"2.0\" , Method : \"wallets.info\" , ID : 31 , Params : walletInfoParams { Address : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" , }, }, ) } r = requests . post ( \"http://0.0.0.0:8080\" , json = { \"jsonrpc\" : \"2.0\" , \"method\" : \"wallets.info\" , \"id\" : 31 , \"params\" : { \"address\" : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" , }, } ) The response will contain the jsonrpc and id you used to call the request, along with a payload containing the following data: { \"address\" : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" , \"balance\" : 245098210000000 , \"isDelegate\" : true , \"publicKey\" : \"02532c68cd0842fb86b2202c1027eafc741bdd581517047d9d19319e6741c54883\" , \"secondPublicKey\" : null , \"username\" : \"genesis_30\" } Find Block Information \u00b6 If you want to retrieve the latest block on the blockchain, call the blocks.latest method with no parameters: const body = { jsonrpc : \"2.0\" , method : \"blocks.latest\" , id : 31 // internal ID to track responses }; package main ... func main () { resp , err := post ( \"http://0.0.0.0:8080\" , request { Jsonrpc : \"2.0\" , Method : \"blocks.latest\" , ID : 31 , Params : nil , }, ) } r = requests . post ( \"http://0.0.0.0:8080\" , json = { \"jsonrpc\" : \"2.0\" , \"method\" : \"blocks.latest\" , \"id\" : 31 } ) This returns a response similar to the following: { \"forged\" : { \"amount\" : 0 , \"fee\" : 0 , \"reward\" : 0 , \"total\" : 0 }, \"generator\" : { \"address\" : \"AdWRsk7Lbo97jxGBKzLAFwevVHbqVbW1Cj\" , \"publicKey\" : \"03691178f8610d0a295e650201b62345056c788d7f9ac7e8570b69c6c90091b564\" , \"username\" : \"genesis_8\" }, \"height\" : 20582 , \"id\" : \"5897025410627682852\" , \"payload\" : { \"hash\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"length\" : 0 }, \"previous\" : \"9643009166535029717\" , \"signature\" : \"30440220772362881112eb0ce65d2a91b92cbb6b404f83165edfc95aa2cfb19a02026a3a022010bec681e7b9abfca61a4961f0e29db6730e8d3f9c649b5ab4b7eee1b919897e\" , \"timestamp\" : { \"epoch\" : 54902770 , \"human\" : \"2018-12-16T23:46:10.000Z\" , \"unix\" : 1545003970 }, \"transactions\" : 0 , \"version\" : 0 } Create and Broadcast Transactions \u00b6 Creating a transaction using the JSON-RPC is a two-step process: Create the transaction object with transactions.create . Broadcast the transaction to the network with transactions.broadcast . The transactions.create endpoint accepts three parameters: RecipientId Amount Passphrase An example transaction creation payload could look like this: const body = { jsonrpc : \"2.0\" , method : \"transactions.create\" , id : 31 params : { recipientId : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" // the address you want to send to, amount : \"200000000\" , // 2 Solar * 100,000,000 arktoshi/SXP passphrase : \"craft imitate step mixture patch forest volcano business charge around girl confirm\" } } package main ... type transaction struct { RecipientId string `json:\"recipientId\"` Amount string `json:\"amount\"` Passphrase string `json:\"passphrase\"` } func main () { resp , err := post ( \"http://0.0.0.0:8080\" , request { Jsonrpc : \"2.0\" , Method : \"transactions.create\" , ID : 31 , Params : transaction { Address : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" , Amount : \"200000000\" , // 2 Solar * 100,000,000 arktoshi/SXP Passphrase : \"craft imitate step mixture patch forest volcano business charge around girl confirm\" , }, }, ) } r = requests . post ( \"http://0.0.0.0:8080\" , json = { \"jsonrpc\" : \"2.0\" , \"method\" : \"transactions.create\" , \"id\" : 31 , \"params\" : { \"recipientId\" : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" # the address you want to send to, \"amount\" : \"200000000\" , # 2 Solar * 100,000,000 arktoshi/SXP \"passphrase\" : \"craft imitate step mixture patch forest volcano business charge around girl confirm\" }, } ) This endpoint will return a transaction object similar to the following: { \"amount\" : \"200000000\" , \"fee\" : 10000000 , \"id\" : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" , \"recipientId\" : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" , \"senderPublicKey\" : \"038082dad560a22ea003022015e3136b21ef1ffd9f2fd50049026cbe8e2258ca17\" , \"signature\" : \"304402204236a59a19266b5969e18f87d6d4b178180277c79beb5d4b42f272ee03fba0b702200c6c97ed5ab2e6231f3dce5cdfe740e72261b460f896fb4c5be0ca7ce6244c67\" , \"timestamp\" : 54903765 , \"type\" : 0 } Importantly, this does not mean your transaction has been added to the blockchain! To do so, we'll need to submit a second request to transactions.broadcast . This request should have a params object with a single key: the id key returned by transactions.create . With the returned ID, our second request body looks like this: const body = { jsonrpc : \"2.0\" , method : \"transactions.broadcast\" , id : 31 params : { id : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" } } package main ... type broadcast struct { Id string `json:\"id\"` } func main () { resp , err := post ( \"http://0.0.0.0:8080\" , request { Jsonrpc : \"2.0\" , Method : \"transactions.broadcast\" , ID : 31 , Params : broadcast { Id : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" , }, }, ) } r = requests . post ( \"http://0.0.0.0:8080\" , json = { \"jsonrpc\" : \"2.0\" , \"method\" : \"transactions.broadcast\" , \"id\" : 31 , \"params\" : { \"id\" : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" , }, } ) If we receive the same transaction object as the call to transactions.create , our transaction was successful. Within your application, one way to confirm the result is to check that result.id matches the transaction ID you provided to the endpoint. Otherwise, the errors key will contain more information on what went wrong. Check Transaction Confirmations \u00b6 Checking the number of confirmations a transaction can be done via JSON-RPC by the transactions.info method. The command accepts one parameter: the id of the transaction to query. A sample request could look like: const body = { jsonrpc : \"2.0\" , method : \"transactions.info\" , id : 9 , params : { id : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" } }; package main ... type transactionInfo struct { Id string `json:\"id\"` } func main () { resp , err := post ( \"http://0.0.0.0:8080\" , request { Jsonrpc : \"2.0\" , Method : \"transactions.info\" , ID : 31 , Params : transactionInfo { id : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" , }, }, ) } r = requests . post ( \"http://0.0.0.0:8080\" , json = { \"jsonrpc\" : \"2.0\" , \"method\" : \"transactions.info\" , \"id\" : 31 , \"params\" : { \"id\" : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" , }, } ) If successful, you'll receive a response similar to the following: { \"amount\" : 200000000 , \"blockId\" : \"16888082711050311577\" , \"confirmations\" : 27 , \"fee\" : 10000000 , \"id\" : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" , \"recipient\" : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" , \"sender\" : \"ARAibxGqLQJTo1bWMJfu5fCc88rdWWjqgv\" , \"signature\" : \"304402204236a59a19266b5969e18f87d6d4b178180277c79beb5d4b42f272ee03fba0b702200c6c97ed5ab2e6231f3dce5cdfe740e72261b460f896fb4c5be0ca7ce6244c67\" , \"timestamp\" : { \"epoch\" : 54903765 , \"human\" : \"2018-12-17T00:02:45.000Z\" , \"unix\" : 1545004965 }, \"type\" : 0 , \"version\" : 1 } This particular transaction has 27 confirmations, meaning you can be confident that this transaction has been irreversibly included in the blockchain. Most exchanges use a minimum of 51 confirmations, which is one complete round.","title":"Examples"},{"location":"exchanges/json-rpc/examples/#examples","text":"All HTTP requests have to be sent with the Content-Type: application/vnd.api+json header. If the header is not present, it will result in malformed responses or request rejections. const axios = require ( 'axios' ) // install using npm: `npm install axios` const url = \"http://0.0.0.0:8080\" // http://${NODE_IP}:${JSON-RPC_PORT} const headers = { \"Content-Type\" : \"application/json\" } const body = {} // this object is unique to each method described below axios . post ( url , body , headers ) . then ( response => { console . log ( response . result ) } . catch ( error => { console . log ( error ) }) package main import ( \"bytes\" \"encoding/json\" \"net/http\" ) func post ( URL string , body interface {}) ( * http . Response , error ) { b := new ( bytes . Buffer ) err := json . NewEncoder ( b ). Encode ( u ) if err != nil { return nil , err } return http . Post ( URL , \"application/json\" , b ) } type request struct { Jsonrpc string `json:\"jsonrpc\"` Method string `json:\"method\"` ID int `json:\"id\"` Params interface {} `json:\"params\"` } func main () { resp , err := post ( \"http://0.0.0.0:8080\" , request {}, ) } import requests r = requests . post ( \"http://0.0.0.0:8080\" ) print ( r ) To complete the template, replace the empty body object with the objects provided in each quick action. The blocks.latest method, for example, can be accessed by the following script: const axios = require ( 'axios' ) // install from npm with `npm install axios` const url = \"http://0.0.0.0:8080\" // http://${NODE_ID}:${JSON-RPC-PORT} const headers = { \"Content-Type\" : \"application/json\" } const body = { jsonrpc : \"2.0\" , // JSON-RPC API version. method : \"blocks.latest\" , // RPC method. id : 31 // internal ID to track responses. } axios . post ( url , body , headers ) . then ( response => { console . log ( response . data ) } . catch ( error => { console . log ( error ) }) package main import ( \"bytes\" \"encoding/json\" \"net/http\" ) func post ( URL string , body interface {}) ( * http . Response , error ) { b := new ( bytes . Buffer ) err := json . NewEncoder ( b ). Encode ( u ) if err != nil { return nil , err } return http . Post ( URL , \"application/json; charset=utf-8\" , b ) } type request struct { Jsonrpc string `json:\"jsonrpc\"` Method string `json:\"method\"` ID int `json:\"id\"` Params interface {} `json:\"params\"` } func main () { resp , err := post ( \"http://0.0.0.0:8080\" , request { Jsonrpc : \"2.0\" , Method : \"blocks.latest\" , ID : 31 , Params : nil , }, ) } import requests r = requests . post ( \"http://0.0.0.0:8080\" , json = { \"jsonrpc\" : \"2.0\" , \"method\" : \"blocks.latest\" , \"id\" : 31 } ) print ( r )","title":"Examples"},{"location":"exchanges/json-rpc/examples/#check-wallet-balance","text":"This method can be used to check the account balance associated with a particular Solar address. To utilize it, use the following body payload: const body = { jsonrpc : \"2.0\" , method : \"wallets.info\" , id : 31 // internal ID to track responses params : { address : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" // the address of the wallet being queried. } } package main ... type walletInfoParams struct { Address string `json:\"address\"` } func main () { resp , err := post ( \"http://0.0.0.0:8080\" , request { Jsonrpc : \"2.0\" , Method : \"wallets.info\" , ID : 31 , Params : walletInfoParams { Address : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" , }, }, ) } r = requests . post ( \"http://0.0.0.0:8080\" , json = { \"jsonrpc\" : \"2.0\" , \"method\" : \"wallets.info\" , \"id\" : 31 , \"params\" : { \"address\" : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" , }, } ) The response will contain the jsonrpc and id you used to call the request, along with a payload containing the following data: { \"address\" : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" , \"balance\" : 245098210000000 , \"isDelegate\" : true , \"publicKey\" : \"02532c68cd0842fb86b2202c1027eafc741bdd581517047d9d19319e6741c54883\" , \"secondPublicKey\" : null , \"username\" : \"genesis_30\" }","title":"Check Wallet Balance"},{"location":"exchanges/json-rpc/examples/#find-block-information","text":"If you want to retrieve the latest block on the blockchain, call the blocks.latest method with no parameters: const body = { jsonrpc : \"2.0\" , method : \"blocks.latest\" , id : 31 // internal ID to track responses }; package main ... func main () { resp , err := post ( \"http://0.0.0.0:8080\" , request { Jsonrpc : \"2.0\" , Method : \"blocks.latest\" , ID : 31 , Params : nil , }, ) } r = requests . post ( \"http://0.0.0.0:8080\" , json = { \"jsonrpc\" : \"2.0\" , \"method\" : \"blocks.latest\" , \"id\" : 31 } ) This returns a response similar to the following: { \"forged\" : { \"amount\" : 0 , \"fee\" : 0 , \"reward\" : 0 , \"total\" : 0 }, \"generator\" : { \"address\" : \"AdWRsk7Lbo97jxGBKzLAFwevVHbqVbW1Cj\" , \"publicKey\" : \"03691178f8610d0a295e650201b62345056c788d7f9ac7e8570b69c6c90091b564\" , \"username\" : \"genesis_8\" }, \"height\" : 20582 , \"id\" : \"5897025410627682852\" , \"payload\" : { \"hash\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"length\" : 0 }, \"previous\" : \"9643009166535029717\" , \"signature\" : \"30440220772362881112eb0ce65d2a91b92cbb6b404f83165edfc95aa2cfb19a02026a3a022010bec681e7b9abfca61a4961f0e29db6730e8d3f9c649b5ab4b7eee1b919897e\" , \"timestamp\" : { \"epoch\" : 54902770 , \"human\" : \"2018-12-16T23:46:10.000Z\" , \"unix\" : 1545003970 }, \"transactions\" : 0 , \"version\" : 0 }","title":"Find Block Information"},{"location":"exchanges/json-rpc/examples/#create-and-broadcast-transactions","text":"Creating a transaction using the JSON-RPC is a two-step process: Create the transaction object with transactions.create . Broadcast the transaction to the network with transactions.broadcast . The transactions.create endpoint accepts three parameters: RecipientId Amount Passphrase An example transaction creation payload could look like this: const body = { jsonrpc : \"2.0\" , method : \"transactions.create\" , id : 31 params : { recipientId : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" // the address you want to send to, amount : \"200000000\" , // 2 Solar * 100,000,000 arktoshi/SXP passphrase : \"craft imitate step mixture patch forest volcano business charge around girl confirm\" } } package main ... type transaction struct { RecipientId string `json:\"recipientId\"` Amount string `json:\"amount\"` Passphrase string `json:\"passphrase\"` } func main () { resp , err := post ( \"http://0.0.0.0:8080\" , request { Jsonrpc : \"2.0\" , Method : \"transactions.create\" , ID : 31 , Params : transaction { Address : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" , Amount : \"200000000\" , // 2 Solar * 100,000,000 arktoshi/SXP Passphrase : \"craft imitate step mixture patch forest volcano business charge around girl confirm\" , }, }, ) } r = requests . post ( \"http://0.0.0.0:8080\" , json = { \"jsonrpc\" : \"2.0\" , \"method\" : \"transactions.create\" , \"id\" : 31 , \"params\" : { \"recipientId\" : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" # the address you want to send to, \"amount\" : \"200000000\" , # 2 Solar * 100,000,000 arktoshi/SXP \"passphrase\" : \"craft imitate step mixture patch forest volcano business charge around girl confirm\" }, } ) This endpoint will return a transaction object similar to the following: { \"amount\" : \"200000000\" , \"fee\" : 10000000 , \"id\" : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" , \"recipientId\" : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" , \"senderPublicKey\" : \"038082dad560a22ea003022015e3136b21ef1ffd9f2fd50049026cbe8e2258ca17\" , \"signature\" : \"304402204236a59a19266b5969e18f87d6d4b178180277c79beb5d4b42f272ee03fba0b702200c6c97ed5ab2e6231f3dce5cdfe740e72261b460f896fb4c5be0ca7ce6244c67\" , \"timestamp\" : 54903765 , \"type\" : 0 } Importantly, this does not mean your transaction has been added to the blockchain! To do so, we'll need to submit a second request to transactions.broadcast . This request should have a params object with a single key: the id key returned by transactions.create . With the returned ID, our second request body looks like this: const body = { jsonrpc : \"2.0\" , method : \"transactions.broadcast\" , id : 31 params : { id : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" } } package main ... type broadcast struct { Id string `json:\"id\"` } func main () { resp , err := post ( \"http://0.0.0.0:8080\" , request { Jsonrpc : \"2.0\" , Method : \"transactions.broadcast\" , ID : 31 , Params : broadcast { Id : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" , }, }, ) } r = requests . post ( \"http://0.0.0.0:8080\" , json = { \"jsonrpc\" : \"2.0\" , \"method\" : \"transactions.broadcast\" , \"id\" : 31 , \"params\" : { \"id\" : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" , }, } ) If we receive the same transaction object as the call to transactions.create , our transaction was successful. Within your application, one way to confirm the result is to check that result.id matches the transaction ID you provided to the endpoint. Otherwise, the errors key will contain more information on what went wrong.","title":"Create and Broadcast Transactions"},{"location":"exchanges/json-rpc/examples/#check-transaction-confirmations","text":"Checking the number of confirmations a transaction can be done via JSON-RPC by the transactions.info method. The command accepts one parameter: the id of the transaction to query. A sample request could look like: const body = { jsonrpc : \"2.0\" , method : \"transactions.info\" , id : 9 , params : { id : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" } }; package main ... type transactionInfo struct { Id string `json:\"id\"` } func main () { resp , err := post ( \"http://0.0.0.0:8080\" , request { Jsonrpc : \"2.0\" , Method : \"transactions.info\" , ID : 31 , Params : transactionInfo { id : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" , }, }, ) } r = requests . post ( \"http://0.0.0.0:8080\" , json = { \"jsonrpc\" : \"2.0\" , \"method\" : \"transactions.info\" , \"id\" : 31 , \"params\" : { \"id\" : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" , }, } ) If successful, you'll receive a response similar to the following: { \"amount\" : 200000000 , \"blockId\" : \"16888082711050311577\" , \"confirmations\" : 27 , \"fee\" : 10000000 , \"id\" : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" , \"recipient\" : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" , \"sender\" : \"ARAibxGqLQJTo1bWMJfu5fCc88rdWWjqgv\" , \"signature\" : \"304402204236a59a19266b5969e18f87d6d4b178180277c79beb5d4b42f272ee03fba0b702200c6c97ed5ab2e6231f3dce5cdfe740e72261b460f896fb4c5be0ca7ce6244c67\" , \"timestamp\" : { \"epoch\" : 54903765 , \"human\" : \"2018-12-17T00:02:45.000Z\" , \"unix\" : 1545004965 }, \"type\" : 0 , \"version\" : 1 } This particular transaction has 27 confirmations, meaning you can be confident that this transaction has been irreversibly included in the blockchain. Most exchanges use a minimum of 51 confirmations, which is one complete round.","title":"Check Transaction Confirmations"},{"location":"exchanges/json-rpc/getting-started/","text":"Getting Started \u00b6 The Exchange JSON-RPC is only maintained for exchanges, as the name suggests. We do not offer any support or guidance unless you are an Exchange in which case you most likely will already be in touch with us. Installation via Yarn \u00b6 yarn global add @solar-network/exchange-json-rpc-cli Usage instructions \u00b6 All commands support a -h flag to show help for the specified command. $ exchange-json-rpc A JSON-RPC 2 .0 specification compliant server for Exchanges to interact with the Solar Blockchain. VERSION @solar-network/exchange-json-rpc-cli/1.0.0 darwin-x64 node-v10.16.0 USAGE $ exchange-json-rpc [ COMMAND ] COMMANDS autocomplete display autocomplete installation instructions command commands list all the commands help display help for exchange-json-rpc log Show the log restart Restart the JSON-RPC run Run the JSON-RPC ( without pm2 ) start Start the JSON-RPC status Show the JSON-RPC status stop Stop the JSON-RPC update Update the exchange-json-rpc installation start \u00b6 Start the JSON-RPC exchange-json-rpc start Flag Description Default Required --[no-]allowRemote allow remote connections which are filtered by a whitelist n/a No --network= the name of the network that should be used mainnet No --token= the name of the token that should be used sxp No --host= the host that should be used to expose the RPC 0.0.0.0 No --port= the port that should be used to expose the RPC 8008 No --peer= the peer you want to use for communication, defaults to random network peers n/a No --whitelist= a comma separated list of IPs that can access the RPC 127.0.0.1,::ffff:127.0.0.1 No restart \u00b6 Restart the JSON-RPC exchange-json-rpc restart stop \u00b6 Stop the JSON-RPC exchange-json-rpc stop Flag Description Default Required --kill kill the process or daemon n/a No run \u00b6 Run the JSON-RPC without pm2 (exits on CTRL+C) exchange-json-rpc run Flag Description Default Required --[no-]allowRemote allow remote connections which are filtered by a whitelist n/a No --network= the name of the network that should be used mainnet No --token= the name of the token that should be used sxp No --host= the host that should be used to expose the RPC 0.0.0.0 No --port= the port that should be used to expose the RPC 8008 No --peer= the peer you want to use for communication, defaults to random network peers n/a No --whitelist= a comma separated list of IPs that can access the RPC 127.0.0.1,::ffff:127.0.0.1 No status \u00b6 Show the JSON-RPC status exchange-json-rpc status update \u00b6 Update the JSON-RPC installation exchange-json-rpc update log \u00b6 Show the log exchange-json-rpc log Flag Description Default Required --error= only show error output n/a No --lines= number of lines to tail 15 No Security \u00b6 If you discover a security vulnerability within this package, please send an e-mail to security@solar.org . All security vulnerabilities will be promptly addressed.","title":"Getting Started"},{"location":"exchanges/json-rpc/getting-started/#getting-started","text":"The Exchange JSON-RPC is only maintained for exchanges, as the name suggests. We do not offer any support or guidance unless you are an Exchange in which case you most likely will already be in touch with us.","title":"Getting Started"},{"location":"exchanges/json-rpc/getting-started/#installation-via-yarn","text":"yarn global add @solar-network/exchange-json-rpc-cli","title":"Installation via Yarn"},{"location":"exchanges/json-rpc/getting-started/#usage-instructions","text":"All commands support a -h flag to show help for the specified command. $ exchange-json-rpc A JSON-RPC 2 .0 specification compliant server for Exchanges to interact with the Solar Blockchain. VERSION @solar-network/exchange-json-rpc-cli/1.0.0 darwin-x64 node-v10.16.0 USAGE $ exchange-json-rpc [ COMMAND ] COMMANDS autocomplete display autocomplete installation instructions command commands list all the commands help display help for exchange-json-rpc log Show the log restart Restart the JSON-RPC run Run the JSON-RPC ( without pm2 ) start Start the JSON-RPC status Show the JSON-RPC status stop Stop the JSON-RPC update Update the exchange-json-rpc installation","title":"Usage instructions"},{"location":"exchanges/json-rpc/getting-started/#start","text":"Start the JSON-RPC exchange-json-rpc start Flag Description Default Required --[no-]allowRemote allow remote connections which are filtered by a whitelist n/a No --network= the name of the network that should be used mainnet No --token= the name of the token that should be used sxp No --host= the host that should be used to expose the RPC 0.0.0.0 No --port= the port that should be used to expose the RPC 8008 No --peer= the peer you want to use for communication, defaults to random network peers n/a No --whitelist= a comma separated list of IPs that can access the RPC 127.0.0.1,::ffff:127.0.0.1 No","title":"start"},{"location":"exchanges/json-rpc/getting-started/#restart","text":"Restart the JSON-RPC exchange-json-rpc restart","title":"restart"},{"location":"exchanges/json-rpc/getting-started/#stop","text":"Stop the JSON-RPC exchange-json-rpc stop Flag Description Default Required --kill kill the process or daemon n/a No","title":"stop"},{"location":"exchanges/json-rpc/getting-started/#run","text":"Run the JSON-RPC without pm2 (exits on CTRL+C) exchange-json-rpc run Flag Description Default Required --[no-]allowRemote allow remote connections which are filtered by a whitelist n/a No --network= the name of the network that should be used mainnet No --token= the name of the token that should be used sxp No --host= the host that should be used to expose the RPC 0.0.0.0 No --port= the port that should be used to expose the RPC 8008 No --peer= the peer you want to use for communication, defaults to random network peers n/a No --whitelist= a comma separated list of IPs that can access the RPC 127.0.0.1,::ffff:127.0.0.1 No","title":"run"},{"location":"exchanges/json-rpc/getting-started/#status","text":"Show the JSON-RPC status exchange-json-rpc status","title":"status"},{"location":"exchanges/json-rpc/getting-started/#update","text":"Update the JSON-RPC installation exchange-json-rpc update","title":"update"},{"location":"exchanges/json-rpc/getting-started/#log","text":"Show the log exchange-json-rpc log Flag Description Default Required --error= only show error output n/a No --lines= number of lines to tail 15 No","title":"log"},{"location":"exchanges/json-rpc/getting-started/#security","text":"If you discover a security vulnerability within this package, please send an e-mail to security@solar.org . All security vulnerabilities will be promptly addressed.","title":"Security"},{"location":"exchanges/json-rpc/endpoints/blocks/","text":"Blocks \u00b6 Get a Block \u00b6 Method \u00b6 blocks.info Body Parameters \u00b6 Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.id string The identifier of the block to be retrieved. Yes Request \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"blocks.info\" , \"params\" : { \"id\" : \"9336364900436444611\" } } Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"id\" : \"9336364900436444611\" , \"version\" : 0 , \"height\" : 23 , \"previous\" : \"17180650139879860733\" , \"forged\" : { \"reward\" : 0 , \"fee\" : 0 , \"total\" : 0 }, \"payload\" : { \"hash\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"length\" : 0 }, \"generator\" : { \"username\" : \"genesis_43\" , \"address\" : \"AQBo4exLwyapRiDoDteh1fF2ctWWdxofSf\" , \"publicKey\" : \"034985f6f2167cc8c9df1204aaf6744bc97c0d7f3c07c43ee6c0978bc91b6c680e\" }, \"signature\" : \"3045022100b5c6ebb1c4c6694b82b98eea6c6eb889547908d8c1aff98d16f3f9df810fe34b02207266371081ffc6461da6fbb2811065aabe135c6e47863605416e6e5ddb4c7806\" , \"transactions\" : 0 , \"timestamp\" : { \"epoch\" : 50686634 , \"unix\" : 1540787834 , \"human\" : \"2018-10-29T04:37:14Z\" } } } Error Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } } Get the Latest Block \u00b6 Method \u00b6 blocks.latest Body Parameters \u00b6 Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes Request \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"blocks.latest\" } Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"id\" : \"1453043075643523354\" , \"version\" : 0 , \"height\" : 29 , \"previous\" : \"14915069404850182157\" , \"forged\" : { \"reward\" : 0 , \"fee\" : 0 , \"total\" : 0 }, \"payload\" : { \"hash\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"length\" : 0 }, \"generator\" : { \"username\" : \"genesis_42\" , \"address\" : \"AcmXmomxpP8NahbbFivq32QmLuKFkTkqRg\" , \"publicKey\" : \"0311077c86a98b67850e7ed2c81775d094cf81c6991082ddc33fc7be5347dc765d\" }, \"signature\" : \"3045022100d94630fc328f5e70a4fa6134fa8aadbaab42eff15b22e91ae17438b6f28cfd3a022014df10ff42cea9d02e549353c24a6207c3de10d85b4f91742b44ffb4f303592e\" , \"transactions\" : 0 , \"timestamp\" : { \"epoch\" : 50686712 , \"unix\" : 1540787912 , \"human\" : \"2018-10-29T04:38:32Z\" } } } Error Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } } Get a Blocks Transactions \u00b6 Method \u00b6 blocks.transactions Body Parameters \u00b6 Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.id string The identifier of the block to be retrieved. Yes params.offset int The offset of transactions to be retrieved. Yes Request \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"blocks.transactions\" , \"params\" : { \"id\" : \"17184958558311101492\" } } Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"count\" : 153 , \"data\" : [ { \"id\" : \"db1aa687737858cc9199bfa336f9b1c035915c30aaee60b1e0f8afadfdb946bd\" , \"blockId\" : \"17184958558311101492\" , \"type\" : 0 , \"amount\" : 245098000000000 , \"fee\" : 0 , \"sender\" : \"APnhwwyTbMiykJwYbGhYjNgtHiVJDSEhSn\" , \"recipient\" : \"AHXtmB84sTZ9Zd35h9Y1vfFvPE2Xzqj8ri\" , \"signature\" : \"304402205fcb0677e06bde7aac3dc776665615f4b93ef8c3ed0fddecef9900e74fcb00f302206958a0c9868ea1b1f3d151bdfa92da1ce24de0b1fcd91933e64fb7971e92f48d\" , \"confirmations\" : 3 , \"timestamp\" : { \"epoch\" : 0 , \"unix\" : 1490101200 , \"human\" : \"2017-03-21T13:00:00Z\" } } ] } } Error Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }","title":"Blocks"},{"location":"exchanges/json-rpc/endpoints/blocks/#blocks","text":"","title":"Blocks"},{"location":"exchanges/json-rpc/endpoints/blocks/#get-a-block","text":"","title":"Get a Block"},{"location":"exchanges/json-rpc/endpoints/blocks/#method","text":"blocks.info","title":"Method"},{"location":"exchanges/json-rpc/endpoints/blocks/#body-parameters","text":"Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.id string The identifier of the block to be retrieved. Yes","title":"Body Parameters"},{"location":"exchanges/json-rpc/endpoints/blocks/#request","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"blocks.info\" , \"params\" : { \"id\" : \"9336364900436444611\" } }","title":"Request"},{"location":"exchanges/json-rpc/endpoints/blocks/#response","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"id\" : \"9336364900436444611\" , \"version\" : 0 , \"height\" : 23 , \"previous\" : \"17180650139879860733\" , \"forged\" : { \"reward\" : 0 , \"fee\" : 0 , \"total\" : 0 }, \"payload\" : { \"hash\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"length\" : 0 }, \"generator\" : { \"username\" : \"genesis_43\" , \"address\" : \"AQBo4exLwyapRiDoDteh1fF2ctWWdxofSf\" , \"publicKey\" : \"034985f6f2167cc8c9df1204aaf6744bc97c0d7f3c07c43ee6c0978bc91b6c680e\" }, \"signature\" : \"3045022100b5c6ebb1c4c6694b82b98eea6c6eb889547908d8c1aff98d16f3f9df810fe34b02207266371081ffc6461da6fbb2811065aabe135c6e47863605416e6e5ddb4c7806\" , \"transactions\" : 0 , \"timestamp\" : { \"epoch\" : 50686634 , \"unix\" : 1540787834 , \"human\" : \"2018-10-29T04:37:14Z\" } } }","title":"Response"},{"location":"exchanges/json-rpc/endpoints/blocks/#error-response","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }","title":"Error Response"},{"location":"exchanges/json-rpc/endpoints/blocks/#get-the-latest-block","text":"","title":"Get the Latest Block"},{"location":"exchanges/json-rpc/endpoints/blocks/#method_1","text":"blocks.latest","title":"Method"},{"location":"exchanges/json-rpc/endpoints/blocks/#body-parameters_1","text":"Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes","title":"Body Parameters"},{"location":"exchanges/json-rpc/endpoints/blocks/#request_1","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"blocks.latest\" }","title":"Request"},{"location":"exchanges/json-rpc/endpoints/blocks/#response_1","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"id\" : \"1453043075643523354\" , \"version\" : 0 , \"height\" : 29 , \"previous\" : \"14915069404850182157\" , \"forged\" : { \"reward\" : 0 , \"fee\" : 0 , \"total\" : 0 }, \"payload\" : { \"hash\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"length\" : 0 }, \"generator\" : { \"username\" : \"genesis_42\" , \"address\" : \"AcmXmomxpP8NahbbFivq32QmLuKFkTkqRg\" , \"publicKey\" : \"0311077c86a98b67850e7ed2c81775d094cf81c6991082ddc33fc7be5347dc765d\" }, \"signature\" : \"3045022100d94630fc328f5e70a4fa6134fa8aadbaab42eff15b22e91ae17438b6f28cfd3a022014df10ff42cea9d02e549353c24a6207c3de10d85b4f91742b44ffb4f303592e\" , \"transactions\" : 0 , \"timestamp\" : { \"epoch\" : 50686712 , \"unix\" : 1540787912 , \"human\" : \"2018-10-29T04:38:32Z\" } } }","title":"Response"},{"location":"exchanges/json-rpc/endpoints/blocks/#error-response_1","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }","title":"Error Response"},{"location":"exchanges/json-rpc/endpoints/blocks/#get-a-blocks-transactions","text":"","title":"Get a Blocks Transactions"},{"location":"exchanges/json-rpc/endpoints/blocks/#method_2","text":"blocks.transactions","title":"Method"},{"location":"exchanges/json-rpc/endpoints/blocks/#body-parameters_2","text":"Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.id string The identifier of the block to be retrieved. Yes params.offset int The offset of transactions to be retrieved. Yes","title":"Body Parameters"},{"location":"exchanges/json-rpc/endpoints/blocks/#request_2","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"blocks.transactions\" , \"params\" : { \"id\" : \"17184958558311101492\" } }","title":"Request"},{"location":"exchanges/json-rpc/endpoints/blocks/#response_2","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"count\" : 153 , \"data\" : [ { \"id\" : \"db1aa687737858cc9199bfa336f9b1c035915c30aaee60b1e0f8afadfdb946bd\" , \"blockId\" : \"17184958558311101492\" , \"type\" : 0 , \"amount\" : 245098000000000 , \"fee\" : 0 , \"sender\" : \"APnhwwyTbMiykJwYbGhYjNgtHiVJDSEhSn\" , \"recipient\" : \"AHXtmB84sTZ9Zd35h9Y1vfFvPE2Xzqj8ri\" , \"signature\" : \"304402205fcb0677e06bde7aac3dc776665615f4b93ef8c3ed0fddecef9900e74fcb00f302206958a0c9868ea1b1f3d151bdfa92da1ce24de0b1fcd91933e64fb7971e92f48d\" , \"confirmations\" : 3 , \"timestamp\" : { \"epoch\" : 0 , \"unix\" : 1490101200 , \"human\" : \"2017-03-21T13:00:00Z\" } } ] } }","title":"Response"},{"location":"exchanges/json-rpc/endpoints/blocks/#error-response_2","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }","title":"Error Response"},{"location":"exchanges/json-rpc/endpoints/intro/","text":"","title":"JSON-RPC Endpoints"},{"location":"exchanges/json-rpc/endpoints/transactions/","text":"Transactions \u00b6 Get a Transaction \u00b6 Method \u00b6 transaction.info Body Parameters \u00b6 Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.id string The identifier of the transaction to be retrieved. Yes Request \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"transactions.info\" , \"params\" : { \"id\" : \"49a4cc2b931e75da4676c5b06649543d3ea30f1097e944549e2ab3d67bc91e6a\" } } Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"id\" : \"49a4cc2b931e75da4676c5b06649543d3ea30f1097e944549e2ab3d67bc91e6a\" , \"blockId\" : \"1957735382338577043\" , \"type\" : 0 , \"amount\" : 1000000000 , \"fee\" : 10000000 , \"sender\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" , \"recipient\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" , \"signature\" : \"304502210084484fc57bd1c0af1e6bf2fc79e1d5c210b29d7651e3482cc764d2160bbd887a0220776362194a30f4c04365061344dd4b4ac2cc6f5efc479afcda07d26be9621e04\" , \"confirmations\" : 1 , \"timestamp\" : { \"epoch\" : 50271515 , \"unix\" : 1540372715 , \"human\" : \"2018-10-24T09:18:35Z\" } } } Error Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } } Broadcast Transactions \u00b6 In order to broadcast transactions via the JSON-RPC they also need to be created through it. If you are looking to just broadcast any transactions you should take a look at Transactions for the public API. Method \u00b6 transactions.broadcast Body Parameters \u00b6 Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.transactions array The list of transactions to be broadcast. Yes Request \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"transactions.broadcast\" , \"params\" : { \"id\" : \"49a4cc2b931e75da4676c5b06649543d3ea30f1097e944549e2ab3d67bc91e6a\" } } Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"id\" : \"49a4cc2b931e75da4676c5b06649543d3ea30f1097e944549e2ab3d67bc91e6a\" , \"signature\" : \"304502210084484fc57bd1c0af1e6bf2fc79e1d5c210b29d7651e3482cc764d2160bbd887a0220776362194a30f4c04365061344dd4b4ac2cc6f5efc479afcda07d26be9621e04\" , \"timestamp\" : 50271515 , \"type\" : 0 , \"fee\" : 10000000 , \"senderPublicKey\" : \"03287bfebba4c7881a0509717e71b34b63f31e40021c321f89ae04f84be6d6ac37\" , \"amount\" : 1000000000 , \"recipientId\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" } } Error Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } } Create a Transaction \u00b6 Method \u00b6 transactions.create Body Parameters \u00b6 Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.recipientId string The address of the recipient. Yes params.amount string The amount to be send. Yes params.passphrase string The passphrase of the sender. Yes params.vendorField string Optional field with custom content. No params.fee string Transaction Fee. If not set the average fee is read from the network. No Parameter params.fee is optional. If the parameter is not set, transaction is created by using the current public network average fee. Make sure to check the network for average fee values , before signing and sending a transaction. This is to handle edge case of them being higher than the current static ones. Request \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"transactions.create\" , \"params\" : { \"passphrase\" : \"this is a top secret passphrase\" , \"amount\" : 1000000000 , \"recipientId\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" } } Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"id\" : \"58f4f8ed866d2c6a42fc2b48d49fc5c949af6768b55d307376aaac61f930d8b6\" , \"signature\" : \"304402201ace9afcaf9d0ec64a31fd98c589767c76b5360d5b22dfe3cde2dfffdfef61dc022026d276a6140e6abbd80775541479cc71cf52590895bd24c0c577a9c57ecae581\" , \"timestamp\" : 50686854 , \"type\" : 0 , \"fee\" : 10000000 , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"amount\" : 1000000000 , \"recipientId\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" } } Error Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } } Create a Transaction from a BIP38 \u00b6 Method \u00b6 transactions.list Body Parameters \u00b6 Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.recipientId string The address of the recipient. Yes params.amount string The amount to be send. Yes params.bip38 string The bip38 of the sender. Yes params.userId string The identifier of the sender. Yes params.vendorField string Optional field with custom content. No params.fee string Transaction Fee. If not set the average fee is read from the network. No Parameter params.fee is optional. If the parameter is not set, transaction is created by using the current public network average fee. Make sure to check the network for average fee values , before signing and sending a transaction. This is to handle edge case of them being higher than the current static ones. Request \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"transactions.bip38.create\" , \"params\" : { \"bip38\" : \"this is a top secret passphrase\" , \"userId\" : \"123\" , \"amount\" : 1000000000 , \"recipientId\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" } } Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"id\" : \"729d8f1974bd1eb517619fe9a4c45c3e769f49bbe1b682237ef3f049038c5421\" , \"signature\" : \"304402207a4877d3515b2dc3c2d8bc337b767cea62718e80d4b9ba02d8f2f873c82e2987022067951e8aa731fed8223b650419c29ef7e71460807920604ea23d3c2872328217\" , \"timestamp\" : 50686826 , \"type\" : 0 , \"fee\" : 10000000 , \"senderPublicKey\" : \"022cf1c9de60c22c0b5a138b6545777cb2edaf82fe3906faa345580352000f84b6\" , \"amount\" : 1000000000 , \"recipientId\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" } } Error Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }","title":"Transactions"},{"location":"exchanges/json-rpc/endpoints/transactions/#transactions","text":"","title":"Transactions"},{"location":"exchanges/json-rpc/endpoints/transactions/#get-a-transaction","text":"","title":"Get a Transaction"},{"location":"exchanges/json-rpc/endpoints/transactions/#method","text":"transaction.info","title":"Method"},{"location":"exchanges/json-rpc/endpoints/transactions/#body-parameters","text":"Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.id string The identifier of the transaction to be retrieved. Yes","title":"Body Parameters"},{"location":"exchanges/json-rpc/endpoints/transactions/#request","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"transactions.info\" , \"params\" : { \"id\" : \"49a4cc2b931e75da4676c5b06649543d3ea30f1097e944549e2ab3d67bc91e6a\" } }","title":"Request"},{"location":"exchanges/json-rpc/endpoints/transactions/#response","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"id\" : \"49a4cc2b931e75da4676c5b06649543d3ea30f1097e944549e2ab3d67bc91e6a\" , \"blockId\" : \"1957735382338577043\" , \"type\" : 0 , \"amount\" : 1000000000 , \"fee\" : 10000000 , \"sender\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" , \"recipient\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" , \"signature\" : \"304502210084484fc57bd1c0af1e6bf2fc79e1d5c210b29d7651e3482cc764d2160bbd887a0220776362194a30f4c04365061344dd4b4ac2cc6f5efc479afcda07d26be9621e04\" , \"confirmations\" : 1 , \"timestamp\" : { \"epoch\" : 50271515 , \"unix\" : 1540372715 , \"human\" : \"2018-10-24T09:18:35Z\" } } }","title":"Response"},{"location":"exchanges/json-rpc/endpoints/transactions/#error-response","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }","title":"Error Response"},{"location":"exchanges/json-rpc/endpoints/transactions/#broadcast-transactions","text":"In order to broadcast transactions via the JSON-RPC they also need to be created through it. If you are looking to just broadcast any transactions you should take a look at Transactions for the public API.","title":"Broadcast Transactions"},{"location":"exchanges/json-rpc/endpoints/transactions/#method_1","text":"transactions.broadcast","title":"Method"},{"location":"exchanges/json-rpc/endpoints/transactions/#body-parameters_1","text":"Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.transactions array The list of transactions to be broadcast. Yes","title":"Body Parameters"},{"location":"exchanges/json-rpc/endpoints/transactions/#request_1","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"transactions.broadcast\" , \"params\" : { \"id\" : \"49a4cc2b931e75da4676c5b06649543d3ea30f1097e944549e2ab3d67bc91e6a\" } }","title":"Request"},{"location":"exchanges/json-rpc/endpoints/transactions/#response_1","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"id\" : \"49a4cc2b931e75da4676c5b06649543d3ea30f1097e944549e2ab3d67bc91e6a\" , \"signature\" : \"304502210084484fc57bd1c0af1e6bf2fc79e1d5c210b29d7651e3482cc764d2160bbd887a0220776362194a30f4c04365061344dd4b4ac2cc6f5efc479afcda07d26be9621e04\" , \"timestamp\" : 50271515 , \"type\" : 0 , \"fee\" : 10000000 , \"senderPublicKey\" : \"03287bfebba4c7881a0509717e71b34b63f31e40021c321f89ae04f84be6d6ac37\" , \"amount\" : 1000000000 , \"recipientId\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" } }","title":"Response"},{"location":"exchanges/json-rpc/endpoints/transactions/#error-response_1","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }","title":"Error Response"},{"location":"exchanges/json-rpc/endpoints/transactions/#create-a-transaction","text":"","title":"Create a Transaction"},{"location":"exchanges/json-rpc/endpoints/transactions/#method_2","text":"transactions.create","title":"Method"},{"location":"exchanges/json-rpc/endpoints/transactions/#body-parameters_2","text":"Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.recipientId string The address of the recipient. Yes params.amount string The amount to be send. Yes params.passphrase string The passphrase of the sender. Yes params.vendorField string Optional field with custom content. No params.fee string Transaction Fee. If not set the average fee is read from the network. No Parameter params.fee is optional. If the parameter is not set, transaction is created by using the current public network average fee. Make sure to check the network for average fee values , before signing and sending a transaction. This is to handle edge case of them being higher than the current static ones.","title":"Body Parameters"},{"location":"exchanges/json-rpc/endpoints/transactions/#request_2","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"transactions.create\" , \"params\" : { \"passphrase\" : \"this is a top secret passphrase\" , \"amount\" : 1000000000 , \"recipientId\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" } }","title":"Request"},{"location":"exchanges/json-rpc/endpoints/transactions/#response_2","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"id\" : \"58f4f8ed866d2c6a42fc2b48d49fc5c949af6768b55d307376aaac61f930d8b6\" , \"signature\" : \"304402201ace9afcaf9d0ec64a31fd98c589767c76b5360d5b22dfe3cde2dfffdfef61dc022026d276a6140e6abbd80775541479cc71cf52590895bd24c0c577a9c57ecae581\" , \"timestamp\" : 50686854 , \"type\" : 0 , \"fee\" : 10000000 , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"amount\" : 1000000000 , \"recipientId\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" } }","title":"Response"},{"location":"exchanges/json-rpc/endpoints/transactions/#error-response_2","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }","title":"Error Response"},{"location":"exchanges/json-rpc/endpoints/transactions/#create-a-transaction-from-a-bip38","text":"","title":"Create a Transaction from a BIP38"},{"location":"exchanges/json-rpc/endpoints/transactions/#method_3","text":"transactions.list","title":"Method"},{"location":"exchanges/json-rpc/endpoints/transactions/#body-parameters_3","text":"Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.recipientId string The address of the recipient. Yes params.amount string The amount to be send. Yes params.bip38 string The bip38 of the sender. Yes params.userId string The identifier of the sender. Yes params.vendorField string Optional field with custom content. No params.fee string Transaction Fee. If not set the average fee is read from the network. No Parameter params.fee is optional. If the parameter is not set, transaction is created by using the current public network average fee. Make sure to check the network for average fee values , before signing and sending a transaction. This is to handle edge case of them being higher than the current static ones.","title":"Body Parameters"},{"location":"exchanges/json-rpc/endpoints/transactions/#request_3","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"transactions.bip38.create\" , \"params\" : { \"bip38\" : \"this is a top secret passphrase\" , \"userId\" : \"123\" , \"amount\" : 1000000000 , \"recipientId\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" } }","title":"Request"},{"location":"exchanges/json-rpc/endpoints/transactions/#response_3","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"id\" : \"729d8f1974bd1eb517619fe9a4c45c3e769f49bbe1b682237ef3f049038c5421\" , \"signature\" : \"304402207a4877d3515b2dc3c2d8bc337b767cea62718e80d4b9ba02d8f2f873c82e2987022067951e8aa731fed8223b650419c29ef7e71460807920604ea23d3c2872328217\" , \"timestamp\" : 50686826 , \"type\" : 0 , \"fee\" : 10000000 , \"senderPublicKey\" : \"022cf1c9de60c22c0b5a138b6545777cb2edaf82fe3906faa345580352000f84b6\" , \"amount\" : 1000000000 , \"recipientId\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" } }","title":"Response"},{"location":"exchanges/json-rpc/endpoints/transactions/#error-response_3","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }","title":"Error Response"},{"location":"exchanges/json-rpc/endpoints/wallets/","text":"Wallets \u00b6 Get a Wallet \u00b6 Method \u00b6 wallets.info Body Parameters \u00b6 Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.address string The address of the wallet to be retrieved. Yes Request \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"wallets.info\" , \"params\" : { \"address\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" } } Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"address\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" , \"publicKey\" : \"03287bfebba4c7881a0509717e71b34b63f31e40021c321f89ae04f84be6d6ac37\" , \"secondPublicKey\" : null , \"balance\" : 245100000000000 , \"isDelegate\" : true } } Error Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } } Get a Wallets Transactions \u00b6 Method \u00b6 wallets.transactions Body Parameters \u00b6 Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.address string The address of the transactions to be retrieved. Yes params.offset int The offset of transactions to be retrieved. Yes Request \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"wallets.transactions\" , \"params\" : { \"address\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" } } Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"count\" : 153 , \"data\" : [ { \"id\" : \"db1aa687737858cc9199bfa336f9b1c035915c30aaee60b1e0f8afadfdb946bd\" , \"blockId\" : \"17184958558311101492\" , \"type\" : 0 , \"amount\" : 245098000000000 , \"fee\" : 0 , \"sender\" : \"APnhwwyTbMiykJwYbGhYjNgtHiVJDSEhSn\" , \"recipient\" : \"AHXtmB84sTZ9Zd35h9Y1vfFvPE2Xzqj8ri\" , \"signature\" : \"304402205fcb0677e06bde7aac3dc776665615f4b93ef8c3ed0fddecef9900e74fcb00f302206958a0c9868ea1b1f3d151bdfa92da1ce24de0b1fcd91933e64fb7971e92f48d\" , \"confirmations\" : 3 , \"timestamp\" : { \"epoch\" : 0 , \"unix\" : 1490101200 , \"human\" : \"2017-03-21T13:00:00Z\" } } ] } } Error Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } } Create a Wallet \u00b6 Method \u00b6 wallets.create Body Parameters \u00b6 Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.passphrase string The passphrase of the wallet to be created. Yes Request \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"wallets.create\" , \"params\" : { \"passphrase\" : \"this is a top secret passphrase\" } } Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"publicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"address\" : \"AGeYmgbg2LgGxRW2vNNJvQ88PknEJsYizC\" } } Error Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } } Get a BIP38 Wallet \u00b6 Method \u00b6 wallets.bip38.info Body Parameters \u00b6 Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.userId string The identifier of the wallet to be retrieved. Yes Request \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"wallets.bip38.info\" , \"params\" : { \"userId\" : \"123\" } } Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"wif\" : \"6PYTWME2aAJTx2NcRyS33zYrS79Hk7KiNbHZmGQWUYJYKWGZn4N36AdUMf\" } } Error Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } } Create a BIP38 Wallet \u00b6 Method \u00b6 wallets.bip38.create Body Parameters \u00b6 Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.bip38 string The bip38 of the wallet to be retrieved. Yes params.userId string The identifier of the wallet to be retrieved. Yes Request \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"wallets.bip38.create\" , \"params\" : { \"userId\" : \"123\" , \"bip38\" : \"this is a top secret passphrase\" } } Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"publicKey\" : \"022cf1c9de60c22c0b5a138b6545777cb2edaf82fe3906faa345580352000f84b6\" , \"address\" : \"AL4z4quXFVPR4ybDHeJ67HfSEmFrguQ6e5\" , \"wif\" : \"6PYTWME2aAJTx2NcRyS33zYrS79Hk7KiNbHZmGQWUYJYKWGZn4N36AdUMf\" } } Error Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }","title":"Wallets"},{"location":"exchanges/json-rpc/endpoints/wallets/#wallets","text":"","title":"Wallets"},{"location":"exchanges/json-rpc/endpoints/wallets/#get-a-wallet","text":"","title":"Get a Wallet"},{"location":"exchanges/json-rpc/endpoints/wallets/#method","text":"wallets.info","title":"Method"},{"location":"exchanges/json-rpc/endpoints/wallets/#body-parameters","text":"Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.address string The address of the wallet to be retrieved. Yes","title":"Body Parameters"},{"location":"exchanges/json-rpc/endpoints/wallets/#request","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"wallets.info\" , \"params\" : { \"address\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" } }","title":"Request"},{"location":"exchanges/json-rpc/endpoints/wallets/#response","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"address\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" , \"publicKey\" : \"03287bfebba4c7881a0509717e71b34b63f31e40021c321f89ae04f84be6d6ac37\" , \"secondPublicKey\" : null , \"balance\" : 245100000000000 , \"isDelegate\" : true } }","title":"Response"},{"location":"exchanges/json-rpc/endpoints/wallets/#error-response","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }","title":"Error Response"},{"location":"exchanges/json-rpc/endpoints/wallets/#get-a-wallets-transactions","text":"","title":"Get a Wallets Transactions"},{"location":"exchanges/json-rpc/endpoints/wallets/#method_1","text":"wallets.transactions","title":"Method"},{"location":"exchanges/json-rpc/endpoints/wallets/#body-parameters_1","text":"Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.address string The address of the transactions to be retrieved. Yes params.offset int The offset of transactions to be retrieved. Yes","title":"Body Parameters"},{"location":"exchanges/json-rpc/endpoints/wallets/#request_1","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"wallets.transactions\" , \"params\" : { \"address\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" } }","title":"Request"},{"location":"exchanges/json-rpc/endpoints/wallets/#response_1","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"count\" : 153 , \"data\" : [ { \"id\" : \"db1aa687737858cc9199bfa336f9b1c035915c30aaee60b1e0f8afadfdb946bd\" , \"blockId\" : \"17184958558311101492\" , \"type\" : 0 , \"amount\" : 245098000000000 , \"fee\" : 0 , \"sender\" : \"APnhwwyTbMiykJwYbGhYjNgtHiVJDSEhSn\" , \"recipient\" : \"AHXtmB84sTZ9Zd35h9Y1vfFvPE2Xzqj8ri\" , \"signature\" : \"304402205fcb0677e06bde7aac3dc776665615f4b93ef8c3ed0fddecef9900e74fcb00f302206958a0c9868ea1b1f3d151bdfa92da1ce24de0b1fcd91933e64fb7971e92f48d\" , \"confirmations\" : 3 , \"timestamp\" : { \"epoch\" : 0 , \"unix\" : 1490101200 , \"human\" : \"2017-03-21T13:00:00Z\" } } ] } }","title":"Response"},{"location":"exchanges/json-rpc/endpoints/wallets/#error-response_1","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }","title":"Error Response"},{"location":"exchanges/json-rpc/endpoints/wallets/#create-a-wallet","text":"","title":"Create a Wallet"},{"location":"exchanges/json-rpc/endpoints/wallets/#method_2","text":"wallets.create","title":"Method"},{"location":"exchanges/json-rpc/endpoints/wallets/#body-parameters_2","text":"Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.passphrase string The passphrase of the wallet to be created. Yes","title":"Body Parameters"},{"location":"exchanges/json-rpc/endpoints/wallets/#request_2","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"wallets.create\" , \"params\" : { \"passphrase\" : \"this is a top secret passphrase\" } }","title":"Request"},{"location":"exchanges/json-rpc/endpoints/wallets/#response_2","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"publicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"address\" : \"AGeYmgbg2LgGxRW2vNNJvQ88PknEJsYizC\" } }","title":"Response"},{"location":"exchanges/json-rpc/endpoints/wallets/#error-response_2","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }","title":"Error Response"},{"location":"exchanges/json-rpc/endpoints/wallets/#get-a-bip38-wallet","text":"","title":"Get a BIP38 Wallet"},{"location":"exchanges/json-rpc/endpoints/wallets/#method_3","text":"wallets.bip38.info","title":"Method"},{"location":"exchanges/json-rpc/endpoints/wallets/#body-parameters_3","text":"Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.userId string The identifier of the wallet to be retrieved. Yes","title":"Body Parameters"},{"location":"exchanges/json-rpc/endpoints/wallets/#request_3","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"wallets.bip38.info\" , \"params\" : { \"userId\" : \"123\" } }","title":"Request"},{"location":"exchanges/json-rpc/endpoints/wallets/#response_3","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"wif\" : \"6PYTWME2aAJTx2NcRyS33zYrS79Hk7KiNbHZmGQWUYJYKWGZn4N36AdUMf\" } }","title":"Response"},{"location":"exchanges/json-rpc/endpoints/wallets/#error-response_3","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }","title":"Error Response"},{"location":"exchanges/json-rpc/endpoints/wallets/#create-a-bip38-wallet","text":"","title":"Create a BIP38 Wallet"},{"location":"exchanges/json-rpc/endpoints/wallets/#method_4","text":"wallets.bip38.create","title":"Method"},{"location":"exchanges/json-rpc/endpoints/wallets/#body-parameters_4","text":"Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.bip38 string The bip38 of the wallet to be retrieved. Yes params.userId string The identifier of the wallet to be retrieved. Yes","title":"Body Parameters"},{"location":"exchanges/json-rpc/endpoints/wallets/#request_4","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"wallets.bip38.create\" , \"params\" : { \"userId\" : \"123\" , \"bip38\" : \"this is a top secret passphrase\" } }","title":"Request"},{"location":"exchanges/json-rpc/endpoints/wallets/#response_4","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"publicKey\" : \"022cf1c9de60c22c0b5a138b6545777cb2edaf82fe3906faa345580352000f84b6\" , \"address\" : \"AL4z4quXFVPR4ybDHeJ67HfSEmFrguQ6e5\" , \"wif\" : \"6PYTWME2aAJTx2NcRyS33zYrS79Hk7KiNbHZmGQWUYJYKWGZn4N36AdUMf\" } }","title":"Response"},{"location":"exchanges/json-rpc/endpoints/wallets/#error-response_4","text":"{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }","title":"Error Response"},{"location":"exchanges/node-installation/baremetal-instructions/","text":"BareMetal or VM Install \u00b6 Installation Using the Official Installation Script \u00b6 On a fresh Ubuntu installation, follow these commands. 1. Update and Upgrade \u00b6 Always ensure your server has the latest set of updates, due to performance and security considerations. apt-get update && apt-get upgrade 2. Add a New User \u00b6 It is best to create a specific SXP-related user, which can later own the required databases as well. The user does not require sudo rights. # add 'solar' user sudo adduser solar 3. Switch to the New User \u00b6 Switch to the new user account and go to the base directory. # change to solar user and solar directory su -l solar 4. Install Dependencies and Solar Core \u00b6 We will use Solar installer script that will install all of the necessary dependencies, Solar Core onto your server and publish configuration files for it. To install essentials run this command. Download and run install-script wget -O install.sh https://raw.githubusercontent.com/solar-network/core/main/install.sh bash install.sh Process might take a while, don't interrupt it and wait for it to finish. 5. Selecting Solar Core Network \u00b6 Once installation of dependencies and Solar Core is finished you will need to select on which network you wish to operate. This can be achieved by pressing up or down arrow keys and confirming selection with enter . After you made your selection you will need to confirm by pressing y and confirm with enter . 6. Starting Solar Relay Process \u00b6 To start Solar relay process and with it synchronization process with Solar blockchain we need to start relay process with our integrated CLI: solar relay:start If the process has started you will get a message: Starting solar-relay... done 7. Checking to See if Everything Is Working \u00b6 Now we want to see if the Solar relay process has started the synchronization process you can do that by running one of these two commands solar relay:log or pm2 logs If the process has started you will see a lot of messages like this (with actual data) [ YYYY-DD-MM hh:mm:ss ][ DEBUG ] : Delegate <delegate name> ( <public key> ) allowed to forge block < #> \ud83d\udc4d Synchronization of the blockchain can take upwards of 10 hours so let it run, once its synchronized allowed to forge block messages will only pop-up every 8 seconds. A single round consists of 53 delegates each forging a single block. Ensure you properly restart the node process when editing your .env file. Use the --update-env flag, for example: pm2 restart all --update-env Next Steps \u00b6 Please note that API will be available when the node has synced with the network, which can take up to 15 hours depending on your network speed. Now that the relay node has been configured, you should head over to the JSON-RPC Getting Started or look at relevant Public API endpoints related to blockchain functionality to manage your wallets and transactions. Notes \u00b6 Please read the documentation pages for all of our SXP SDK clients and cryptography libraries (offered in many programming languages). Also, read the API documentation.","title":"Relay node installation instructions (Bare Metal or VM)"},{"location":"exchanges/node-installation/baremetal-instructions/#baremetal-or-vm-install","text":"","title":"BareMetal or VM Install"},{"location":"exchanges/node-installation/baremetal-instructions/#installation-using-the-official-installation-script","text":"On a fresh Ubuntu installation, follow these commands.","title":"Installation Using the Official Installation Script"},{"location":"exchanges/node-installation/baremetal-instructions/#1-update-and-upgrade","text":"Always ensure your server has the latest set of updates, due to performance and security considerations. apt-get update && apt-get upgrade","title":"1. Update and Upgrade"},{"location":"exchanges/node-installation/baremetal-instructions/#2-add-a-new-user","text":"It is best to create a specific SXP-related user, which can later own the required databases as well. The user does not require sudo rights. # add 'solar' user sudo adduser solar","title":"2. Add a New User"},{"location":"exchanges/node-installation/baremetal-instructions/#3-switch-to-the-new-user","text":"Switch to the new user account and go to the base directory. # change to solar user and solar directory su -l solar","title":"3. Switch to the New User"},{"location":"exchanges/node-installation/baremetal-instructions/#4-install-dependencies-and-solar-core","text":"We will use Solar installer script that will install all of the necessary dependencies, Solar Core onto your server and publish configuration files for it. To install essentials run this command. Download and run install-script wget -O install.sh https://raw.githubusercontent.com/solar-network/core/main/install.sh bash install.sh Process might take a while, don't interrupt it and wait for it to finish.","title":"4. Install Dependencies and Solar Core"},{"location":"exchanges/node-installation/baremetal-instructions/#5-selecting-solar-core-network","text":"Once installation of dependencies and Solar Core is finished you will need to select on which network you wish to operate. This can be achieved by pressing up or down arrow keys and confirming selection with enter . After you made your selection you will need to confirm by pressing y and confirm with enter .","title":"5. Selecting Solar Core Network"},{"location":"exchanges/node-installation/baremetal-instructions/#6-starting-solar-relay-process","text":"To start Solar relay process and with it synchronization process with Solar blockchain we need to start relay process with our integrated CLI: solar relay:start If the process has started you will get a message: Starting solar-relay... done","title":"6. Starting Solar Relay Process"},{"location":"exchanges/node-installation/baremetal-instructions/#7-checking-to-see-if-everything-is-working","text":"Now we want to see if the Solar relay process has started the synchronization process you can do that by running one of these two commands solar relay:log or pm2 logs If the process has started you will see a lot of messages like this (with actual data) [ YYYY-DD-MM hh:mm:ss ][ DEBUG ] : Delegate <delegate name> ( <public key> ) allowed to forge block < #> \ud83d\udc4d Synchronization of the blockchain can take upwards of 10 hours so let it run, once its synchronized allowed to forge block messages will only pop-up every 8 seconds. A single round consists of 53 delegates each forging a single block. Ensure you properly restart the node process when editing your .env file. Use the --update-env flag, for example: pm2 restart all --update-env","title":"7. Checking to See if Everything Is Working"},{"location":"exchanges/node-installation/baremetal-instructions/#next-steps","text":"Please note that API will be available when the node has synced with the network, which can take up to 15 hours depending on your network speed. Now that the relay node has been configured, you should head over to the JSON-RPC Getting Started or look at relevant Public API endpoints related to blockchain functionality to manage your wallets and transactions.","title":"Next Steps"},{"location":"exchanges/node-installation/baremetal-instructions/#notes","text":"Please read the documentation pages for all of our SXP SDK clients and cryptography libraries (offered in many programming languages). Also, read the API documentation.","title":"Notes"},{"location":"exchanges/node-installation/hardware-requirements/","text":"Hardware Requirements \u00b6 A Relay Node is a full node in the Solar network; it maintains a complete copy of the ledger (blockchain). These nodes serve as Public API endpoint, use an internal service discovery mechanism to locate other nodes and keep each other in sync. Recommended Hardware Requirements \u00b6 NodeJS 18 Relay Specification Minimum Recommended CPUs 2 4 RAM 4GB 8GB HDD 80GB 100GB - 120GB Supported OS Release Version(s) Ubuntu 18.10 / 20.x / 22.x Ubuntu 18.04 and older are no longer supported. SXP Nodes execute many query intensive operations. The most cost-effective approach for running a high-performance node is choosing SSD over HDD. Increasing the total RAM improves cache performance. Configuration Requirements \u00b6 Stable internet connection Access to multiple open ports (actual ports may be configured) Service Port Required Enabled by default Documentation p2p 6001 \u2705 \u2705 reference public API 6003 \u274c \u2705 reference webhook 6004 \u274c \u274c reference","title":"Hardware Requirements"},{"location":"exchanges/node-installation/hardware-requirements/#hardware-requirements","text":"A Relay Node is a full node in the Solar network; it maintains a complete copy of the ledger (blockchain). These nodes serve as Public API endpoint, use an internal service discovery mechanism to locate other nodes and keep each other in sync.","title":"Hardware Requirements"},{"location":"exchanges/node-installation/hardware-requirements/#recommended-hardware-requirements","text":"NodeJS 18 Relay Specification Minimum Recommended CPUs 2 4 RAM 4GB 8GB HDD 80GB 100GB - 120GB Supported OS Release Version(s) Ubuntu 18.10 / 20.x / 22.x Ubuntu 18.04 and older are no longer supported. SXP Nodes execute many query intensive operations. The most cost-effective approach for running a high-performance node is choosing SSD over HDD. Increasing the total RAM improves cache performance.","title":"Recommended Hardware Requirements"},{"location":"exchanges/node-installation/hardware-requirements/#configuration-requirements","text":"Stable internet connection Access to multiple open ports (actual ports may be configured) Service Port Required Enabled by default Documentation p2p 6001 \u2705 \u2705 reference public API 6003 \u274c \u2705 reference webhook 6004 \u274c \u274c reference","title":"Configuration Requirements"},{"location":"project/intro/","text":"Solar \u00b6 1. What is Solar? \u00b6 A decentralized community-driven blockchain project. Solar is focused on creating an ecosystem with true governance. An ecosystem with open-source developers and community involvement. 1.2 Project Mission \u00b6 Solar is a blockchain with its own native SXP coin. The SXP blockchain offers a wide variety of features and tools that allows us to level with enterprise-grade applications. 1.3 Project Key Highlights \u00b6 Community-focused Competing with top tier crypto projects Open-source tools with many use-cases Scalable and secure using the latest blockchain technology Deflationary and inflationary at the same time 2. Solar products and technical infrastructure \u00b6 2.1 Existing products \u00b6 Solar Wallet The main software to interact directly with the SXP blockchain is by using the so-called Solar wallets. The initial Solar wallets are forked from the ARK repositories and it offers basic functions to send and receive SXP coins and to vote for delegates on the SXP blockchain. New desktop, mobile, and browser wallets are currently being developed to interact with all the features that the SXP blockchain has to offer, such as creating tokens, interacting with the metaverse, tools to monitor the blockchain and a lot more. 2.2 Technical Infrastructure \u00b6 Solar is powered by Solar Core. A safe and secure Layer-1 Blockchain Framework. Solar utilizes the Delegated Proof of Stake Consensus, also known as DPoS. The Blockchain with its own native coin named SXP is fast, modular, sustainable, efficient and fully decentralized without the known issues and vulnerabilities from traditional Proof of Work (PoW) blockchains. Issues and vulnerabilities such as being energy intensive or the risk of taking part in 51% attack vectors. The Blockchain Framework has been forked from ARK Core. Solar Core improved on the security of the Blockchain Framework by fully utilizing Schnorr for signatures. Solar Core entirely drops all support for ECDSA due to persistent signature malleability vectors. Solar Core also provides a more robust block production routine to minimise the likelihood of nodes missing blocks and therefore creating a more stable and operational blockchain. Security first. The blockchain framework is open-source and actively maintained on Github by dedicated Core developers. Anyone is able to create a PR or open an issue on our Github repositories to discuss or point at a potential vulnerability in our code. These issues will always have the highest priority and will be taken seriously to ensure that the framework will always be safe to use for our users and for anyone participating in the Solar DAO. The Solar Core has several enhancements such as the Side Ledger Protocol for token issuing with and without metadata and custom transaction types to allow \u201cburning\u201d and \u201cSolContract\u201d which allows the creation of Solidity Smart Contracts on the SXP Blockchain. The Solar Core also enables dynamic forging rewards based on the position of a delegate. 3. SXP Coin Overview & Use Cases \u00b6 SXP utilizes a Delegated Proof of Stake concensus, from which the forging rewards are distributed to delegates. The delegates are able to further distribute these rewards to their voters and keep a percentage as reward for the contribution to the network. 90% of the transaction fees are automatically burned on the network and 10% are rewarded to delegates that forge the block with the fees. Users may use the SXP coin in the following ways: Payments Create fungible and non-fungible tokens Use SXP in the Metaverse Staking Funding projects on the launchpad Voting in Governance Proposals 4. Team \u00b6 The Solar Project mainly consists of open-source developers from several top tier projects with Nayiem Willems as the project leader for 2022. At time of writing, the Solar team has 25 developers working on the initial start of the project. With the delegating consensus, Solar aims to bring more developers or contributors to the project and reward them with the forging rewards generated by the delegates. Solar will also additionally have a Community Fund to fund individual projects that are using the SXP blockchain. More information about the developers can be obtained from this Github Page .","title":"Solar"},{"location":"project/intro/#solar","text":"","title":"Solar"},{"location":"project/intro/#1-what-is-solar","text":"A decentralized community-driven blockchain project. Solar is focused on creating an ecosystem with true governance. An ecosystem with open-source developers and community involvement.","title":"1. What is Solar?"},{"location":"project/intro/#12-project-mission","text":"Solar is a blockchain with its own native SXP coin. The SXP blockchain offers a wide variety of features and tools that allows us to level with enterprise-grade applications.","title":"1.2 Project Mission"},{"location":"project/intro/#13-project-key-highlights","text":"Community-focused Competing with top tier crypto projects Open-source tools with many use-cases Scalable and secure using the latest blockchain technology Deflationary and inflationary at the same time","title":"1.3 Project Key Highlights"},{"location":"project/intro/#2-solar-products-and-technical-infrastructure","text":"","title":"2. Solar products and technical infrastructure"},{"location":"project/intro/#21-existing-products","text":"Solar Wallet The main software to interact directly with the SXP blockchain is by using the so-called Solar wallets. The initial Solar wallets are forked from the ARK repositories and it offers basic functions to send and receive SXP coins and to vote for delegates on the SXP blockchain. New desktop, mobile, and browser wallets are currently being developed to interact with all the features that the SXP blockchain has to offer, such as creating tokens, interacting with the metaverse, tools to monitor the blockchain and a lot more.","title":"2.1 Existing products"},{"location":"project/intro/#22-technical-infrastructure","text":"Solar is powered by Solar Core. A safe and secure Layer-1 Blockchain Framework. Solar utilizes the Delegated Proof of Stake Consensus, also known as DPoS. The Blockchain with its own native coin named SXP is fast, modular, sustainable, efficient and fully decentralized without the known issues and vulnerabilities from traditional Proof of Work (PoW) blockchains. Issues and vulnerabilities such as being energy intensive or the risk of taking part in 51% attack vectors. The Blockchain Framework has been forked from ARK Core. Solar Core improved on the security of the Blockchain Framework by fully utilizing Schnorr for signatures. Solar Core entirely drops all support for ECDSA due to persistent signature malleability vectors. Solar Core also provides a more robust block production routine to minimise the likelihood of nodes missing blocks and therefore creating a more stable and operational blockchain. Security first. The blockchain framework is open-source and actively maintained on Github by dedicated Core developers. Anyone is able to create a PR or open an issue on our Github repositories to discuss or point at a potential vulnerability in our code. These issues will always have the highest priority and will be taken seriously to ensure that the framework will always be safe to use for our users and for anyone participating in the Solar DAO. The Solar Core has several enhancements such as the Side Ledger Protocol for token issuing with and without metadata and custom transaction types to allow \u201cburning\u201d and \u201cSolContract\u201d which allows the creation of Solidity Smart Contracts on the SXP Blockchain. The Solar Core also enables dynamic forging rewards based on the position of a delegate.","title":"2.2 Technical Infrastructure"},{"location":"project/intro/#3-sxp-coin-overview-use-cases","text":"SXP utilizes a Delegated Proof of Stake concensus, from which the forging rewards are distributed to delegates. The delegates are able to further distribute these rewards to their voters and keep a percentage as reward for the contribution to the network. 90% of the transaction fees are automatically burned on the network and 10% are rewarded to delegates that forge the block with the fees. Users may use the SXP coin in the following ways: Payments Create fungible and non-fungible tokens Use SXP in the Metaverse Staking Funding projects on the launchpad Voting in Governance Proposals","title":"3. SXP Coin Overview &amp; Use Cases"},{"location":"project/intro/#4-team","text":"The Solar Project mainly consists of open-source developers from several top tier projects with Nayiem Willems as the project leader for 2022. At time of writing, the Solar team has 25 developers working on the initial start of the project. With the delegating consensus, Solar aims to bring more developers or contributors to the project and reward them with the forging rewards generated by the delegates. Solar will also additionally have a Community Fund to fund individual projects that are using the SXP blockchain. More information about the developers can be obtained from this Github Page .","title":"4. Team"},{"location":"project/whitepaper/","text":"Initial Whitepaper by Solar (February 2022) \u00b6 The following whitepaper is referred to goals and mission statements made by Solar. Click on the link below to view or download the whitepaper. Please keep in mind that the Whitepaper will be updated with more detailed information upon mainnet release. English Whitepaper February 2022 Korean Whitepaper February 2022 Turkish Whitepaper February 2022 Vietnamese Whitepaper February 2022","title":"Whitepaper"},{"location":"project/whitepaper/#initial-whitepaper-by-solar-february-2022","text":"The following whitepaper is referred to goals and mission statements made by Solar. Click on the link below to view or download the whitepaper. Please keep in mind that the Whitepaper will be updated with more detailed information upon mainnet release. English Whitepaper February 2022 Korean Whitepaper February 2022 Turkish Whitepaper February 2022 Vietnamese Whitepaper February 2022","title":"Initial Whitepaper by Solar (February 2022)"},{"location":"sdk/documentation/","text":"Introduction \u00b6 Using SXP SDKs, developers can employ the programming language of their choice to build applications utilizing the SXP blockchain. The SXP SDKs are split into two packages for each language: Client and Cryptography. Client SDKs help developers fetch information from the SXP blockchain about its current state: which delegates are currently forging, what transactions are associated with a given wallet, and so on. Cryptography SDKs , by contrast, assist developers in working with transactions: signing, serializing, deserializing, etc. If you need to learn more about Cryptography in general, how initial key and address generation works, what is a public or private key, head over to the page link below: If your application doesn't involve sending transactions, you can most likely build your application using the Client SDK alone. Otherwise, applications looking to leverage the full spectrum of SXP APIs should make use of both Client and Cryptography SDKs. Usage guides are included for each supported language, and examples of how to use these libraries can be found in the Examples section of each specific library. Supported Languages & Frameworks \u00b6 Crypto Client TypeScript TypeScript PHP PHP Python Python","title":"Introduction"},{"location":"sdk/documentation/#introduction","text":"Using SXP SDKs, developers can employ the programming language of their choice to build applications utilizing the SXP blockchain. The SXP SDKs are split into two packages for each language: Client and Cryptography. Client SDKs help developers fetch information from the SXP blockchain about its current state: which delegates are currently forging, what transactions are associated with a given wallet, and so on. Cryptography SDKs , by contrast, assist developers in working with transactions: signing, serializing, deserializing, etc. If you need to learn more about Cryptography in general, how initial key and address generation works, what is a public or private key, head over to the page link below: If your application doesn't involve sending transactions, you can most likely build your application using the Client SDK alone. Otherwise, applications looking to leverage the full spectrum of SXP APIs should make use of both Client and Cryptography SDKs. Usage guides are included for each supported language, and examples of how to use these libraries can be found in the Examples section of each specific library.","title":"Introduction"},{"location":"sdk/documentation/#supported-languages-frameworks","text":"Crypto Client TypeScript TypeScript PHP PHP Python Python","title":"Supported Languages &amp; Frameworks"},{"location":"sdk/guidelines/client/","text":"Client Libraries \u00b6 The following is a guide for implementing a new SXP Client SDK. It covers the required functionalities as well as guidelines for how clients should typically look and behave. These guidelines are to be strictly followed if you are implementing or modifying an API client for the Solar Network. Following these guidelines is required to provide a streamlined experience across different languages to make it easier for new developers to get started with developing a new package or modify an existing one without lowering the quality of the already existing implementation. Carefully read those guidelines and abide by them while developing an API client. Required Functionality \u00b6 Connection \u00b6 Accept configuration for the base URI and API version. Optional: Allow to pass in a custom HTTP client. Connection Manager \u00b6 This can be omitted in languages which have no concept of objects and thus making it impossible to store connection objects. Connect Connect to the given connection. Disconnect Disconnect from the given connection. Connection Get a connection instance. GetDefaultConnection Get the default connection name. SetDefaultConnection Set the default connection name. GetConnections Return all of the created connections. Public API Support \u00b6 Blocks Delegates Node Peers Transactions Votes Wallets Things to Keep in Mind \u00b6 Do not assume what the developer is going to do with the output. If your programming language of choice allows you to return the raw response without any mapping, do so. If you work with a programming language like Go that is strict and requires you to provide a struct you should fully reflect the original API response in your struct. Do not incorporate any cryptography functionality. An example of this would be to have a createTransaction method that sends a signed transaction to the API and the method itself would create the signed transaction instead of expecting it as an argument. Do not integrate the P2P API as it is out of scope. In solar-node it is required to send your transactions to the P2P API because there is no Public API endpoint for doing this. With the introduction of solar-core and the revamped Public API, there is no longer the need to use the P2P API. Terminology & Phrasing \u00b6 If you need to use the SXP name, keep these 2 use-cases in mind. The first one is SXP which is used in financial contexts like 10 SXP . The second is SXP which used for everything else that is not talking about SXP , the financial unit. If you need to namespace something with a numerical value in it, write out the numerical value. An example would be App\\Versions\\One instead of App\\V1 ._ If you work with a language that provides standard interfaces for HTTP messaging, implement them to provide a standardized and compliant interface which allows other developers to inject dependencies. An example of this would be PSR-7 for PHP which allows developers to create HTTP clients that follow a standardized interface which allows switching implementations while knowing it will work. Implementation \u00b6 Depending on if you are working with an Object Oriented Programming Language or Functional Programming Language the tools at your disposal for how to implement the required functionality will differ. If you for example work with an OOP language you will be able to isolate functionality into Objects whereas you won't be able to do that with a Functional language but instead need to think of everything as Functions . There are already a few implementations of cryptography packages available, so take a look at them and decide which approach is the right one for your language. Object Oriented Programming \u00b6 https://github.com/solar-network/php-client https://github.com/solar-network/python-client","title":"Client"},{"location":"sdk/guidelines/client/#client-libraries","text":"The following is a guide for implementing a new SXP Client SDK. It covers the required functionalities as well as guidelines for how clients should typically look and behave. These guidelines are to be strictly followed if you are implementing or modifying an API client for the Solar Network. Following these guidelines is required to provide a streamlined experience across different languages to make it easier for new developers to get started with developing a new package or modify an existing one without lowering the quality of the already existing implementation. Carefully read those guidelines and abide by them while developing an API client.","title":"Client Libraries"},{"location":"sdk/guidelines/client/#required-functionality","text":"","title":"Required Functionality"},{"location":"sdk/guidelines/client/#connection","text":"Accept configuration for the base URI and API version. Optional: Allow to pass in a custom HTTP client.","title":"Connection"},{"location":"sdk/guidelines/client/#connection-manager","text":"This can be omitted in languages which have no concept of objects and thus making it impossible to store connection objects. Connect Connect to the given connection. Disconnect Disconnect from the given connection. Connection Get a connection instance. GetDefaultConnection Get the default connection name. SetDefaultConnection Set the default connection name. GetConnections Return all of the created connections.","title":"Connection Manager"},{"location":"sdk/guidelines/client/#public-api-support","text":"Blocks Delegates Node Peers Transactions Votes Wallets","title":"Public API Support"},{"location":"sdk/guidelines/client/#things-to-keep-in-mind","text":"Do not assume what the developer is going to do with the output. If your programming language of choice allows you to return the raw response without any mapping, do so. If you work with a programming language like Go that is strict and requires you to provide a struct you should fully reflect the original API response in your struct. Do not incorporate any cryptography functionality. An example of this would be to have a createTransaction method that sends a signed transaction to the API and the method itself would create the signed transaction instead of expecting it as an argument. Do not integrate the P2P API as it is out of scope. In solar-node it is required to send your transactions to the P2P API because there is no Public API endpoint for doing this. With the introduction of solar-core and the revamped Public API, there is no longer the need to use the P2P API.","title":"Things to Keep in Mind"},{"location":"sdk/guidelines/client/#terminology-phrasing","text":"If you need to use the SXP name, keep these 2 use-cases in mind. The first one is SXP which is used in financial contexts like 10 SXP . The second is SXP which used for everything else that is not talking about SXP , the financial unit. If you need to namespace something with a numerical value in it, write out the numerical value. An example would be App\\Versions\\One instead of App\\V1 ._ If you work with a language that provides standard interfaces for HTTP messaging, implement them to provide a standardized and compliant interface which allows other developers to inject dependencies. An example of this would be PSR-7 for PHP which allows developers to create HTTP clients that follow a standardized interface which allows switching implementations while knowing it will work.","title":"Terminology &amp; Phrasing"},{"location":"sdk/guidelines/client/#implementation","text":"Depending on if you are working with an Object Oriented Programming Language or Functional Programming Language the tools at your disposal for how to implement the required functionality will differ. If you for example work with an OOP language you will be able to isolate functionality into Objects whereas you won't be able to do that with a Functional language but instead need to think of everything as Functions . There are already a few implementations of cryptography packages available, so take a look at them and decide which approach is the right one for your language.","title":"Implementation"},{"location":"sdk/guidelines/client/#object-oriented-programming","text":"https://github.com/solar-network/php-client https://github.com/solar-network/python-client","title":"Object Oriented Programming"},{"location":"sdk/guidelines/crypto/","text":"Crypto Libraries \u00b6 The following is a guide for implementing a new SXP Cryptography SDK. It covers the required functionalities as well as guidelines for how cryptography should typically look and behave. These guidelines are to be strictly followed if you are implementing or modifying a cryptography package for the Solar Network. Following these guidelines is required to provide a streamlined experience across different languages to make it easier for new developers to get started with developing a new package or modify an existing one without lowering the quality of the already existing implementation. Carefully read those guidelines and abide by them while developing a cryptography package. Required Functionality \u00b6 Transaction \u00b6 getId Compute the unique transaction ID. sign Sign the transaction using a passphrase. secondSign Sign the transaction using a second passphrase. verify Verify the transaction. secondVerify Verify the transaction using a second public key. parseSignatures Parse the signature, second signature, and multi signatures. serialize Serialize the object via AIP11. deserialize Deserialize the given hex string via AIP11. fromJson Map the JSON to a new transaction object. toBytes Turn the transaction into its v1 byte representation. toArray Turn the transaction into a standardized array. toJson Turn the transaction into a JSON string using the toArray data as the source. Message \u00b6 sign Create a signed message using the given message and passphrase. verify Verify the given message, public key and signature combination. toArray Turn the message into a standardized array. toJson Turn the message into a JSON string using the toArray data as the source. Private Key \u00b6 fromPassphrase Derive a private key from the given passphrase. fromHex Get a private key instance from a private key hex string. Public Key \u00b6 fromPassphrase Derive a public key from the given passphrase. fromHex Get a public key instance from a public key hex string. Address \u00b6 fromPassphrase Derive an address from the given passphrase. fromPublicKey Derive an address from the given public key. fromPrivateKey Derive an address from the given private key. validate Validate the given address against the given network. WIF \u00b6 fromPassphrase Derive a WIF from the given passphrase. Configuration \u00b6 getNetwork Get the default network used by all functions. setNetwork Set the default network used by all functions. getFee Get a default fee by type used by all functions. setFee Set a default fee by type used by all functions. Slot \u00b6 time Get the time elapsed since network start. epoch Get the timestamp of the network start. Networks (Mainnet, Testnet) \u00b6 epoch Get the epoch of the network. version Get the version of the network. nethash Get the nethash of the network. wif Get the wif prefix of the network. Things to Keep in Mind \u00b6 Do not assume what the developer is going to do with the output. If you are working with a buffer, return the buffer instead of a hex encoded value. Add optional helper methods to easily convert identities between binary and hex . An example of this would be to be able to do privateKey.toHex() instead of having to encode the private key bytes to hex manually. Do not add functionality outside of the required functionality. An example would be to add helper methods for very niche use-cases just because they seem like a nice-to-have. Add optional helper methods to derive identities from multiple sources easily. An example would be methods like AddressFromPassphrase , PublicKeyFromPassphrase or PublicKeyFromPrivateKey . Terminology & Phrasing \u00b6 If you need to use the SXP name, keep these 2 use-cases in mind. The first one is SXP which is used in financial contexts like 10 SXP . The second is SXP which used for everything else that is not talking about SXP , the financial unit. If you work with functions that require a secret or passphrase name the variables passphrase and secondPassphrase . If you work with serialization use the American English serialization variant with z to name methods and variables. If you work with deserialization use the American English deserialization variant with z to name methods and variables. File & Directory Structure \u00b6 The structure outlined here should be followed as closely as possible. If you work with an Object Oriented Programming Language you should be able to implement this structure as is, small adjustments might be required for languages like Go as nested packages can get hacky. You can check https://github.com/solar-network/php-crypto for an example of how this structure looks like when implemented and how it is reflected in the structure of tests. [src | lib | crypto] \u251c\u2500\u2500 Configuration \u2502 \u251c\u2500\u2500 Fee \u2502 \u2514\u2500\u2500 Network \u251c\u2500\u2500 Enums \u2502 \u251c\u2500\u2500 Fees \u2502 \u2514\u2500\u2500 Types \u251c\u2500\u2500 Identities \u2502 \u251c\u2500\u2500 Address \u2502 \u251c\u2500\u2500 PrivateKey \u2502 \u251c\u2500\u2500 PublicKey \u2502 \u2514\u2500\u2500 WIF \u251c\u2500\u2500 Networks \u2502 \u251c\u2500\u2500 Mainnet \u2502 \u2514\u2500\u2500 Testnet \u251c\u2500\u2500 Transactions \u2502 \u251c\u2500\u2500 Builder \u2502 \u2502 \u251c\u2500\u2500 DelegateRegistration \u2502 \u2502 \u251c\u2500\u2500 DelegateResignation \u2502 \u2502 \u251c\u2500\u2500 IPFS \u2502 \u2502 \u251c\u2500\u2500 MultiPayment \u2502 \u2502 \u251c\u2500\u2500 MultiSignatureRegistration \u2502 \u2502 \u251c\u2500\u2500 SecondSignatureRegistration \u2502 \u2502 \u251c\u2500\u2500 TimelockTransfer \u2502 \u2502 \u251c\u2500\u2500 Transfer \u2502 \u2502 \u2514\u2500\u2500 Vote \u2502 \u251c\u2500\u2500 Deserializer \u2502 \u251c\u2500\u2500 Deserializers \u2502 \u2502 \u251c\u2500\u2500 DelegateRegistration \u2502 \u2502 \u251c\u2500\u2500 DelegateResignation \u2502 \u2502 \u251c\u2500\u2500 IPFS \u2502 \u2502 \u251c\u2500\u2500 MultiPayment \u2502 \u2502 \u251c\u2500\u2500 MultiSignatureRegistration \u2502 \u2502 \u251c\u2500\u2500 SecondSignatureRegistration \u2502 \u2502 \u251c\u2500\u2500 TimelockTransfer \u2502 \u2502 \u251c\u2500\u2500 Transfer \u2502 \u2502 \u2514\u2500\u2500 Vote \u2502 \u251c\u2500\u2500 Serializer \u2502 \u251c\u2500\u2500 Serializers \u2502 \u2502 \u251c\u2500\u2500 DelegateRegistration \u2502 \u2502 \u251c\u2500\u2500 DelegateResignation \u2502 \u2502 \u251c\u2500\u2500 IPFS \u2502 \u2502 \u251c\u2500\u2500 MultiPayment \u2502 \u2502 \u251c\u2500\u2500 MultiSignatureRegistration \u2502 \u2502 \u251c\u2500\u2500 SecondSignatureRegistration \u2502 \u2502 \u251c\u2500\u2500 TimelockTransfer \u2502 \u2502 \u251c\u2500\u2500 Transfer \u2502 \u2502 \u2514\u2500\u2500 Vote \u2502 \u2514\u2500\u2500 Transaction \u2514\u2500\u2500 Utils \u251c\u2500\u2500 Message \u2514\u2500\u2500 Slot Implementation \u00b6 Depending on if you are working with an Object Oriented Programming Language or Functional Programming Language the tools at your disposal for how to implement the required functionality will differ. If you for example work with an OOP language you will be able to isolate functionality into Objects whereas you won't be able to do that with a Functional language but instead need to think of everything as Functions . There are already a few implementations of cryptography packages available, so take a look at them and decide which approach is the right one for your language. Object Oriented Programming \u00b6 https://github.com/solar-network/php-crypto https://github.com/solar-network/python-crypto","title":"Crypto"},{"location":"sdk/guidelines/crypto/#crypto-libraries","text":"The following is a guide for implementing a new SXP Cryptography SDK. It covers the required functionalities as well as guidelines for how cryptography should typically look and behave. These guidelines are to be strictly followed if you are implementing or modifying a cryptography package for the Solar Network. Following these guidelines is required to provide a streamlined experience across different languages to make it easier for new developers to get started with developing a new package or modify an existing one without lowering the quality of the already existing implementation. Carefully read those guidelines and abide by them while developing a cryptography package.","title":"Crypto Libraries"},{"location":"sdk/guidelines/crypto/#required-functionality","text":"","title":"Required Functionality"},{"location":"sdk/guidelines/crypto/#transaction","text":"getId Compute the unique transaction ID. sign Sign the transaction using a passphrase. secondSign Sign the transaction using a second passphrase. verify Verify the transaction. secondVerify Verify the transaction using a second public key. parseSignatures Parse the signature, second signature, and multi signatures. serialize Serialize the object via AIP11. deserialize Deserialize the given hex string via AIP11. fromJson Map the JSON to a new transaction object. toBytes Turn the transaction into its v1 byte representation. toArray Turn the transaction into a standardized array. toJson Turn the transaction into a JSON string using the toArray data as the source.","title":"Transaction"},{"location":"sdk/guidelines/crypto/#message","text":"sign Create a signed message using the given message and passphrase. verify Verify the given message, public key and signature combination. toArray Turn the message into a standardized array. toJson Turn the message into a JSON string using the toArray data as the source.","title":"Message"},{"location":"sdk/guidelines/crypto/#private-key","text":"fromPassphrase Derive a private key from the given passphrase. fromHex Get a private key instance from a private key hex string.","title":"Private Key"},{"location":"sdk/guidelines/crypto/#public-key","text":"fromPassphrase Derive a public key from the given passphrase. fromHex Get a public key instance from a public key hex string.","title":"Public Key"},{"location":"sdk/guidelines/crypto/#address","text":"fromPassphrase Derive an address from the given passphrase. fromPublicKey Derive an address from the given public key. fromPrivateKey Derive an address from the given private key. validate Validate the given address against the given network.","title":"Address"},{"location":"sdk/guidelines/crypto/#wif","text":"fromPassphrase Derive a WIF from the given passphrase.","title":"WIF"},{"location":"sdk/guidelines/crypto/#configuration","text":"getNetwork Get the default network used by all functions. setNetwork Set the default network used by all functions. getFee Get a default fee by type used by all functions. setFee Set a default fee by type used by all functions.","title":"Configuration"},{"location":"sdk/guidelines/crypto/#slot","text":"time Get the time elapsed since network start. epoch Get the timestamp of the network start.","title":"Slot"},{"location":"sdk/guidelines/crypto/#networks-mainnet-testnet","text":"epoch Get the epoch of the network. version Get the version of the network. nethash Get the nethash of the network. wif Get the wif prefix of the network.","title":"Networks (Mainnet, Testnet)"},{"location":"sdk/guidelines/crypto/#things-to-keep-in-mind","text":"Do not assume what the developer is going to do with the output. If you are working with a buffer, return the buffer instead of a hex encoded value. Add optional helper methods to easily convert identities between binary and hex . An example of this would be to be able to do privateKey.toHex() instead of having to encode the private key bytes to hex manually. Do not add functionality outside of the required functionality. An example would be to add helper methods for very niche use-cases just because they seem like a nice-to-have. Add optional helper methods to derive identities from multiple sources easily. An example would be methods like AddressFromPassphrase , PublicKeyFromPassphrase or PublicKeyFromPrivateKey .","title":"Things to Keep in Mind"},{"location":"sdk/guidelines/crypto/#terminology-phrasing","text":"If you need to use the SXP name, keep these 2 use-cases in mind. The first one is SXP which is used in financial contexts like 10 SXP . The second is SXP which used for everything else that is not talking about SXP , the financial unit. If you work with functions that require a secret or passphrase name the variables passphrase and secondPassphrase . If you work with serialization use the American English serialization variant with z to name methods and variables. If you work with deserialization use the American English deserialization variant with z to name methods and variables.","title":"Terminology &amp; Phrasing"},{"location":"sdk/guidelines/crypto/#file-directory-structure","text":"The structure outlined here should be followed as closely as possible. If you work with an Object Oriented Programming Language you should be able to implement this structure as is, small adjustments might be required for languages like Go as nested packages can get hacky. You can check https://github.com/solar-network/php-crypto for an example of how this structure looks like when implemented and how it is reflected in the structure of tests. [src | lib | crypto] \u251c\u2500\u2500 Configuration \u2502 \u251c\u2500\u2500 Fee \u2502 \u2514\u2500\u2500 Network \u251c\u2500\u2500 Enums \u2502 \u251c\u2500\u2500 Fees \u2502 \u2514\u2500\u2500 Types \u251c\u2500\u2500 Identities \u2502 \u251c\u2500\u2500 Address \u2502 \u251c\u2500\u2500 PrivateKey \u2502 \u251c\u2500\u2500 PublicKey \u2502 \u2514\u2500\u2500 WIF \u251c\u2500\u2500 Networks \u2502 \u251c\u2500\u2500 Mainnet \u2502 \u2514\u2500\u2500 Testnet \u251c\u2500\u2500 Transactions \u2502 \u251c\u2500\u2500 Builder \u2502 \u2502 \u251c\u2500\u2500 DelegateRegistration \u2502 \u2502 \u251c\u2500\u2500 DelegateResignation \u2502 \u2502 \u251c\u2500\u2500 IPFS \u2502 \u2502 \u251c\u2500\u2500 MultiPayment \u2502 \u2502 \u251c\u2500\u2500 MultiSignatureRegistration \u2502 \u2502 \u251c\u2500\u2500 SecondSignatureRegistration \u2502 \u2502 \u251c\u2500\u2500 TimelockTransfer \u2502 \u2502 \u251c\u2500\u2500 Transfer \u2502 \u2502 \u2514\u2500\u2500 Vote \u2502 \u251c\u2500\u2500 Deserializer \u2502 \u251c\u2500\u2500 Deserializers \u2502 \u2502 \u251c\u2500\u2500 DelegateRegistration \u2502 \u2502 \u251c\u2500\u2500 DelegateResignation \u2502 \u2502 \u251c\u2500\u2500 IPFS \u2502 \u2502 \u251c\u2500\u2500 MultiPayment \u2502 \u2502 \u251c\u2500\u2500 MultiSignatureRegistration \u2502 \u2502 \u251c\u2500\u2500 SecondSignatureRegistration \u2502 \u2502 \u251c\u2500\u2500 TimelockTransfer \u2502 \u2502 \u251c\u2500\u2500 Transfer \u2502 \u2502 \u2514\u2500\u2500 Vote \u2502 \u251c\u2500\u2500 Serializer \u2502 \u251c\u2500\u2500 Serializers \u2502 \u2502 \u251c\u2500\u2500 DelegateRegistration \u2502 \u2502 \u251c\u2500\u2500 DelegateResignation \u2502 \u2502 \u251c\u2500\u2500 IPFS \u2502 \u2502 \u251c\u2500\u2500 MultiPayment \u2502 \u2502 \u251c\u2500\u2500 MultiSignatureRegistration \u2502 \u2502 \u251c\u2500\u2500 SecondSignatureRegistration \u2502 \u2502 \u251c\u2500\u2500 TimelockTransfer \u2502 \u2502 \u251c\u2500\u2500 Transfer \u2502 \u2502 \u2514\u2500\u2500 Vote \u2502 \u2514\u2500\u2500 Transaction \u2514\u2500\u2500 Utils \u251c\u2500\u2500 Message \u2514\u2500\u2500 Slot","title":"File &amp; Directory Structure"},{"location":"sdk/guidelines/crypto/#implementation","text":"Depending on if you are working with an Object Oriented Programming Language or Functional Programming Language the tools at your disposal for how to implement the required functionality will differ. If you for example work with an OOP language you will be able to isolate functionality into Objects whereas you won't be able to do that with a Functional language but instead need to think of everything as Functions . There are already a few implementations of cryptography packages available, so take a look at them and decide which approach is the right one for your language.","title":"Implementation"},{"location":"sdk/guidelines/crypto/#object-oriented-programming","text":"https://github.com/solar-network/php-crypto https://github.com/solar-network/python-crypto","title":"Object Oriented Programming"},{"location":"sdk/guidelines/documentation/","text":"Introduction \u00b6 This file describes a general overview that must be adhered to when writing documentation for any of the SDKs (both Crypto and Client). Following these guidelines is required to provide a streamlined experience across different languages to make it easier for developers to read up on the SDK usage in their language of choice. Carefully read those guidelines and abide by them while writing SDK documentation. Structure \u00b6 Each SDK contains as at a minimum the following three documentation files: getting-started.md , which contains all the information you need in order to work with the SDK. api-documentation.md , which contains an overview of all available functions in the SDK. examples.md , which contains actual code examples for scenario's that frequently occur. We'll explain the specifics of each file in more details in the following sections. Getting Started \u00b6 We want to make it easy for anyone to work with the SDKs. Therefore this document will detail all the steps necessary to use it in your project. These steps include listing requirements for the SDKs (in terms of what other dependencies you need to have), how to install the SDK on your system to use it and how to include or import it in a project. Note that this document should also include a section on how to start further development on the SDK, including cloning from GitHub, how to run the tests and everything else needed to properly setup a development environment. API Documentation \u00b6 The API documentation should only document the available functions in the SDK, the parameters they take and their return type. It should be accompanied by a guiding text on what the function does, but should not become a code example; save those for the actual example document. Examples \u00b6 This file is meant to show code examples on how to use the SDK. These examples should contain often-used use cases depending on the SDK type. For the Client SDK, this would for example show: How to fetch a list of blocks How to fetch all active delegates How to fetch information of a specific wallet ... For the Crypto SDK, you could give examples of: How to create a transaction with a builder How to serialize / deserialize transactions How to generate a private key / public key / address from a passphrase ... These examples are not set in stone yet and can be adjusted to what you deem fit. If an SDK has more functionality than the same SDK in another language, this would of course mean it could have additional examples. However, please keep an eye on the examples in other languages and make sure the language you work on has similar ones if the SDK contains that same functionality. That way the examples will be streamlined across different languages.","title":"Documentation"},{"location":"sdk/guidelines/documentation/#introduction","text":"This file describes a general overview that must be adhered to when writing documentation for any of the SDKs (both Crypto and Client). Following these guidelines is required to provide a streamlined experience across different languages to make it easier for developers to read up on the SDK usage in their language of choice. Carefully read those guidelines and abide by them while writing SDK documentation.","title":"Introduction"},{"location":"sdk/guidelines/documentation/#structure","text":"Each SDK contains as at a minimum the following three documentation files: getting-started.md , which contains all the information you need in order to work with the SDK. api-documentation.md , which contains an overview of all available functions in the SDK. examples.md , which contains actual code examples for scenario's that frequently occur. We'll explain the specifics of each file in more details in the following sections.","title":"Structure"},{"location":"sdk/guidelines/documentation/#getting-started","text":"We want to make it easy for anyone to work with the SDKs. Therefore this document will detail all the steps necessary to use it in your project. These steps include listing requirements for the SDKs (in terms of what other dependencies you need to have), how to install the SDK on your system to use it and how to include or import it in a project. Note that this document should also include a section on how to start further development on the SDK, including cloning from GitHub, how to run the tests and everything else needed to properly setup a development environment.","title":"Getting Started"},{"location":"sdk/guidelines/documentation/#api-documentation","text":"The API documentation should only document the available functions in the SDK, the parameters they take and their return type. It should be accompanied by a guiding text on what the function does, but should not become a code example; save those for the actual example document.","title":"API Documentation"},{"location":"sdk/guidelines/documentation/#examples","text":"This file is meant to show code examples on how to use the SDK. These examples should contain often-used use cases depending on the SDK type. For the Client SDK, this would for example show: How to fetch a list of blocks How to fetch all active delegates How to fetch information of a specific wallet ... For the Crypto SDK, you could give examples of: How to create a transaction with a builder How to serialize / deserialize transactions How to generate a private key / public key / address from a passphrase ... These examples are not set in stone yet and can be adjusted to what you deem fit. If an SDK has more functionality than the same SDK in another language, this would of course mean it could have additional examples. However, please keep an eye on the examples in other languages and make sure the language you work on has similar ones if the SDK contains that same functionality. That way the examples will be streamlined across different languages.","title":"Examples"},{"location":"sdk/javascript/installation/","text":"Installation \u00b6 NodeJS installation \u00b6 NodeJS can be downloaded here . Alternatively you can install NodeJS through your operating system packager manager . An excellent way to manage your NodeJS installation and be able to work with multiple version is to go through NVM . Install Yarn Package Manager \u00b6 Yarn is a package manager for your code. It allows you to use and share code with other developers from around the world. Yarn does this quickly, securely, and reliably so you don\u2019t ever have to worry. Instructions on how to install Yarn can be found here","title":"Installation"},{"location":"sdk/javascript/installation/#installation","text":"","title":"Installation"},{"location":"sdk/javascript/installation/#nodejs-installation","text":"NodeJS can be downloaded here . Alternatively you can install NodeJS through your operating system packager manager . An excellent way to manage your NodeJS installation and be able to work with multiple version is to go through NVM .","title":"NodeJS installation"},{"location":"sdk/javascript/installation/#install-yarn-package-manager","text":"Yarn is a package manager for your code. It allows you to use and share code with other developers from around the world. Yarn does this quickly, securely, and reliably so you don\u2019t ever have to worry. Instructions on how to install Yarn can be found here","title":"Install Yarn Package Manager"},{"location":"sdk/javascript/client/api-documentation/","text":"API Documentation \u00b6 ConnectionManager \u00b6 connect() \u00b6 public connect ( host : string , name = \"main\" ) Connect to the given connection. Parameters \u00b6 Type Name Required Description string host Yes Node URL string name No Network name Return Value \u00b6 Connection disconnect() \u00b6 public disconnect ( name? : string ) Disconnect from the given connection. Parameters \u00b6 Type Name Required Description string name No Network Name Return Value \u00b6 void connection() \u00b6 public connection ( name? : string ) Get a connection instance. Parameters \u00b6 Type Name Required Description string name No Network Name Return Value \u00b6 Connection getDefaultConnection() \u00b6 public getDefaultConnection () Get the default connection name. Return Value \u00b6 string setDefaultConnection() \u00b6 public setDefaultConnection ( name : string ) Set the default connection name. Parameters \u00b6 Type Name Required Description string name No Network Name Return Value \u00b6 void getConnections() \u00b6 public getConnections () Return all of the created connections. Return Value \u00b6 Record<string, Connection> Connection \u00b6 constructor() \u00b6 public constructor ( private readonly host : string ) Create a new Connection class instance. Parameters \u00b6 Type Name Required Description string host Yes Node URL api() \u00b6 public api < T = any > ( name : string ) Instantiate new Api. Parameters \u00b6 Type Name Required Description string name Yes Network name Return Value \u00b6 T get() \u00b6 public async get < T = any > ( url : string , opts? : Record < string , any > ) Send a GET request with query parameters. Parameters \u00b6 Type Name Required Description string url Yes Endpoint Record opts? No Query parameters Return Value \u00b6 Promise<IResponse<T>> post() \u00b6 public async post < T = any > ( url : string , opts? : Record < string , any > ) : Promise < IResponse < T >> Send a POST request with JSON-encoded parameters. Parameters \u00b6 Type Name Required Description string url Yes Endpoint Record opts? No Query parameters Return Value \u00b6 Promise<IResponse<T>> RequestError \u00b6 constructor() \u00b6 public constructor ( error ) Create a new RequestError class instance. Parameters \u00b6 Type Name Required Description string error Yes Error Resources\\Blocks \u00b6 all() \u00b6 public async all < T = any > ( query? : Record < string , any > ) Get all blocks. Parameters \u00b6 Type Name Required Description Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> get() \u00b6 public async get < T = any > ( id : string ) Get a block by the given id. Parameters \u00b6 Type Name Required Description string id Yes Block ID Return Value \u00b6 Promise<IResponse<T>> transactions() \u00b6 public async transactions < T = any > ( id : string , query? : Record < string , any > ) Get all transactions by the given block. Parameters \u00b6 Type Name Required Description string id Yes Block ID Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> search() \u00b6 public async search < T = any > ( payload? : Record < string , any > ) Filter all blocks by the given parameters. Parameters \u00b6 Type Name Required Description Record payload No Search parameters Return Value \u00b6 Promise<IResponse<T>> Resources\\Delegates \u00b6 all() \u00b6 public async all < T = any > ( query? : Record < string , any > ) Get all accounts. Parameters \u00b6 Type Name Required Description Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> get() \u00b6 public async get < T = any > ( id : string ) Get a delegate by the given id. Parameters \u00b6 Type Name Required Description string id Yes Delegate identifier Return Value \u00b6 Promise<IResponse<T>> blocks() \u00b6 public async blocks < T = any > ( id : string , query? : Record < string , any > ) Get all blocks for the given delegate. Parameters \u00b6 Type Name Required Description string id Yes Delegate identifier Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> voters() \u00b6 public async voters < T = any > ( id : string , query? : Record < string , any > ) Get all voters for the given delegate. Parameters \u00b6 Type Name Required Description string id Yes Delegate identifier Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> Resources\\Node \u00b6 configuration() \u00b6 public async configuration < T = any > () Get the node configuration. Return Value \u00b6 Promise<IResponse<T>> status() \u00b6 public async status < T = any > () Get the node status. Return Value \u00b6 Promise<IResponse<T>> syncing() \u00b6 public async syncing < T = any > () Get the node syncing status. Return Value \u00b6 Promise<IResponse<T>> fees() \u00b6 public async fees < T = any > ( days : number ) Get the node fee statistics. Parameters \u00b6 Type Name Required Description number days Yes Days Return Value \u00b6 Promise<IResponse<T>> Resources\\Peers \u00b6 all() \u00b6 public async all < T = any > ( query? : Record < string , any > ) Get all peers. Parameters \u00b6 Type Name Required Description Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> get() \u00b6 public async get < T = any > ( ip : string ) Get a peer by the given IP address. Parameters \u00b6 Type Name Required Description string ip Yes IP address Return Value \u00b6 Promise<IResponse<T>> Resources\\Transactions \u00b6 create() \u00b6 public async create < T = any > ( payload : object []) Create a new transaction. Parameters \u00b6 Type Name Required Description object[] payload Yes Transaction(s) to broadcast Return Value \u00b6 Promise<IResponse<T>> get() \u00b6 public async get < T = any > ( id : string ) Get a transaction by the given id. Parameters \u00b6 Type Name Required Description string id Yes Transaction ID Return Value \u00b6 Promise<IResponse<T>> all() \u00b6 public async all < T = any > ( query? : Record < string , any > ) Get all transactions. Parameters \u00b6 Type Name Required Description Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> allUnconfirmed() \u00b6 public async allUnconfirmed < T = any > ( query? : Record < string , any > ) Get all unconfirmed transactions. Parameters \u00b6 Type Name Required Description Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> getUnconfirmed() \u00b6 public async getUnconfirmed < T = any > ( id : string ) Get an unconfirmed transaction by the given id. Parameters \u00b6 Type Name Required Description string id Yes Transaction ID Return Value \u00b6 Promise<IResponse<T>> search() \u00b6 public async search < T = any > ( payload : Record < string , any > ) Filter all transactions by the given parameters. Parameters \u00b6 Type Name Required Description Record payload Yes Search parameters Return Value \u00b6 Promise<IResponse<T>> types() \u00b6 public async types < T = any > () Get a list of valid transaction types. Return Value \u00b6 Promise<IResponse<T>> fees() \u00b6 public async fees < T = any > () : Promise < IResponse < T >> Get the node fee statistics. Return Value \u00b6 Promise<IResponse<T>> Resources\\Votes \u00b6 all() \u00b6 public async all < T = any > ( query? : Record < string , any > ) Get all votes. Parameters \u00b6 Type Name Required Description Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> get() \u00b6 public async get < T = any > ( id : string ) Get a vote by the given id. Parameters \u00b6 Type Name Required Description string id Yes Vote ID Return Value \u00b6 Promise<IResponse<T>> Resources\\Wallets \u00b6 all() \u00b6 public async all < T = any > ( query? : Record < string , any > ) Get all wallets. Parameters \u00b6 Type Name Required Description Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> get() \u00b6 public async get < T = any > ( id : string ) Get a wallet by the given id. Parameters \u00b6 Type Name Required Description string id Yes Wallet identifier Return Value \u00b6 Promise<IResponse<T>> transactions() \u00b6 public async transactions < T = any > ( id : string , query? : Record < string , any > ) Get all transactions for the given wallet. Parameters \u00b6 Type Name Required Description string id Yes Wallet identifier Record query Yes Query parameters Return Value \u00b6 Promise<IResponse<T>> transactionsReceived() \u00b6 public async transactionsReceived < T = any > ( id : string , query? : Record < string , any > ) Get all transactions received by the given wallet. Parameters \u00b6 Type Name Required Description string id Yes Wallet identifier Record query Yes Query parameters Return Value \u00b6 Promise<IResponse<T>> transactionsSent() \u00b6 public async transactionsSent < T = any > ( id : string , query? : Record < string , any > ) Get all transactions sent by the given wallet. Parameters \u00b6 Type Name Required Description string id Yes Wallet identifier Record query Yes Query parameters Return Value \u00b6 Promise<IResponse<T>> votes() \u00b6 public async votes < T = any > ( id : string ) Get all votes by the given wallet. Parameters \u00b6 Type Name Required Description string id Yes Wallet identifier Return Value \u00b6 Promise<IResponse<T>> top() \u00b6 public async top < T = any > ( query? : Record < string , any > ) Get all wallets sorted by balance in descending order. Parameters \u00b6 Type Name Required Description Record query Yes Query parameters Return Value \u00b6 Promise<IResponse<T>> search() \u00b6 public async search < T = any > ( payload : Record < string , any > ) Filter all wallets by the given parameters. Parameters \u00b6 Type Name Required Description Record payload Yes Search parameters Return Value \u00b6 Promise<IResponse<T>>","title":"API Documentation"},{"location":"sdk/javascript/client/api-documentation/#api-documentation","text":"","title":"API Documentation"},{"location":"sdk/javascript/client/api-documentation/#connectionmanager","text":"","title":"ConnectionManager"},{"location":"sdk/javascript/client/api-documentation/#connect","text":"public connect ( host : string , name = \"main\" ) Connect to the given connection.","title":"connect()"},{"location":"sdk/javascript/client/api-documentation/#parameters","text":"Type Name Required Description string host Yes Node URL string name No Network name","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value","text":"Connection","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#disconnect","text":"public disconnect ( name? : string ) Disconnect from the given connection.","title":"disconnect()"},{"location":"sdk/javascript/client/api-documentation/#parameters_1","text":"Type Name Required Description string name No Network Name","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_1","text":"void","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#connection","text":"public connection ( name? : string ) Get a connection instance.","title":"connection()"},{"location":"sdk/javascript/client/api-documentation/#parameters_2","text":"Type Name Required Description string name No Network Name","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_2","text":"Connection","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#getdefaultconnection","text":"public getDefaultConnection () Get the default connection name.","title":"getDefaultConnection()"},{"location":"sdk/javascript/client/api-documentation/#return-value_3","text":"string","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#setdefaultconnection","text":"public setDefaultConnection ( name : string ) Set the default connection name.","title":"setDefaultConnection()"},{"location":"sdk/javascript/client/api-documentation/#parameters_3","text":"Type Name Required Description string name No Network Name","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_4","text":"void","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#getconnections","text":"public getConnections () Return all of the created connections.","title":"getConnections()"},{"location":"sdk/javascript/client/api-documentation/#return-value_5","text":"Record<string, Connection>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#connection_1","text":"","title":"Connection"},{"location":"sdk/javascript/client/api-documentation/#constructor","text":"public constructor ( private readonly host : string ) Create a new Connection class instance.","title":"constructor()"},{"location":"sdk/javascript/client/api-documentation/#parameters_4","text":"Type Name Required Description string host Yes Node URL","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#api","text":"public api < T = any > ( name : string ) Instantiate new Api.","title":"api()"},{"location":"sdk/javascript/client/api-documentation/#parameters_5","text":"Type Name Required Description string name Yes Network name","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_6","text":"T","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#get","text":"public async get < T = any > ( url : string , opts? : Record < string , any > ) Send a GET request with query parameters.","title":"get()"},{"location":"sdk/javascript/client/api-documentation/#parameters_6","text":"Type Name Required Description string url Yes Endpoint Record opts? No Query parameters","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_7","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#post","text":"public async post < T = any > ( url : string , opts? : Record < string , any > ) : Promise < IResponse < T >> Send a POST request with JSON-encoded parameters.","title":"post()"},{"location":"sdk/javascript/client/api-documentation/#parameters_7","text":"Type Name Required Description string url Yes Endpoint Record opts? No Query parameters","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_8","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#requesterror","text":"","title":"RequestError"},{"location":"sdk/javascript/client/api-documentation/#constructor_1","text":"public constructor ( error ) Create a new RequestError class instance.","title":"constructor()"},{"location":"sdk/javascript/client/api-documentation/#parameters_8","text":"Type Name Required Description string error Yes Error","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#resourcesblocks","text":"","title":"Resources\\Blocks"},{"location":"sdk/javascript/client/api-documentation/#all","text":"public async all < T = any > ( query? : Record < string , any > ) Get all blocks.","title":"all()"},{"location":"sdk/javascript/client/api-documentation/#parameters_9","text":"Type Name Required Description Record query No Query parameters","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_9","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#get_1","text":"public async get < T = any > ( id : string ) Get a block by the given id.","title":"get()"},{"location":"sdk/javascript/client/api-documentation/#parameters_10","text":"Type Name Required Description string id Yes Block ID","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_10","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#transactions","text":"public async transactions < T = any > ( id : string , query? : Record < string , any > ) Get all transactions by the given block.","title":"transactions()"},{"location":"sdk/javascript/client/api-documentation/#parameters_11","text":"Type Name Required Description string id Yes Block ID Record query No Query parameters","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_11","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#search","text":"public async search < T = any > ( payload? : Record < string , any > ) Filter all blocks by the given parameters.","title":"search()"},{"location":"sdk/javascript/client/api-documentation/#parameters_12","text":"Type Name Required Description Record payload No Search parameters","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_12","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#resourcesdelegates","text":"","title":"Resources\\Delegates"},{"location":"sdk/javascript/client/api-documentation/#all_1","text":"public async all < T = any > ( query? : Record < string , any > ) Get all accounts.","title":"all()"},{"location":"sdk/javascript/client/api-documentation/#parameters_13","text":"Type Name Required Description Record query No Query parameters","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_13","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#get_2","text":"public async get < T = any > ( id : string ) Get a delegate by the given id.","title":"get()"},{"location":"sdk/javascript/client/api-documentation/#parameters_14","text":"Type Name Required Description string id Yes Delegate identifier","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_14","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#blocks","text":"public async blocks < T = any > ( id : string , query? : Record < string , any > ) Get all blocks for the given delegate.","title":"blocks()"},{"location":"sdk/javascript/client/api-documentation/#parameters_15","text":"Type Name Required Description string id Yes Delegate identifier Record query No Query parameters","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_15","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#voters","text":"public async voters < T = any > ( id : string , query? : Record < string , any > ) Get all voters for the given delegate.","title":"voters()"},{"location":"sdk/javascript/client/api-documentation/#parameters_16","text":"Type Name Required Description string id Yes Delegate identifier Record query No Query parameters","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_16","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#resourcesnode","text":"","title":"Resources\\Node"},{"location":"sdk/javascript/client/api-documentation/#configuration","text":"public async configuration < T = any > () Get the node configuration.","title":"configuration()"},{"location":"sdk/javascript/client/api-documentation/#return-value_17","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#status","text":"public async status < T = any > () Get the node status.","title":"status()"},{"location":"sdk/javascript/client/api-documentation/#return-value_18","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#syncing","text":"public async syncing < T = any > () Get the node syncing status.","title":"syncing()"},{"location":"sdk/javascript/client/api-documentation/#return-value_19","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#fees","text":"public async fees < T = any > ( days : number ) Get the node fee statistics.","title":"fees()"},{"location":"sdk/javascript/client/api-documentation/#parameters_17","text":"Type Name Required Description number days Yes Days","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_20","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#resourcespeers","text":"","title":"Resources\\Peers"},{"location":"sdk/javascript/client/api-documentation/#all_2","text":"public async all < T = any > ( query? : Record < string , any > ) Get all peers.","title":"all()"},{"location":"sdk/javascript/client/api-documentation/#parameters_18","text":"Type Name Required Description Record query No Query parameters","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_21","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#get_3","text":"public async get < T = any > ( ip : string ) Get a peer by the given IP address.","title":"get()"},{"location":"sdk/javascript/client/api-documentation/#parameters_19","text":"Type Name Required Description string ip Yes IP address","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_22","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#resourcestransactions","text":"","title":"Resources\\Transactions"},{"location":"sdk/javascript/client/api-documentation/#create","text":"public async create < T = any > ( payload : object []) Create a new transaction.","title":"create()"},{"location":"sdk/javascript/client/api-documentation/#parameters_20","text":"Type Name Required Description object[] payload Yes Transaction(s) to broadcast","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_23","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#get_4","text":"public async get < T = any > ( id : string ) Get a transaction by the given id.","title":"get()"},{"location":"sdk/javascript/client/api-documentation/#parameters_21","text":"Type Name Required Description string id Yes Transaction ID","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_24","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#all_3","text":"public async all < T = any > ( query? : Record < string , any > ) Get all transactions.","title":"all()"},{"location":"sdk/javascript/client/api-documentation/#parameters_22","text":"Type Name Required Description Record query No Query parameters","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_25","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#allunconfirmed","text":"public async allUnconfirmed < T = any > ( query? : Record < string , any > ) Get all unconfirmed transactions.","title":"allUnconfirmed()"},{"location":"sdk/javascript/client/api-documentation/#parameters_23","text":"Type Name Required Description Record query No Query parameters","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_26","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#getunconfirmed","text":"public async getUnconfirmed < T = any > ( id : string ) Get an unconfirmed transaction by the given id.","title":"getUnconfirmed()"},{"location":"sdk/javascript/client/api-documentation/#parameters_24","text":"Type Name Required Description string id Yes Transaction ID","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_27","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#search_1","text":"public async search < T = any > ( payload : Record < string , any > ) Filter all transactions by the given parameters.","title":"search()"},{"location":"sdk/javascript/client/api-documentation/#parameters_25","text":"Type Name Required Description Record payload Yes Search parameters","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_28","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#types","text":"public async types < T = any > () Get a list of valid transaction types.","title":"types()"},{"location":"sdk/javascript/client/api-documentation/#return-value_29","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#fees_1","text":"public async fees < T = any > () : Promise < IResponse < T >> Get the node fee statistics.","title":"fees()"},{"location":"sdk/javascript/client/api-documentation/#return-value_30","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#resourcesvotes","text":"","title":"Resources\\Votes"},{"location":"sdk/javascript/client/api-documentation/#all_4","text":"public async all < T = any > ( query? : Record < string , any > ) Get all votes.","title":"all()"},{"location":"sdk/javascript/client/api-documentation/#parameters_26","text":"Type Name Required Description Record query No Query parameters","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_31","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#get_5","text":"public async get < T = any > ( id : string ) Get a vote by the given id.","title":"get()"},{"location":"sdk/javascript/client/api-documentation/#parameters_27","text":"Type Name Required Description string id Yes Vote ID","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_32","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#resourceswallets","text":"","title":"Resources\\Wallets"},{"location":"sdk/javascript/client/api-documentation/#all_5","text":"public async all < T = any > ( query? : Record < string , any > ) Get all wallets.","title":"all()"},{"location":"sdk/javascript/client/api-documentation/#parameters_28","text":"Type Name Required Description Record query No Query parameters","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_33","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#get_6","text":"public async get < T = any > ( id : string ) Get a wallet by the given id.","title":"get()"},{"location":"sdk/javascript/client/api-documentation/#parameters_29","text":"Type Name Required Description string id Yes Wallet identifier","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_34","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#transactions_1","text":"public async transactions < T = any > ( id : string , query? : Record < string , any > ) Get all transactions for the given wallet.","title":"transactions()"},{"location":"sdk/javascript/client/api-documentation/#parameters_30","text":"Type Name Required Description string id Yes Wallet identifier Record query Yes Query parameters","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_35","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#transactionsreceived","text":"public async transactionsReceived < T = any > ( id : string , query? : Record < string , any > ) Get all transactions received by the given wallet.","title":"transactionsReceived()"},{"location":"sdk/javascript/client/api-documentation/#parameters_31","text":"Type Name Required Description string id Yes Wallet identifier Record query Yes Query parameters","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_36","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#transactionssent","text":"public async transactionsSent < T = any > ( id : string , query? : Record < string , any > ) Get all transactions sent by the given wallet.","title":"transactionsSent()"},{"location":"sdk/javascript/client/api-documentation/#parameters_32","text":"Type Name Required Description string id Yes Wallet identifier Record query Yes Query parameters","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_37","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#votes","text":"public async votes < T = any > ( id : string ) Get all votes by the given wallet.","title":"votes()"},{"location":"sdk/javascript/client/api-documentation/#parameters_33","text":"Type Name Required Description string id Yes Wallet identifier","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_38","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#top","text":"public async top < T = any > ( query? : Record < string , any > ) Get all wallets sorted by balance in descending order.","title":"top()"},{"location":"sdk/javascript/client/api-documentation/#parameters_34","text":"Type Name Required Description Record query Yes Query parameters","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_39","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/api-documentation/#search_2","text":"public async search < T = any > ( payload : Record < string , any > ) Filter all wallets by the given parameters.","title":"search()"},{"location":"sdk/javascript/client/api-documentation/#parameters_35","text":"Type Name Required Description Record payload Yes Search parameters","title":"Parameters"},{"location":"sdk/javascript/client/api-documentation/#return-value_40","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/javascript/client/examples/","text":"Examples \u00b6 Initialization \u00b6 import ApiClient from '@solar-network/client' const client = new ApiClient ( server , 2 ) // API version Blocks \u00b6 This service API grants access to the blocks resource . A block is a signed set of transactions created by a delegate and permanently committed to the SXP blockchain. It is not possible to POST a block through the public API. Relay Nodes accept only blocks posted by a delegate at the correct time through the internal API. List All Blocks \u00b6 const { blocks } = await client . resource ( 'blocks' ). all () >>> Promise < IResponse < T >> Retrieve a Block \u00b6 const { block } = await client . resource ( 'blocks' ). get ( 'validBlockId' ) >>> Promise < IResponse < T >> List All Transactions of a Block \u00b6 const { blockTransactions } = await client . resource ( 'blocks' ). transactions ( 'validBlockId' ) >>> Promise < IResponse < T >> Search All Blocks \u00b6 const { searchedBlocks } = await client . resource ( 'blocks' ). search ({ \"id\" : \"validBlockId\" }) >>> Promise < IResponse < T >> Delegates \u00b6 The client SDK can be used to query the delegate resource . A delegate is a regular wallet that has broadcast a registration transaction, acquired a sufficient number of votes, and has a Relay Node configured to forge new blocks through a forger module. At any time only 51 delegates are active. They are cost-efficient miners running the SXP network. Voters are wallets which have broadcast a vote transaction on a delegate. A vote remains active until an un-vote transaction is sent (it does not have to be recast unless a wallet wishes to change from delegate). Voting for a delegate does not give the delegate access to the wallet nor does it lock the coins in it. List All Delegates \u00b6 const { delegates } = await client . resource ( 'delegates' ). all () >>> Promise < IResponse < T >> Retrieve a Delegate \u00b6 const { delegate } = await client . resource ( 'delegates' ). get ( \"validId\" ) >>> Promise < IResponse < T >> List All Blocks of a Delegate \u00b6 const { delegateBlocks } = await client . resource ( 'delegates' ). blocks ( \"validId\" ) >>> Promise < IResponse < T >> List All Voters of a Delegate \u00b6 const { delegateVoters } = await client . resource ( 'delegates' ). voters ( \"validId\" ) >>> Promise < IResponse < T >> Node \u00b6 The SXP network consists of different anonymous nodes (servers), maintaining the public ledger, validating transactions and blocks and providing APIs. The node resource allows for querying the health and configurations of the node used by the instantiated client. Retrieve the Configuration \u00b6 const { nodeConfiguration } = await client . resource ( 'node' ). configuration () >>> Promise < IResponse < T >> Retrieve the Status \u00b6 const { nodeStatus } = await client . resource ( 'node' ). status () >>> Promise < IResponse < T >> Retrieve the Syncing Status \u00b6 const { nodeSyncing } = await client . resource ( 'node' ). syncing () >>> Promise < IResponse < T >> Retrieve the Fees \u00b6 const { nodeFees } = await client . resource ( 'node' ). fees () >>> Promise < IResponse < T >> Peers \u00b6 Each node is connected to a set of peers, which are Relay or Delegate Nodes as well. The peers resource provides access to all peers connected to our node. Peers have made their Public API available for use; however for mission-critical queries and transaction posting you should use a node which is under your control. We provide a guide to setting up a Relay Node here . List All Peers \u00b6 const { peers } = await client . resource ( 'peers' ). all () >>> Promise < IResponse < T >> Retrieve a Peer \u00b6 const { peer } = await client . resource ( 'peers' ). get ( \"validIpAddress\" ) >>> Promise < IResponse < T >> Transactions \u00b6 The heart of any blockchain is formed by its transactions; state-altering payloads signed by a wallet. Most likely you will be querying for transactions most often, using the transaction resource . A transaction is the only object which may be posted by a non-delegate. It requires a signature from a wallet containing a sufficient amount of SXP. Create a Transaction \u00b6 const { transaction } = await client . resource ( 'transactions' ). create ([...]) >>> Promise < IResponse < T >> Retrieve a Transaction \u00b6 const { transaction } = await client . resource ( 'transactions' ). get ( \"validId\" ) >>> Promise < IResponse < T >> List All Transactions \u00b6 const { transaction } = await client . resource ( 'transactions' ). all () >>> Promise < IResponse < T >> List All Unconfirmed Transactions \u00b6 const { transaction } = await client . resource ( 'transactions' ). allUnconfirmed () >>> Promise < IResponse < T >> Get Unconfirmed Transaction \u00b6 const { transaction } = await client . resource ( 'transactions' ). getUnconfirmed ( \"validId\" ) >>> Promise < IResponse < T >> Search Transactions \u00b6 const { transaction } = await client . resource ( 'transactions' ). search ({ \"id\" : \"validId\" }) >>> Promise < IResponse < T >> List Transaction Types \u00b6 const { transaction } = await client . resource ( 'transactions' ). types () >>> Promise < IResponse < T >> Votes \u00b6 A vote is a transaction sub-type, where the asset field contains a votes object and the transaction.type is 3 . List All Votes \u00b6 const { votes } = await client . resource ( 'votes' ). all () >>> Promise < IResponse < T >> Retrieve a Vote \u00b6 const { vote } = await client . resource ( 'votes' ). get ( \"validId\" ) >>> Promise < IResponse < T >> Wallets \u00b6 The wallet resource provides access to: Wallets. Incoming and outgoing transactions per wallet. Each wallet's votes. Retrieve All Wallets \u00b6 const { wallets } = await client . resource ( 'wallets' ). all () >>> Promise < IResponse < T >> Retrieve a Wallet \u00b6 const { wallet } = await client . resource ( 'wallets' ). get ( \"validId\" ) >>> Promise < IResponse < T >> List All Transactions of a Wallet \u00b6 const { walletTransactions } = await client . resource ( 'wallets' ). transactions ( \"validId\" ) >>> Promise < IResponse < T >> List All Received Transactions of a Wallet \u00b6 const { wallets } = await client . resource ( 'wallets' ). transactionsReceived ( \"validId\" ) >>> Promise < IResponse < T >> List All Sent Transactions of a Wallet \u00b6 const { wallets } = await client . resource ( 'wallets' ). transactionsSent ( \"validId\" ) >>> Promise < IResponse < T >> List All Votes of a Wallet \u00b6 const { wallets } = await client . resource ( 'wallets' ). votes ( \"validId\" ) >>> Promise < IResponse < T >> List All Top Wallets \u00b6 const { wallets } = await client . resource ( 'wallets' ). top () >>> Promise < IResponse < T >> Search All Wallets \u00b6 const { wallets } = await client . resource ( 'wallets' ). search ({ \"id\" : \"validId\" }) >>> Promise < IResponse < T >>","title":"Examples"},{"location":"sdk/javascript/client/examples/#examples","text":"","title":"Examples"},{"location":"sdk/javascript/client/examples/#initialization","text":"import ApiClient from '@solar-network/client' const client = new ApiClient ( server , 2 ) // API version","title":"Initialization"},{"location":"sdk/javascript/client/examples/#blocks","text":"This service API grants access to the blocks resource . A block is a signed set of transactions created by a delegate and permanently committed to the SXP blockchain. It is not possible to POST a block through the public API. Relay Nodes accept only blocks posted by a delegate at the correct time through the internal API.","title":"Blocks"},{"location":"sdk/javascript/client/examples/#list-all-blocks","text":"const { blocks } = await client . resource ( 'blocks' ). all () >>> Promise < IResponse < T >>","title":"List All Blocks"},{"location":"sdk/javascript/client/examples/#retrieve-a-block","text":"const { block } = await client . resource ( 'blocks' ). get ( 'validBlockId' ) >>> Promise < IResponse < T >>","title":"Retrieve a Block"},{"location":"sdk/javascript/client/examples/#list-all-transactions-of-a-block","text":"const { blockTransactions } = await client . resource ( 'blocks' ). transactions ( 'validBlockId' ) >>> Promise < IResponse < T >>","title":"List All Transactions of a Block"},{"location":"sdk/javascript/client/examples/#search-all-blocks","text":"const { searchedBlocks } = await client . resource ( 'blocks' ). search ({ \"id\" : \"validBlockId\" }) >>> Promise < IResponse < T >>","title":"Search All Blocks"},{"location":"sdk/javascript/client/examples/#delegates","text":"The client SDK can be used to query the delegate resource . A delegate is a regular wallet that has broadcast a registration transaction, acquired a sufficient number of votes, and has a Relay Node configured to forge new blocks through a forger module. At any time only 51 delegates are active. They are cost-efficient miners running the SXP network. Voters are wallets which have broadcast a vote transaction on a delegate. A vote remains active until an un-vote transaction is sent (it does not have to be recast unless a wallet wishes to change from delegate). Voting for a delegate does not give the delegate access to the wallet nor does it lock the coins in it.","title":"Delegates"},{"location":"sdk/javascript/client/examples/#list-all-delegates","text":"const { delegates } = await client . resource ( 'delegates' ). all () >>> Promise < IResponse < T >>","title":"List All Delegates"},{"location":"sdk/javascript/client/examples/#retrieve-a-delegate","text":"const { delegate } = await client . resource ( 'delegates' ). get ( \"validId\" ) >>> Promise < IResponse < T >>","title":"Retrieve a Delegate"},{"location":"sdk/javascript/client/examples/#list-all-blocks-of-a-delegate","text":"const { delegateBlocks } = await client . resource ( 'delegates' ). blocks ( \"validId\" ) >>> Promise < IResponse < T >>","title":"List All Blocks of a Delegate"},{"location":"sdk/javascript/client/examples/#list-all-voters-of-a-delegate","text":"const { delegateVoters } = await client . resource ( 'delegates' ). voters ( \"validId\" ) >>> Promise < IResponse < T >>","title":"List All Voters of a Delegate"},{"location":"sdk/javascript/client/examples/#node","text":"The SXP network consists of different anonymous nodes (servers), maintaining the public ledger, validating transactions and blocks and providing APIs. The node resource allows for querying the health and configurations of the node used by the instantiated client.","title":"Node"},{"location":"sdk/javascript/client/examples/#retrieve-the-configuration","text":"const { nodeConfiguration } = await client . resource ( 'node' ). configuration () >>> Promise < IResponse < T >>","title":"Retrieve the Configuration"},{"location":"sdk/javascript/client/examples/#retrieve-the-status","text":"const { nodeStatus } = await client . resource ( 'node' ). status () >>> Promise < IResponse < T >>","title":"Retrieve the Status"},{"location":"sdk/javascript/client/examples/#retrieve-the-syncing-status","text":"const { nodeSyncing } = await client . resource ( 'node' ). syncing () >>> Promise < IResponse < T >>","title":"Retrieve the Syncing Status"},{"location":"sdk/javascript/client/examples/#retrieve-the-fees","text":"const { nodeFees } = await client . resource ( 'node' ). fees () >>> Promise < IResponse < T >>","title":"Retrieve the Fees"},{"location":"sdk/javascript/client/examples/#peers","text":"Each node is connected to a set of peers, which are Relay or Delegate Nodes as well. The peers resource provides access to all peers connected to our node. Peers have made their Public API available for use; however for mission-critical queries and transaction posting you should use a node which is under your control. We provide a guide to setting up a Relay Node here .","title":"Peers"},{"location":"sdk/javascript/client/examples/#list-all-peers","text":"const { peers } = await client . resource ( 'peers' ). all () >>> Promise < IResponse < T >>","title":"List All Peers"},{"location":"sdk/javascript/client/examples/#retrieve-a-peer","text":"const { peer } = await client . resource ( 'peers' ). get ( \"validIpAddress\" ) >>> Promise < IResponse < T >>","title":"Retrieve a Peer"},{"location":"sdk/javascript/client/examples/#transactions","text":"The heart of any blockchain is formed by its transactions; state-altering payloads signed by a wallet. Most likely you will be querying for transactions most often, using the transaction resource . A transaction is the only object which may be posted by a non-delegate. It requires a signature from a wallet containing a sufficient amount of SXP.","title":"Transactions"},{"location":"sdk/javascript/client/examples/#create-a-transaction","text":"const { transaction } = await client . resource ( 'transactions' ). create ([...]) >>> Promise < IResponse < T >>","title":"Create a Transaction"},{"location":"sdk/javascript/client/examples/#retrieve-a-transaction","text":"const { transaction } = await client . resource ( 'transactions' ). get ( \"validId\" ) >>> Promise < IResponse < T >>","title":"Retrieve a Transaction"},{"location":"sdk/javascript/client/examples/#list-all-transactions","text":"const { transaction } = await client . resource ( 'transactions' ). all () >>> Promise < IResponse < T >>","title":"List All Transactions"},{"location":"sdk/javascript/client/examples/#list-all-unconfirmed-transactions","text":"const { transaction } = await client . resource ( 'transactions' ). allUnconfirmed () >>> Promise < IResponse < T >>","title":"List All Unconfirmed Transactions"},{"location":"sdk/javascript/client/examples/#get-unconfirmed-transaction","text":"const { transaction } = await client . resource ( 'transactions' ). getUnconfirmed ( \"validId\" ) >>> Promise < IResponse < T >>","title":"Get Unconfirmed Transaction"},{"location":"sdk/javascript/client/examples/#search-transactions","text":"const { transaction } = await client . resource ( 'transactions' ). search ({ \"id\" : \"validId\" }) >>> Promise < IResponse < T >>","title":"Search Transactions"},{"location":"sdk/javascript/client/examples/#list-transaction-types","text":"const { transaction } = await client . resource ( 'transactions' ). types () >>> Promise < IResponse < T >>","title":"List Transaction Types"},{"location":"sdk/javascript/client/examples/#votes","text":"A vote is a transaction sub-type, where the asset field contains a votes object and the transaction.type is 3 .","title":"Votes"},{"location":"sdk/javascript/client/examples/#list-all-votes","text":"const { votes } = await client . resource ( 'votes' ). all () >>> Promise < IResponse < T >>","title":"List All Votes"},{"location":"sdk/javascript/client/examples/#retrieve-a-vote","text":"const { vote } = await client . resource ( 'votes' ). get ( \"validId\" ) >>> Promise < IResponse < T >>","title":"Retrieve a Vote"},{"location":"sdk/javascript/client/examples/#wallets","text":"The wallet resource provides access to: Wallets. Incoming and outgoing transactions per wallet. Each wallet's votes.","title":"Wallets"},{"location":"sdk/javascript/client/examples/#retrieve-all-wallets","text":"const { wallets } = await client . resource ( 'wallets' ). all () >>> Promise < IResponse < T >>","title":"Retrieve All Wallets"},{"location":"sdk/javascript/client/examples/#retrieve-a-wallet","text":"const { wallet } = await client . resource ( 'wallets' ). get ( \"validId\" ) >>> Promise < IResponse < T >>","title":"Retrieve a Wallet"},{"location":"sdk/javascript/client/examples/#list-all-transactions-of-a-wallet","text":"const { walletTransactions } = await client . resource ( 'wallets' ). transactions ( \"validId\" ) >>> Promise < IResponse < T >>","title":"List All Transactions of a Wallet"},{"location":"sdk/javascript/client/examples/#list-all-received-transactions-of-a-wallet","text":"const { wallets } = await client . resource ( 'wallets' ). transactionsReceived ( \"validId\" ) >>> Promise < IResponse < T >>","title":"List All Received Transactions of a Wallet"},{"location":"sdk/javascript/client/examples/#list-all-sent-transactions-of-a-wallet","text":"const { wallets } = await client . resource ( 'wallets' ). transactionsSent ( \"validId\" ) >>> Promise < IResponse < T >>","title":"List All Sent Transactions of a Wallet"},{"location":"sdk/javascript/client/examples/#list-all-votes-of-a-wallet","text":"const { wallets } = await client . resource ( 'wallets' ). votes ( \"validId\" ) >>> Promise < IResponse < T >>","title":"List All Votes of a Wallet"},{"location":"sdk/javascript/client/examples/#list-all-top-wallets","text":"const { wallets } = await client . resource ( 'wallets' ). top () >>> Promise < IResponse < T >>","title":"List All Top Wallets"},{"location":"sdk/javascript/client/examples/#search-all-wallets","text":"const { wallets } = await client . resource ( 'wallets' ). search ({ \"id\" : \"validId\" }) >>> Promise < IResponse < T >>","title":"Search All Wallets"},{"location":"sdk/javascript/client/intro/","text":"Client \u00b6 Install package with Yarn \u00b6 yarn add @solar-network/client Development \u00b6 Fork the package . Clone your forked repository. git clone https://github.com/<githubusername>/javascript-client Next, move into the fresh cloned directory. cd javascript-client Proceed to install the dependencies. yarn install Dependencies are now installed, you can now run the tests to see if everything is running as it should. yarn test","title":"Getting Started"},{"location":"sdk/javascript/client/intro/#client","text":"","title":"Client"},{"location":"sdk/javascript/client/intro/#install-package-with-yarn","text":"yarn add @solar-network/client","title":"Install package with Yarn"},{"location":"sdk/javascript/client/intro/#development","text":"Fork the package . Clone your forked repository. git clone https://github.com/<githubusername>/javascript-client Next, move into the fresh cloned directory. cd javascript-client Proceed to install the dependencies. yarn install Dependencies are now installed, you can now run the tests to see if everything is running as it should. yarn test","title":"Development"},{"location":"sdk/javascript/crypto/examples/","text":"Examples \u00b6 Initialization \u00b6 const { crypto } = require ( \"@solar-network/crypto\" ); // Throughout this document, the keys object used is: const keys = crypto . getKeys ( \"this is a top-secret passphrase\" ); Transactions \u00b6 A transaction is an object specifying the transfer of funds from the sender's wallet to the recipient's. Each transaction must be signed by the sender's private key to prove authenticity and origin. After broadcasting through the client SDK , a transaction is permanently incorporated in the blockchain by a Delegate Node. Sign \u00b6 The crypto SDK can sign a transaction using your private key or passphrase (from which the private key is generated). Ensure you are familiar with digital signatures before using the crypto SDKs. const { Transaction } = require ( \"@solar-network/crypto\" ). models ; const transaction = { type : 0 , amount : 1000 , fee : 2000 , recipientId : \"validRecipientId\" , timestamp : 121212 , asset : {}, senderPublicKey : \"validPublicKey\" }; crypto . sign ( transaction , keys ); >>> TBuilder Serialize (AIP11) \u00b6 Serialization of a transaction object ensures it is compact and properly formatted to be incorporated in the SXP blockchain. If you are using the crypto SDK in combination with the public API SDK, you should not need to serialize manually. const { Transaction } = require ( \"@solar-network/crypto\" ). models ; const serialized = Transaction . serialize ( transaction ). toString ( \"hex\" ); >>> string Deserialize (AIP11) \u00b6 A serialized transaction may be deserialized for inspection purposes. The public API does not return serialized transactions, so you should only need to deserialize in exceptional circumstances. const { Transaction } = require ( \"@solar-network/crypto\" ). models ; const deserialized = Transaction . deserialize ( serialized ); >>> ITransaction Message \u00b6 The crypto SDK not only supports transactions but can also work with other arbitrary data (expressed as strings). Sign \u00b6 Signing a string works much like signing a transaction: in most implementations, the message is hashed, and the resulting hash is signed using the private key or passphrase . const message = \"Arbitrary entry of data\" ; const hash = utils . sha256 ( message ); const signature = crypto . signHash ( hash , keys ); const signed = { message , hash , signature }; >>> IMessage Verify \u00b6 A message's signature can easily be verified by hash, without the private key that signed the message, by using the verify method. crypto . verifyHash ( signed . hash , signed . signature , \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b\" ); >>> boolean Identities \u00b6 The identities class allows for the creation and inspection of keyPairs from passphrases . Here you find vital functions when creating transactions and managing wallets. Derive the Address from a Passphrase \u00b6 const { identities } = require ( \"@solar-network/crypto\" ); identities . address . fromPassphrase ( \"this is a top secret passphrase\" ); >>> string Derive the Address from a Public Key \u00b6 const { identities } = require ( \"@solar-network/crypto\" ); identities . address . fromPublicKey ( \"validPublicKey\" ); >>> string Derive the Address from a Private Key \u00b6 const { identities } = require ( \"@solar-network/crypto\" ); identities . address . fromPrivateKey ( \"validPrivateKey\" ); >>> string Validate an Address \u00b6 const { identities } = require ( \"@solar-network/crypto\" ); identities . address . validate ( \"validAddress\" ); >>> boolean Private Key \u00b6 As the name implies, private keys and passphrases are to remain private. Never store these unencrypted and minimize access to these secrets Derive the Private Key from a Passphrase \u00b6 const { identities } = require ( \"@solar-network/crypto\" ); identities . privateKey . fromPassphrase ( \"this is a top secret passphrase\" ); >>> string Derive the Private Key Instance Object from a Hexadecimal Encoded String \u00b6 This function has not been implemented in this client library . Derive the Private Key from a WIF \u00b6 const { identities } = require ( \"@solar-network/crypto\" ); identities . privateKey . fromWIF ( \"validWif\" ); >>> string Public Key \u00b6 Public Keys may be freely shared, and are included in transaction objects to validate the authenticity. Derive the Public Key from a Passphrase \u00b6 const { identities } = require ( \"@solar-network/crypto\" ); identities . publicKey . fromPassphrase ( \"this is a top secret passphrase\" ); >>> string Derive the Public Key Instance Object from a Hexadecimal Encoded String \u00b6 This function has not been implemented in this client library . Validate a Public Key \u00b6 const { identities } = require ( \"@solar-network/crypto\" ); identities . publicKey . validate ( \"validPublicKey\" ); >>> boolean WIF \u00b6 The WIF should remain secret, just like your passphrase and private key . Derive the WIF from a Passphrase \u00b6 const { identities } = require ( \"@solar-network/crypto\" ); identities . wif . fromPassphrase ( \"this is a top secret passphrase\" ); >>> string","title":"Examples"},{"location":"sdk/javascript/crypto/examples/#examples","text":"","title":"Examples"},{"location":"sdk/javascript/crypto/examples/#initialization","text":"const { crypto } = require ( \"@solar-network/crypto\" ); // Throughout this document, the keys object used is: const keys = crypto . getKeys ( \"this is a top-secret passphrase\" );","title":"Initialization"},{"location":"sdk/javascript/crypto/examples/#transactions","text":"A transaction is an object specifying the transfer of funds from the sender's wallet to the recipient's. Each transaction must be signed by the sender's private key to prove authenticity and origin. After broadcasting through the client SDK , a transaction is permanently incorporated in the blockchain by a Delegate Node.","title":"Transactions"},{"location":"sdk/javascript/crypto/examples/#sign","text":"The crypto SDK can sign a transaction using your private key or passphrase (from which the private key is generated). Ensure you are familiar with digital signatures before using the crypto SDKs. const { Transaction } = require ( \"@solar-network/crypto\" ). models ; const transaction = { type : 0 , amount : 1000 , fee : 2000 , recipientId : \"validRecipientId\" , timestamp : 121212 , asset : {}, senderPublicKey : \"validPublicKey\" }; crypto . sign ( transaction , keys ); >>> TBuilder","title":"Sign"},{"location":"sdk/javascript/crypto/examples/#serialize-aip11","text":"Serialization of a transaction object ensures it is compact and properly formatted to be incorporated in the SXP blockchain. If you are using the crypto SDK in combination with the public API SDK, you should not need to serialize manually. const { Transaction } = require ( \"@solar-network/crypto\" ). models ; const serialized = Transaction . serialize ( transaction ). toString ( \"hex\" ); >>> string","title":"Serialize (AIP11)"},{"location":"sdk/javascript/crypto/examples/#deserialize-aip11","text":"A serialized transaction may be deserialized for inspection purposes. The public API does not return serialized transactions, so you should only need to deserialize in exceptional circumstances. const { Transaction } = require ( \"@solar-network/crypto\" ). models ; const deserialized = Transaction . deserialize ( serialized ); >>> ITransaction","title":"Deserialize (AIP11)"},{"location":"sdk/javascript/crypto/examples/#message","text":"The crypto SDK not only supports transactions but can also work with other arbitrary data (expressed as strings).","title":"Message"},{"location":"sdk/javascript/crypto/examples/#sign_1","text":"Signing a string works much like signing a transaction: in most implementations, the message is hashed, and the resulting hash is signed using the private key or passphrase . const message = \"Arbitrary entry of data\" ; const hash = utils . sha256 ( message ); const signature = crypto . signHash ( hash , keys ); const signed = { message , hash , signature }; >>> IMessage","title":"Sign"},{"location":"sdk/javascript/crypto/examples/#verify","text":"A message's signature can easily be verified by hash, without the private key that signed the message, by using the verify method. crypto . verifyHash ( signed . hash , signed . signature , \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b\" ); >>> boolean","title":"Verify"},{"location":"sdk/javascript/crypto/examples/#identities","text":"The identities class allows for the creation and inspection of keyPairs from passphrases . Here you find vital functions when creating transactions and managing wallets.","title":"Identities"},{"location":"sdk/javascript/crypto/examples/#derive-the-address-from-a-passphrase","text":"const { identities } = require ( \"@solar-network/crypto\" ); identities . address . fromPassphrase ( \"this is a top secret passphrase\" ); >>> string","title":"Derive the Address from a Passphrase"},{"location":"sdk/javascript/crypto/examples/#derive-the-address-from-a-public-key","text":"const { identities } = require ( \"@solar-network/crypto\" ); identities . address . fromPublicKey ( \"validPublicKey\" ); >>> string","title":"Derive the Address from a Public Key"},{"location":"sdk/javascript/crypto/examples/#derive-the-address-from-a-private-key","text":"const { identities } = require ( \"@solar-network/crypto\" ); identities . address . fromPrivateKey ( \"validPrivateKey\" ); >>> string","title":"Derive the Address from a Private Key"},{"location":"sdk/javascript/crypto/examples/#validate-an-address","text":"const { identities } = require ( \"@solar-network/crypto\" ); identities . address . validate ( \"validAddress\" ); >>> boolean","title":"Validate an Address"},{"location":"sdk/javascript/crypto/examples/#private-key","text":"As the name implies, private keys and passphrases are to remain private. Never store these unencrypted and minimize access to these secrets","title":"Private Key"},{"location":"sdk/javascript/crypto/examples/#derive-the-private-key-from-a-passphrase","text":"const { identities } = require ( \"@solar-network/crypto\" ); identities . privateKey . fromPassphrase ( \"this is a top secret passphrase\" ); >>> string","title":"Derive the Private Key from a Passphrase"},{"location":"sdk/javascript/crypto/examples/#derive-the-private-key-instance-object-from-a-hexadecimal-encoded-string","text":"This function has not been implemented in this client library .","title":"Derive the Private Key Instance Object from a Hexadecimal Encoded String"},{"location":"sdk/javascript/crypto/examples/#derive-the-private-key-from-a-wif","text":"const { identities } = require ( \"@solar-network/crypto\" ); identities . privateKey . fromWIF ( \"validWif\" ); >>> string","title":"Derive the Private Key from a WIF"},{"location":"sdk/javascript/crypto/examples/#public-key","text":"Public Keys may be freely shared, and are included in transaction objects to validate the authenticity.","title":"Public Key"},{"location":"sdk/javascript/crypto/examples/#derive-the-public-key-from-a-passphrase","text":"const { identities } = require ( \"@solar-network/crypto\" ); identities . publicKey . fromPassphrase ( \"this is a top secret passphrase\" ); >>> string","title":"Derive the Public Key from a Passphrase"},{"location":"sdk/javascript/crypto/examples/#derive-the-public-key-instance-object-from-a-hexadecimal-encoded-string","text":"This function has not been implemented in this client library .","title":"Derive the Public Key Instance Object from a Hexadecimal Encoded String"},{"location":"sdk/javascript/crypto/examples/#validate-a-public-key","text":"const { identities } = require ( \"@solar-network/crypto\" ); identities . publicKey . validate ( \"validPublicKey\" ); >>> boolean","title":"Validate a Public Key"},{"location":"sdk/javascript/crypto/examples/#wif","text":"The WIF should remain secret, just like your passphrase and private key .","title":"WIF"},{"location":"sdk/javascript/crypto/examples/#derive-the-wif-from-a-passphrase","text":"const { identities } = require ( \"@solar-network/crypto\" ); identities . wif . fromPassphrase ( \"this is a top secret passphrase\" ); >>> string","title":"Derive the WIF from a Passphrase"},{"location":"sdk/javascript/crypto/intro/","text":"Crypto \u00b6 Install package with Yarn \u00b6 yarn add @solar-network/crypto Development \u00b6 Fork the package . Clone your forked repository. git clone https://github.com/<githubusername>/javascript-crypto Next, move into the fresh cloned directory. cd javascript-crypto Proceed to install the dependencies. yarn install Dependencies are now installed, you can now run the tests to see if everything is running as it should. yarn test","title":"Getting Started"},{"location":"sdk/javascript/crypto/intro/#crypto","text":"","title":"Crypto"},{"location":"sdk/javascript/crypto/intro/#install-package-with-yarn","text":"yarn add @solar-network/crypto","title":"Install package with Yarn"},{"location":"sdk/javascript/crypto/intro/#development","text":"Fork the package . Clone your forked repository. git clone https://github.com/<githubusername>/javascript-crypto Next, move into the fresh cloned directory. cd javascript-crypto Proceed to install the dependencies. yarn install Dependencies are now installed, you can now run the tests to see if everything is running as it should. yarn test","title":"Development"},{"location":"sdk/python/complementary-examples/","text":"Complementary Examples \u00b6 Prerequisites \u00b6 Before we get started we need to make sure that all of the required dependencies are installed. These dependencies are the Solar Crypto SDK and Solar Client SDK. You can head on over to their documentations to read more about them but for now we are only concerned with installing them to get up and running. Open your project and execute the following commands to install both SDKs. Make sure that those complete without any errors. If you encounter any errors, please open an issue with as much information as you can provide so that our developers can have a look and get to the bottom of the issue. sudo apt update && sudo apt install python3-pip python3-dev python3-venv cd <PROJECT_DIR> python3 -m venv .venv . ./venv/bin/activate pip3 install wheel pip3 install git+https://github.com/Solar-network/python-client.git@master#egg = solar-client --upgrade pip3 install solar-crypto --upgrade Creating and Broadcasting a Transfer \u00b6 from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.transfer import Transfer # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://sxp.testnet.sh/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = Transfer () transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . add_transfer ( 1 , 'RECIPIENT_WALLET_ADDRESS_1' ) transaction . add_transfer ( 2 , 'RECIPIENT_WALLET_ADDRESS_2' ) transaction . set_memo ( \"Hello World\" ) #transaction.set_version(3) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse ) The transaction memo is optional and limited to a length of 255 characters. It can be a good idea to add memo to your transactions if you want to be able to easily track them in the future. Rest of the examples assume V3 transactions as default. You must set the version explicity using transaction.set_version(int) otherwise. Creating and Broadcasting a Legacy Transfer \u00b6 from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.legacy_transfer import LegacyTransfer # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://sxp.testnet.sh/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = LegacyTransfer ( recipientId = 'RECIPIENT_WALLET_ADDRESS' , amount = 200000000 , memo = \"Hello World\" ) transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse ) Creating and Broadcasting a Second Signature \u00b6 from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.second_signature_registration import SecondSignatureRegistration # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://sxp.testnet.sh/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = SecondSignatureRegistration ( 'this is a top secret second passphrase' ) transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse ) Creating and Broadcasting a Delegate Registration \u00b6 from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.delegate_registration import DelegateRegistration # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://sxp.testnet.sh/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = DelegateRegistration ( 'johndoe' ) transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse ) Creating and Broadcasting a Delegate Resignation \u00b6 from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.delegate_resignation import DelegateResignation # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://sxp.testnet.sh/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = DelegateResignation () transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse ) A delegate resignation has to be sent from the delegate wallet itself to verify its identity. Creating and Broadcasting a Vote (Solar Version >= 4.0.0) \u00b6 from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.vote import Vote # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://sxp.testnet.sh/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = Vote () transaction . set_votes ({ \"asterix\" : 34.9 , \"obelix\" : 35.1 , \"getafix\" : 30.0 }) # must tot up to 100.00 transaction . set_votes ([ \"+asterix\" , \"-obelix\" , \"+getafix\" ]) # will ignore obelix and distribute the wallet to asterix & getafix 50:50 transaction . set_votes ([ \"-obelix\" ]) # will ignore obelix and cancel vote transaction . set_votes ({}) #cancel vote transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse ) Creating and Broadcasting a Legacy Vote (Solar Version >= 3.3.0 & < 4.0.0) \u00b6 from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.legacy_vote import LegacyVote # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://sxp.testnet.sh/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = LegacyVote () transaction . set_votes ([ \"-obelix\" ]) # cancel vote transaction . set_votes ([ \"+asterix\" ]) # vote transaction . set_votes ([ \"-obelix\" , \"+asterix\" ]) # switch vote transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse ) Creating and Broadcasting a MultiSignature Registration \u00b6 from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.multi_signature_registration import MultiSignatureRegistration # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://sxp.testnet.sh/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = MultiSignatureRegistration () transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . set_sender_public_key ( 'SENDER_WALLET_PUBLIC_KEY' ) transaction . set_min ( 2 ) transaction . set_public_keys ([ 'participant_1_pk' , 'participant_2_pk' ]) transaction . add_participant ( 'participant_3_pk' ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse ) Creating and Broadcasting a IPFS \u00b6 from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.ipfs import IPFS # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://sxp.testnet.sh/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = IPFS ( 'QmYSK2JyM3RyDyB52caZCTKFR3HKniEcMnNJYdk8DQ6KKB' ) transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse ) Creating and Broadcasting a HTLC Lock \u00b6 from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP , HTLC_LOCK_EXPIRATION_TYPE from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.htlc_lock import HtlcLock from solar_crypto.utils.slot import get_time from hashlib import sha256 # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://sxp.testnet.sh/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Secret hash is sha256 of the sha256 hash of the original message secret = \"super secret code that must be unique and entirely random\" secret_code = sha256 ( secret . encode ()) . digest () secret_hash = sha256 ( secret_code ) . hexdigest () # Expiration value must be > lastBlock.data.timestamp + blocktime * activeDelegates expire_in = 600 # set to expire in 10 min. # Step 2: Create the transaction transaction = HtlcLock ( recipient_id = 'RECIPIENT_WALLET_ADDRESS' , amount = 200000000 , secret_hash = secret_hash , expiration_type = HTLC_LOCK_EXPIRATION_TYPE . EPOCH_TIMESTAMP . value , expiration_value = get_time () + expire_in ) transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse ) Creating and Broadcasting a HTLC Claim \u00b6 from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP , HashingType from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.htlc_claim import HtlcClaim import hashlib # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://sxp.testnet.sh/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Unlock secret is the sha256 hash of the original message secret = \"super secret code that must be unique and entirely random\" unlock_secret = hashlib . sha256 ( secret . encode ( 'utf-8' )) . hexdigest () # Step 2: Create the transaction transaction = HtlcClaim ( 'LOCK_TRANSACTION_ID' , unlock_secret , HashingType . SHA256 ) transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse ) The unlockSecret has to be a SHA256 hash of the plain text secret that you shared with the person that is allowed to claim the transaction. Creating and Broadcasting a HTLC Refund \u00b6 from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.htlc_refund import HtlcRefund # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://sxp.testnet.sh/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = HtlcRefund ( lock_transaction_id = 'LOCK_TRANSACTION_ID' ) transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse )","title":"Complementary Examples"},{"location":"sdk/python/complementary-examples/#complementary-examples","text":"","title":"Complementary Examples"},{"location":"sdk/python/complementary-examples/#prerequisites","text":"Before we get started we need to make sure that all of the required dependencies are installed. These dependencies are the Solar Crypto SDK and Solar Client SDK. You can head on over to their documentations to read more about them but for now we are only concerned with installing them to get up and running. Open your project and execute the following commands to install both SDKs. Make sure that those complete without any errors. If you encounter any errors, please open an issue with as much information as you can provide so that our developers can have a look and get to the bottom of the issue. sudo apt update && sudo apt install python3-pip python3-dev python3-venv cd <PROJECT_DIR> python3 -m venv .venv . ./venv/bin/activate pip3 install wheel pip3 install git+https://github.com/Solar-network/python-client.git@master#egg = solar-client --upgrade pip3 install solar-crypto --upgrade","title":"Prerequisites"},{"location":"sdk/python/complementary-examples/#creating-and-broadcasting-a-transfer","text":"from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.transfer import Transfer # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://sxp.testnet.sh/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = Transfer () transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . add_transfer ( 1 , 'RECIPIENT_WALLET_ADDRESS_1' ) transaction . add_transfer ( 2 , 'RECIPIENT_WALLET_ADDRESS_2' ) transaction . set_memo ( \"Hello World\" ) #transaction.set_version(3) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse ) The transaction memo is optional and limited to a length of 255 characters. It can be a good idea to add memo to your transactions if you want to be able to easily track them in the future. Rest of the examples assume V3 transactions as default. You must set the version explicity using transaction.set_version(int) otherwise.","title":"Creating and Broadcasting a Transfer"},{"location":"sdk/python/complementary-examples/#creating-and-broadcasting-a-legacy-transfer","text":"from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.legacy_transfer import LegacyTransfer # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://sxp.testnet.sh/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = LegacyTransfer ( recipientId = 'RECIPIENT_WALLET_ADDRESS' , amount = 200000000 , memo = \"Hello World\" ) transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse )","title":"Creating and Broadcasting a Legacy Transfer"},{"location":"sdk/python/complementary-examples/#creating-and-broadcasting-a-second-signature","text":"from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.second_signature_registration import SecondSignatureRegistration # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://sxp.testnet.sh/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = SecondSignatureRegistration ( 'this is a top secret second passphrase' ) transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse )","title":"Creating and Broadcasting a Second Signature"},{"location":"sdk/python/complementary-examples/#creating-and-broadcasting-a-delegate-registration","text":"from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.delegate_registration import DelegateRegistration # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://sxp.testnet.sh/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = DelegateRegistration ( 'johndoe' ) transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse )","title":"Creating and Broadcasting a Delegate Registration"},{"location":"sdk/python/complementary-examples/#creating-and-broadcasting-a-delegate-resignation","text":"from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.delegate_resignation import DelegateResignation # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://sxp.testnet.sh/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = DelegateResignation () transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse ) A delegate resignation has to be sent from the delegate wallet itself to verify its identity.","title":"Creating and Broadcasting a Delegate Resignation"},{"location":"sdk/python/complementary-examples/#creating-and-broadcasting-a-vote-solar-version-400","text":"from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.vote import Vote # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://sxp.testnet.sh/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = Vote () transaction . set_votes ({ \"asterix\" : 34.9 , \"obelix\" : 35.1 , \"getafix\" : 30.0 }) # must tot up to 100.00 transaction . set_votes ([ \"+asterix\" , \"-obelix\" , \"+getafix\" ]) # will ignore obelix and distribute the wallet to asterix & getafix 50:50 transaction . set_votes ([ \"-obelix\" ]) # will ignore obelix and cancel vote transaction . set_votes ({}) #cancel vote transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse )","title":"Creating and Broadcasting a Vote (Solar Version &gt;= 4.0.0)"},{"location":"sdk/python/complementary-examples/#creating-and-broadcasting-a-legacy-vote-solar-version-330-400","text":"from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.legacy_vote import LegacyVote # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://sxp.testnet.sh/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = LegacyVote () transaction . set_votes ([ \"-obelix\" ]) # cancel vote transaction . set_votes ([ \"+asterix\" ]) # vote transaction . set_votes ([ \"-obelix\" , \"+asterix\" ]) # switch vote transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse )","title":"Creating and Broadcasting a Legacy Vote (Solar Version &gt;= 3.3.0 &amp; &lt; 4.0.0)"},{"location":"sdk/python/complementary-examples/#creating-and-broadcasting-a-multisignature-registration","text":"from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.multi_signature_registration import MultiSignatureRegistration # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://sxp.testnet.sh/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = MultiSignatureRegistration () transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . set_sender_public_key ( 'SENDER_WALLET_PUBLIC_KEY' ) transaction . set_min ( 2 ) transaction . set_public_keys ([ 'participant_1_pk' , 'participant_2_pk' ]) transaction . add_participant ( 'participant_3_pk' ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse )","title":"Creating and Broadcasting a MultiSignature Registration"},{"location":"sdk/python/complementary-examples/#creating-and-broadcasting-a-ipfs","text":"from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.ipfs import IPFS # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://sxp.testnet.sh/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = IPFS ( 'QmYSK2JyM3RyDyB52caZCTKFR3HKniEcMnNJYdk8DQ6KKB' ) transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse )","title":"Creating and Broadcasting a IPFS"},{"location":"sdk/python/complementary-examples/#creating-and-broadcasting-a-htlc-lock","text":"from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP , HTLC_LOCK_EXPIRATION_TYPE from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.htlc_lock import HtlcLock from solar_crypto.utils.slot import get_time from hashlib import sha256 # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://sxp.testnet.sh/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Secret hash is sha256 of the sha256 hash of the original message secret = \"super secret code that must be unique and entirely random\" secret_code = sha256 ( secret . encode ()) . digest () secret_hash = sha256 ( secret_code ) . hexdigest () # Expiration value must be > lastBlock.data.timestamp + blocktime * activeDelegates expire_in = 600 # set to expire in 10 min. # Step 2: Create the transaction transaction = HtlcLock ( recipient_id = 'RECIPIENT_WALLET_ADDRESS' , amount = 200000000 , secret_hash = secret_hash , expiration_type = HTLC_LOCK_EXPIRATION_TYPE . EPOCH_TIMESTAMP . value , expiration_value = get_time () + expire_in ) transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse )","title":"Creating and Broadcasting a HTLC Lock"},{"location":"sdk/python/complementary-examples/#creating-and-broadcasting-a-htlc-claim","text":"from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP , HashingType from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.htlc_claim import HtlcClaim import hashlib # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://sxp.testnet.sh/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Unlock secret is the sha256 hash of the original message secret = \"super secret code that must be unique and entirely random\" unlock_secret = hashlib . sha256 ( secret . encode ( 'utf-8' )) . hexdigest () # Step 2: Create the transaction transaction = HtlcClaim ( 'LOCK_TRANSACTION_ID' , unlock_secret , HashingType . SHA256 ) transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse ) The unlockSecret has to be a SHA256 hash of the plain text secret that you shared with the person that is allowed to claim the transaction.","title":"Creating and Broadcasting a HTLC Claim"},{"location":"sdk/python/complementary-examples/#creating-and-broadcasting-a-htlc-refund","text":"from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.htlc_refund import HtlcRefund # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://sxp.testnet.sh/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = HtlcRefund ( lock_transaction_id = 'LOCK_TRANSACTION_ID' ) transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse )","title":"Creating and Broadcasting a HTLC Refund"},{"location":"sdk/python/installation/","text":"Installation \u00b6 Python can be downloaded here . For further information on how to install Python on your operating system : Windows guide Unix guide OSx guide On OSx you can also install Python through HomeBrew , which would also install pip along, to do so, you need to install HomeBrew and then run the following command : brew install python3 Install pip \u00b6 pip is the standard package manager for Python. It allows you to install and manage additional packages that are not part of the Python standard library. On Windows : Download get-pip.py Open your terminal ( powershell , cmd , ...) and navigate to the folder containing get-pip.py Run the following command : python get-pip.py Pip is now installed On Unix : Debian / Ubuntu : sudo apt install python3-pip CentOS / Rhel : sudo yum install epel-release sudo yum install python-pip Fedora : sudo dnf install python3 Arch Linux : sudo pacman -S python-pip openSUSE : sudo zypper install python3-pip On macOS : Download get-pip.py and then run it curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py python get-pip.py With Brew : brew install python3 You can verify that pip was installed properly by running the following command in your terminal : pip -V which should returns the version of the installed pip program.","title":"Installation"},{"location":"sdk/python/installation/#installation","text":"Python can be downloaded here . For further information on how to install Python on your operating system : Windows guide Unix guide OSx guide On OSx you can also install Python through HomeBrew , which would also install pip along, to do so, you need to install HomeBrew and then run the following command : brew install python3","title":"Installation"},{"location":"sdk/python/installation/#install-pip","text":"pip is the standard package manager for Python. It allows you to install and manage additional packages that are not part of the Python standard library. On Windows : Download get-pip.py Open your terminal ( powershell , cmd , ...) and navigate to the folder containing get-pip.py Run the following command : python get-pip.py Pip is now installed On Unix : Debian / Ubuntu : sudo apt install python3-pip CentOS / Rhel : sudo yum install epel-release sudo yum install python-pip Fedora : sudo dnf install python3 Arch Linux : sudo pacman -S python-pip openSUSE : sudo zypper install python3-pip On macOS : Download get-pip.py and then run it curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py python get-pip.py With Brew : brew install python3 You can verify that pip was installed properly by running the following command in your terminal : pip -V which should returns the version of the installed pip program.","title":"Install pip"},{"location":"sdk/python/client/api-documentation/","text":"API Documentation \u00b6 client.api.blocks.Blocks \u00b6 all() \u00b6 def all ( self , page = None , limit = 100 , ** kwargs ) List All Blocks. Parameters \u00b6 Type Name Required Description int page No Pagination int limit No Result limits any **kwargs No Query parameters Return Value \u00b6 <class 'dict'> get() \u00b6 def get ( self , block_id ) Retrieve a Block Parameters \u00b6 Type Name Required Description int block_id Yes Block ID Return Value \u00b6 <class 'dict'> transactions() \u00b6 def transactions ( self , block_id , page = None , limit = 100 ) List All Transactions of a Block Parameters \u00b6 Type Name Required Description str block_id Yes Block ID int page No Pagination int limit No Query parameters Return Value \u00b6 <class 'dict'> search() \u00b6 def search ( self , criteria , page = None , limit = 100 ) Search All Blocks Parameters \u00b6 Type Name Required Description dict criteria Yes Search parameters int page No Pagination int limit No Result limit Return Value \u00b6 <class 'dict'> client.api.delegates.Delegates \u00b6 all() \u00b6 def all ( self , page = None , limit = 100 , ** kwargs ) List All Delegates Parameters \u00b6 Type Name Required Description int page No Pagination int limit No Result limits any **kwargs No Query parameters Return Value \u00b6 <class 'dict'> get() \u00b6 def get ( self , delegate_id ) Retrieve a Delegate Parameters \u00b6 Type Name Required Description int delegate_id Yes Delegate identifier Return Value \u00b6 <class 'dict'> search() \u00b6 def search ( self , username , page = None , limit = 100 ) Search Delegates Parameters \u00b6 Type Name Required Description str username Yes Delegate username int page No Pagination int limit No Result limits Return Value \u00b6 <class 'dict'> blocks() \u00b6 def blocks ( self , delegate_id , page = None , limit = 100 ) List All Blocks of a Delegate Parameters \u00b6 Type Name Required Description str delegate_id Yes Delegate identifier int page No Pagination int limit No Result limits Return Value \u00b6 <class 'dict'> voters() \u00b6 def voters ( self , delegate_id , page = None , limit = 100 , ** kwargs ) List All Voters of a Delegate Parameters \u00b6 Type Name Required Description str delegate_id Yes Delegate identifier int page No Pagination int limit No Result limits any **kwargs No Query parameters Return Value \u00b6 <class 'dict'> client.api.node.Node \u00b6 configuration() \u00b6 def configuration ( self ) Retrieve the Configuration Return Value \u00b6 <class 'dict'> status() \u00b6 def status ( self ) Retrieve the Status Return Value \u00b6 <class 'dict'> syncing() \u00b6 def syncing ( self ) Retrieve the Syncing Status Return Value \u00b6 <class 'dict'> fees() \u00b6 def fees ( self , days = None ) Retrieve the Fees Parameters \u00b6 Type Name Required Description int days No ... Return Value \u00b6 <class 'dict'> client.api.peers.Peers \u00b6 all() \u00b6 def all ( self , os = None , status = None , port = None , version = None , order_by = None , page = None , limit = 100 ) List All Peers Parameters \u00b6 Type Name Required Description s str os No Operating System str status No Peer status int port No Peer port str version No Peer version str order_by No Order by int page No Pagination int limit No Result limit Return Value \u00b6 <class 'dict'> get() \u00b6 def get ( self , ip ) Retrieve a Peer Parameters \u00b6 Type Name Required Description str ip Yes IP address Return Value \u00b6 <class 'dict'> client.api.transactions.Transactions \u00b6 create() \u00b6 def create ( self , transactions ) Create a Transaction Parameters \u00b6 Type Name Required Description list transactions Yes Transaction to broadcast Return Value \u00b6 <class 'dict'> get() \u00b6 def get ( self , transaction_id ) Retrieve a Transaction Parameters \u00b6 Type Name Required Description str transaction_id Yes Transaction ID Return Value \u00b6 <class 'dict'> all() \u00b6 def all ( self , page = None , limit = 100 , ** kwargs ) List All Transactions Parameters \u00b6 Type Name Required Description int page No Pagination int limit No Result limit any **kwargs No Query parameters Return Value \u00b6 <class 'dict'> all_unconfirmed() \u00b6 def all_unconfirmed ( self , limit = 100 , offset = None , ** kwargs ) List All Unconfirmed Transactions Parameters \u00b6 Type Name Required Description int limit No Result limit int offset No Offset any **kwargs No Query parameters Return Value \u00b6 <class 'dict'> get_unconfirmed() \u00b6 def get_unconfirmed ( self , transaction_id ) Get Unconfirmed Transaction Parameters \u00b6 Type Name Required Description str transaction_id Yes Transaction ID Return Value \u00b6 <class 'dict'> search() \u00b6 def search ( self , criteria , page = None , limit = 100 ) Search Transactions Parameters \u00b6 Type Name Required Description dict criteria Yes Search parameters int page No Pagination int limit No Result limit Return Value \u00b6 <class 'dict'> types() \u00b6 def types ( self ) List Transaction Types Return Value \u00b6 <class 'dict'> fees() \u00b6 def fees ( self ) List Transaction Fees (Non-Dynamic) Return Value \u00b6 <class 'dict'> client.api.votes.Votes \u00b6 all() \u00b6 def all ( self , page = None , limit = 100 ) List All Votes Parameters \u00b6 Type Name Required Description s int page No Pagination int limit No Result limit Return Value \u00b6 <class 'dict'> get() \u00b6 def get ( self , vote_id ) Retrieve a Vote Parameters \u00b6 Type Name Required Description str vote_id Yes Vote IDs Return Value \u00b6 <class 'dict'> client.api.wallets.Wallets \u00b6 all() \u00b6 def all ( self , page = None , limit = 100 ) Retrieve All Wallets Parameters \u00b6 Type Name Required Description int page No Pagination int limit No Result limit Return Value \u00b6 <class 'dict'> get() \u00b6 def get ( self , wallet_id ) Retrieve a Wallet Parameters \u00b6 Type Name Required Description str wallet_id Yes Wallet identifier Return Value \u00b6 <class 'dict'> transactions() \u00b6 def transactions ( self , wallet_id , page = None , limit = 100 , ** kwargs ) List All Transactions of a Wallet Parameters \u00b6 Type Name Required Description str wallet_id Yes Wallet identifier int page No Pagination int limit No Result limit any **kwargs No Query parameters Return Value \u00b6 <class 'dict'> transactions_received() \u00b6 def transactions_received ( self , wallet_id , page = None , limit = 100 ) List All Received Transactions of a Wallet Parameters \u00b6 Type Name Required Description str wallet_id Yes Wallet identifier int page No Pagination int limit No Result limit Return Value \u00b6 <class 'dict'> transactions_sent() \u00b6 def transactions_sent ( self , wallet_id , page = None , limit = 100 ) List All Sent Transactions of a Wallet Parameters \u00b6 Type Name Required Description str wallet_id Yes Wallet identifier int page No Pagination int limit No Result limit Return Value \u00b6 <class 'dict'> votes() \u00b6 def votes ( self , wallet_id , page = None , limit = 100 ) List All Votes of a Wallet Parameters \u00b6 Type Name Required Description str wallet_id Yes Wallet identifier int page No Pagination int limit No Result limit Return Value \u00b6 <class 'dict'> top() \u00b6 def top ( self , page = None , limit = 100 ) List All Top Wallets Parameters \u00b6 Type Name Required Description int page No Pagination int limit No Result limit Return Value \u00b6 <class 'dict'> search() \u00b6 def search ( self , criteria , page = None , limit = 100 ) Search All Wallets Parameters \u00b6 Type Name Required Description dict criteria Yes Search parameters int page No Pagination int limit No Result limit Return Value \u00b6 <class 'dict'>","title":"API Documentation"},{"location":"sdk/python/client/api-documentation/#api-documentation","text":"","title":"API Documentation"},{"location":"sdk/python/client/api-documentation/#clientapiblocksblocks","text":"","title":"client.api.blocks.Blocks"},{"location":"sdk/python/client/api-documentation/#all","text":"def all ( self , page = None , limit = 100 , ** kwargs ) List All Blocks.","title":"all()"},{"location":"sdk/python/client/api-documentation/#parameters","text":"Type Name Required Description int page No Pagination int limit No Result limits any **kwargs No Query parameters","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#get","text":"def get ( self , block_id ) Retrieve a Block","title":"get()"},{"location":"sdk/python/client/api-documentation/#parameters_1","text":"Type Name Required Description int block_id Yes Block ID","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_1","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#transactions","text":"def transactions ( self , block_id , page = None , limit = 100 ) List All Transactions of a Block","title":"transactions()"},{"location":"sdk/python/client/api-documentation/#parameters_2","text":"Type Name Required Description str block_id Yes Block ID int page No Pagination int limit No Query parameters","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_2","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#search","text":"def search ( self , criteria , page = None , limit = 100 ) Search All Blocks","title":"search()"},{"location":"sdk/python/client/api-documentation/#parameters_3","text":"Type Name Required Description dict criteria Yes Search parameters int page No Pagination int limit No Result limit","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_3","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#clientapidelegatesdelegates","text":"","title":"client.api.delegates.Delegates"},{"location":"sdk/python/client/api-documentation/#all_1","text":"def all ( self , page = None , limit = 100 , ** kwargs ) List All Delegates","title":"all()"},{"location":"sdk/python/client/api-documentation/#parameters_4","text":"Type Name Required Description int page No Pagination int limit No Result limits any **kwargs No Query parameters","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_4","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#get_1","text":"def get ( self , delegate_id ) Retrieve a Delegate","title":"get()"},{"location":"sdk/python/client/api-documentation/#parameters_5","text":"Type Name Required Description int delegate_id Yes Delegate identifier","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_5","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#search_1","text":"def search ( self , username , page = None , limit = 100 ) Search Delegates","title":"search()"},{"location":"sdk/python/client/api-documentation/#parameters_6","text":"Type Name Required Description str username Yes Delegate username int page No Pagination int limit No Result limits","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_6","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#blocks","text":"def blocks ( self , delegate_id , page = None , limit = 100 ) List All Blocks of a Delegate","title":"blocks()"},{"location":"sdk/python/client/api-documentation/#parameters_7","text":"Type Name Required Description str delegate_id Yes Delegate identifier int page No Pagination int limit No Result limits","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_7","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#voters","text":"def voters ( self , delegate_id , page = None , limit = 100 , ** kwargs ) List All Voters of a Delegate","title":"voters()"},{"location":"sdk/python/client/api-documentation/#parameters_8","text":"Type Name Required Description str delegate_id Yes Delegate identifier int page No Pagination int limit No Result limits any **kwargs No Query parameters","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_8","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#clientapinodenode","text":"","title":"client.api.node.Node"},{"location":"sdk/python/client/api-documentation/#configuration","text":"def configuration ( self ) Retrieve the Configuration","title":"configuration()"},{"location":"sdk/python/client/api-documentation/#return-value_9","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#status","text":"def status ( self ) Retrieve the Status","title":"status()"},{"location":"sdk/python/client/api-documentation/#return-value_10","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#syncing","text":"def syncing ( self ) Retrieve the Syncing Status","title":"syncing()"},{"location":"sdk/python/client/api-documentation/#return-value_11","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#fees","text":"def fees ( self , days = None ) Retrieve the Fees","title":"fees()"},{"location":"sdk/python/client/api-documentation/#parameters_9","text":"Type Name Required Description int days No ...","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_12","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#clientapipeerspeers","text":"","title":"client.api.peers.Peers"},{"location":"sdk/python/client/api-documentation/#all_2","text":"def all ( self , os = None , status = None , port = None , version = None , order_by = None , page = None , limit = 100 ) List All Peers","title":"all()"},{"location":"sdk/python/client/api-documentation/#parameters_10","text":"Type Name Required Description s str os No Operating System str status No Peer status int port No Peer port str version No Peer version str order_by No Order by int page No Pagination int limit No Result limit","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_13","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#get_2","text":"def get ( self , ip ) Retrieve a Peer","title":"get()"},{"location":"sdk/python/client/api-documentation/#parameters_11","text":"Type Name Required Description str ip Yes IP address","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_14","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#clientapitransactionstransactions","text":"","title":"client.api.transactions.Transactions"},{"location":"sdk/python/client/api-documentation/#create","text":"def create ( self , transactions ) Create a Transaction","title":"create()"},{"location":"sdk/python/client/api-documentation/#parameters_12","text":"Type Name Required Description list transactions Yes Transaction to broadcast","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_15","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#get_3","text":"def get ( self , transaction_id ) Retrieve a Transaction","title":"get()"},{"location":"sdk/python/client/api-documentation/#parameters_13","text":"Type Name Required Description str transaction_id Yes Transaction ID","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_16","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#all_3","text":"def all ( self , page = None , limit = 100 , ** kwargs ) List All Transactions","title":"all()"},{"location":"sdk/python/client/api-documentation/#parameters_14","text":"Type Name Required Description int page No Pagination int limit No Result limit any **kwargs No Query parameters","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_17","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#all_unconfirmed","text":"def all_unconfirmed ( self , limit = 100 , offset = None , ** kwargs ) List All Unconfirmed Transactions","title":"all_unconfirmed()"},{"location":"sdk/python/client/api-documentation/#parameters_15","text":"Type Name Required Description int limit No Result limit int offset No Offset any **kwargs No Query parameters","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_18","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#get_unconfirmed","text":"def get_unconfirmed ( self , transaction_id ) Get Unconfirmed Transaction","title":"get_unconfirmed()"},{"location":"sdk/python/client/api-documentation/#parameters_16","text":"Type Name Required Description str transaction_id Yes Transaction ID","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_19","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#search_2","text":"def search ( self , criteria , page = None , limit = 100 ) Search Transactions","title":"search()"},{"location":"sdk/python/client/api-documentation/#parameters_17","text":"Type Name Required Description dict criteria Yes Search parameters int page No Pagination int limit No Result limit","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_20","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#types","text":"def types ( self ) List Transaction Types","title":"types()"},{"location":"sdk/python/client/api-documentation/#return-value_21","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#fees_1","text":"def fees ( self ) List Transaction Fees (Non-Dynamic)","title":"fees()"},{"location":"sdk/python/client/api-documentation/#return-value_22","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#clientapivotesvotes","text":"","title":"client.api.votes.Votes"},{"location":"sdk/python/client/api-documentation/#all_4","text":"def all ( self , page = None , limit = 100 ) List All Votes","title":"all()"},{"location":"sdk/python/client/api-documentation/#parameters_18","text":"Type Name Required Description s int page No Pagination int limit No Result limit","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_23","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#get_4","text":"def get ( self , vote_id ) Retrieve a Vote","title":"get()"},{"location":"sdk/python/client/api-documentation/#parameters_19","text":"Type Name Required Description str vote_id Yes Vote IDs","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_24","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#clientapiwalletswallets","text":"","title":"client.api.wallets.Wallets"},{"location":"sdk/python/client/api-documentation/#all_5","text":"def all ( self , page = None , limit = 100 ) Retrieve All Wallets","title":"all()"},{"location":"sdk/python/client/api-documentation/#parameters_20","text":"Type Name Required Description int page No Pagination int limit No Result limit","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_25","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#get_5","text":"def get ( self , wallet_id ) Retrieve a Wallet","title":"get()"},{"location":"sdk/python/client/api-documentation/#parameters_21","text":"Type Name Required Description str wallet_id Yes Wallet identifier","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_26","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#transactions_1","text":"def transactions ( self , wallet_id , page = None , limit = 100 , ** kwargs ) List All Transactions of a Wallet","title":"transactions()"},{"location":"sdk/python/client/api-documentation/#parameters_22","text":"Type Name Required Description str wallet_id Yes Wallet identifier int page No Pagination int limit No Result limit any **kwargs No Query parameters","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_27","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#transactions_received","text":"def transactions_received ( self , wallet_id , page = None , limit = 100 ) List All Received Transactions of a Wallet","title":"transactions_received()"},{"location":"sdk/python/client/api-documentation/#parameters_23","text":"Type Name Required Description str wallet_id Yes Wallet identifier int page No Pagination int limit No Result limit","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_28","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#transactions_sent","text":"def transactions_sent ( self , wallet_id , page = None , limit = 100 ) List All Sent Transactions of a Wallet","title":"transactions_sent()"},{"location":"sdk/python/client/api-documentation/#parameters_24","text":"Type Name Required Description str wallet_id Yes Wallet identifier int page No Pagination int limit No Result limit","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_29","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#votes","text":"def votes ( self , wallet_id , page = None , limit = 100 ) List All Votes of a Wallet","title":"votes()"},{"location":"sdk/python/client/api-documentation/#parameters_25","text":"Type Name Required Description str wallet_id Yes Wallet identifier int page No Pagination int limit No Result limit","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_30","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#top","text":"def top ( self , page = None , limit = 100 ) List All Top Wallets","title":"top()"},{"location":"sdk/python/client/api-documentation/#parameters_26","text":"Type Name Required Description int page No Pagination int limit No Result limit","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_31","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#search_3","text":"def search ( self , criteria , page = None , limit = 100 ) Search All Wallets","title":"search()"},{"location":"sdk/python/client/api-documentation/#parameters_27","text":"Type Name Required Description dict criteria Yes Search parameters int page No Pagination int limit No Result limit","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_32","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/examples/","text":"Examples \u00b6 Initialization \u00b6 from client import SolarClient client = SolarClient ( 'https://node.ip.address:port/api' ) Blocks \u00b6 This service API grants access to the blocks resource . A block is a signed set of transactions created by a delegate and permanently committed to the SXP blockchain. It is not possible to POST a block through the public API. Relay Nodes accept only blocks posted by a delegate at the correct time through the internal API. List All Blocks \u00b6 blocks = client . blocks . all () # With parameters blocks = client . blocks . all ( page = 5 , limit = 10 , { \"orderBy\" : \"height\" }) # Available extra_parameters : # orderBy, ... print ( blocks ) >>> { 'meta' : { 'count' : 10 , ... }} Retrieve a Block \u00b6 block = client . blocks . get ( 'validBlockId' ) print ( block ) >>> { 'data' : { 'id' : 'validBlockId' ... }} List All Transactions of a Block \u00b6 block_transactions = client . blocks . transactions ( 'validBlockId' ) # With parameters block_transactions = client . blocks . transactions ( 'validBlockId' , page = 5 , limit = 10 ) print ( block_transactions ) >>> { 'meta' : { 'count' : 10 , ... }} Search All Blocks \u00b6 searched_blocks = client . blocks . search ({ \"generatorPublicKey\" : \"validPublicKey\" }) # With parameters searched_blocks = client . blocks . search ({ \"generatorPublicKey\" : \"validPublicKey\" }, page = 5 , limit = 10 ) # Available keys : # generatorPublicKey, ... print ( searched_blocks ) >>> { 'meta' : { 'count' : 100 , ... }} Delegates \u00b6 The client SDK can be used to query the delegate resource . A delegate is a regular wallet that has broadcast a registration transaction, acquired a sufficient number of votes, and has a Relay Node configured to forge new blocks through a forger module. At any time only 51 delegates are active. They are cost-efficient miners running the SXP network. Voters are wallets which have broadcast a vote transaction on a delegate. A vote remains active until an un-vote transaction is sent (it does not have to be recast unless a wallet wishes to change from delegate). Voting for a delegate does not give the delegate access to the wallet nor does it lock the coins in it. List All Delegates \u00b6 delegates = client . delegates . all () # With parameters delegates = client . delegates . all ( page = 5 , limit = 20 , { \"orderBy\" : \"production\" ) # Available extra_parameters : # orderBy, ... print ( delegates ) >>> { 'meta' : { 'count' : 20 , ... }} Retrieve a Delegate \u00b6 delegate = client . delegates . get ( \"delegateName\" ) print ( delegate ) >>> { 'data' : { 'username' : 'delegateName' , ... }} Search Delegates \u00b6 searched_delegates = client . delegates . search ( \"delegateName\" ) # With parameters searched_delegates = client . delegates . search ( \"delegateName\" , page = 1 , limit = 5 ) print ( searched_delegates ) >>> { 'meta' : { 'count' : 1 , ... }} List All Blocks of a Delegate \u00b6 delegate_blocks = client . delegates . blocks ( \"delegateName\" ) # With parameters delegate_blocks = client . delegates . blocks ( \"delegateName\" , page = 1 , limit = 20 ) print ( delegate_blocks ) >>> { 'meta' : { 'count' : 20 , ... }} List All Voters of a Delegate \u00b6 delegate_voters = client . delegates . voters ( \"delegateName\" ) # With parameters delegate_voters = client . delegates . voters ( \"delegateName\" , page = 1 , limit = 10 ) print ( delegate_voters ) >>> { 'meta' : { 'count' : 10 , ... }} Node \u00b6 The SXP network consists of different anonymous nodes (servers), maintaining the public ledger, validating transactions and blocks and providing APIs. The node resource allows for querying the health and configurations of the node used by the instantiated client. Retrieve the Configuration \u00b6 configuration = client . node . configuration () print ( configuration ) >>> { 'data' : { 'nethash' : '6e84d08bd299ed97c212c886c98a57e36545c8f5d645ca7eeae63a8bd62d8988' , ... }} Retrieve the Status \u00b6 status = client . node . status () print ( status ) >>> { 'data' : { 'synced' : True , 'now' : 6897158 , 'blocksCount' : - 1 }} Retrieve the Syncing Status \u00b6 syncing_status = client . node . syncing () print ( syncing_status ) >>> { 'data' : { 'syncing' : False , 'blocks' : - 1 , 'height' : 6897160 , 'id' : '12905037940821862953' }} Retrieve the Node Fees \u00b6 fees = client . node . fees () print ( fees ) >>> { \"meta\" :{ \"days\" : 7 , ... }} Peers \u00b6 Each node is connected to a set of peers, which are Relay or Delegate Nodes as well. The peers resource provides access to all peers connected to our node. Peers have made their Public API available for use; however for mission-critical queries and transaction posting you should use a node which is under your control. We provide a guide to setting up a Relay Node here . List All Peers \u00b6 peers = client . peers . all () # With parameters peers = client . peers . all ( os = \"\" , status = \"\" , port = 6002 , version = \"\" , orderBy = \"latency\" , page = 1 , limit = 10 ) print ( peers ) >>> { 'meta' : { 'count' : 10 , ... }} Retrieve a Peer \u00b6 peer = client . peers . get ( \"peerIpAddress\" ) print ( peer ) >>> { 'data' : { 'count' : 20 , ... }} # Need to changes Transactions \u00b6 The heart of any blockchain is formed by its transactions; state-altering payloads signed by a wallet. Most likely you will be querying for transactions most often, using the transaction resource . A transaction is the only object which may be posted by a non-delegate. It requires a signature from a wallet containing a sufficient amount of SXP. Create a Transaction \u00b6 transaction = client . transactions . create ([ signed_transaction ]) print ( transaction ) >>> < class ' dict '> # Need to update Retrieve a Transaction \u00b6 transaction = client . transactions . get ( \"validTransactionId\" ) print ( transaction ) >>> < class ' dict '> # Need to update List All Transactions \u00b6 transactions = client . transactions . all () # With parameters transactions = client . transactions . all ( page = 1 , limit = 10 , { \"orderBy\" : \"amount\" }) # Available extra_parameters : # orderBy, ... >>> { 'meta' : { 'count' : 10 , ... }} List All Unconfirmed Transactions \u00b6 unconfirmed_transactions = client . transactions . all_unconfirmed () # With parameters unconfirmed_transactions = client . transactions . all_unconfirmed ( page = 1 , limit = 10 , { \"orderBy\" : \"amount\" }) # Available extra_parameters : # orderBy, ... print ( unconfirmed_transactions ) >>> { 'meta' : { 'count' : 10 , ... }} Get Unconfirmed Transaction \u00b6 unconfirmed_transaction = client . transactions . get_unconfirmed ( \"validTransactionId\" ) print ( unconfirmed_transaction ) >>> < class ' dict '> # Need to update Search Transactions \u00b6 transactions = client . transactions . search ({ \"senderId\" : \"validPublicKey\" }) transactions = client . transactions . search ({ \"senderId\" : \"validPublicKey\" }, page = 1 , limit = 10 ) # Available keys : # senderId, ... print ( transactions ) >>> { 'meta' : { 'count' : 10 , ... }} List Transaction Types \u00b6 types = client . transactions . types () print ( types ) >>> { \"data\" :{ ... }} List Transaction Fees (Non-Dynamic) \u00b6 fees = client . transactions . fees () >>> { \"data\" :{ ... }} Votes \u00b6 A vote is a transaction sub-type, where the asset field contains a votes object and the transaction.type is 3 . List All Votes \u00b6 votes = client . votes . all () # With parameters votes = client . votes . all ( page = 1 , limit = 10 ) print ( votes ) >>> { 'meta' : { 'count' : 10 , ... }} Retrieve a Vote \u00b6 vote = client . votes . get ( 'validVoteId' ) print ( vote ) >>> { 'data' : { ... }} Wallets \u00b6 The wallet resource provides access to: Wallets. Incoming and outgoing transactions per wallet. Each wallet's votes. Retrieve All Wallets \u00b6 wallets = client . wallets . all () # With parameters wallets = client . wallets . all ( page = 1 , limit = 10 ) print ( wallets ) >>> { 'meta' : { 'count' : 10 , ... }} Retrieve a Wallet \u00b6 wallet = client . wallets . get ( 'validWalletId' ) print ( wallet ) >>> { 'data' : { 'id' : 'validWalletId' ... }} List All Transactions of a Wallet \u00b6 wallet_transactions = client . wallets . transactions ( 'validWalletId' ) wallet_transactions = client . wallets . transactions ( 'validWalletId' , page = 1 , limit = 10 , { \"orderBy\" : \"amount\" }) # Available extra_parameters : # orderBy, ... print ( wallet_transactions ) >>> { 'meta' : { 'count' : 10 , ... }} List All Received Transactions of a Wallet \u00b6 received_transactions = client . wallets . transactions_received ( 'validWalletId' ) # With parameters received_transactions = client . wallets . transactions_received ( 'validWalletId' , page = 1 , limit = 10 , { \"orderBy\" : \"amount\" }) # Available extra_parameters : # orderBy, ... print ( received_transactions ) >>> { 'meta' : { 'count' : 10 , ... }} List All Sent Transactions of a Wallet \u00b6 sent_transactions = client . wallets . transactions_sent ( 'validWalletId' ) # With parameters sent_transactions = client . wallets . transactions_sent ( 'validWalletId' , page = 1 , limit = 10 , { \"orderBy\" : \"amount\" }) # Available extra_parameters : # orderBy, ... print ( sent_transactions ) >>> { 'meta' : { 'count' : 10 , ... }} List All Votes of a Wallet \u00b6 wallet_votes = client . wallets . votes ( 'validWalletId' ) # With parameters wallet_votes = client . wallets . votes ( 'validWalletId' , page = 1 , limit = 10 ) print ( wallet_votes ) >>> { 'meta' : { 'count' : 10 , ... }} List All Top Wallets \u00b6 top_wallets = client . wallets . top () # With parameters top_wallets = client . wallets . top ( page = 1 , limit = 10 ) print ( top_wallets ) >>> { 'meta' : { 'count' : 10 , ... }} Search All Wallets \u00b6 wallets = client . wallets . search ({ \"publicKey\" : \"validPublicKey\" }) # With parameters wallets = client . wallets . search ({ \"publicKey\" : \"validPublicKey\" }, page = 1 , limit = 10 ) # Available keys : # publicKey, ... print ( wallets ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"Examples"},{"location":"sdk/python/client/examples/#examples","text":"","title":"Examples"},{"location":"sdk/python/client/examples/#initialization","text":"from client import SolarClient client = SolarClient ( 'https://node.ip.address:port/api' )","title":"Initialization"},{"location":"sdk/python/client/examples/#blocks","text":"This service API grants access to the blocks resource . A block is a signed set of transactions created by a delegate and permanently committed to the SXP blockchain. It is not possible to POST a block through the public API. Relay Nodes accept only blocks posted by a delegate at the correct time through the internal API.","title":"Blocks"},{"location":"sdk/python/client/examples/#list-all-blocks","text":"blocks = client . blocks . all () # With parameters blocks = client . blocks . all ( page = 5 , limit = 10 , { \"orderBy\" : \"height\" }) # Available extra_parameters : # orderBy, ... print ( blocks ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"List All Blocks"},{"location":"sdk/python/client/examples/#retrieve-a-block","text":"block = client . blocks . get ( 'validBlockId' ) print ( block ) >>> { 'data' : { 'id' : 'validBlockId' ... }}","title":"Retrieve a Block"},{"location":"sdk/python/client/examples/#list-all-transactions-of-a-block","text":"block_transactions = client . blocks . transactions ( 'validBlockId' ) # With parameters block_transactions = client . blocks . transactions ( 'validBlockId' , page = 5 , limit = 10 ) print ( block_transactions ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"List All Transactions of a Block"},{"location":"sdk/python/client/examples/#search-all-blocks","text":"searched_blocks = client . blocks . search ({ \"generatorPublicKey\" : \"validPublicKey\" }) # With parameters searched_blocks = client . blocks . search ({ \"generatorPublicKey\" : \"validPublicKey\" }, page = 5 , limit = 10 ) # Available keys : # generatorPublicKey, ... print ( searched_blocks ) >>> { 'meta' : { 'count' : 100 , ... }}","title":"Search All Blocks"},{"location":"sdk/python/client/examples/#delegates","text":"The client SDK can be used to query the delegate resource . A delegate is a regular wallet that has broadcast a registration transaction, acquired a sufficient number of votes, and has a Relay Node configured to forge new blocks through a forger module. At any time only 51 delegates are active. They are cost-efficient miners running the SXP network. Voters are wallets which have broadcast a vote transaction on a delegate. A vote remains active until an un-vote transaction is sent (it does not have to be recast unless a wallet wishes to change from delegate). Voting for a delegate does not give the delegate access to the wallet nor does it lock the coins in it.","title":"Delegates"},{"location":"sdk/python/client/examples/#list-all-delegates","text":"delegates = client . delegates . all () # With parameters delegates = client . delegates . all ( page = 5 , limit = 20 , { \"orderBy\" : \"production\" ) # Available extra_parameters : # orderBy, ... print ( delegates ) >>> { 'meta' : { 'count' : 20 , ... }}","title":"List All Delegates"},{"location":"sdk/python/client/examples/#retrieve-a-delegate","text":"delegate = client . delegates . get ( \"delegateName\" ) print ( delegate ) >>> { 'data' : { 'username' : 'delegateName' , ... }}","title":"Retrieve a Delegate"},{"location":"sdk/python/client/examples/#search-delegates","text":"searched_delegates = client . delegates . search ( \"delegateName\" ) # With parameters searched_delegates = client . delegates . search ( \"delegateName\" , page = 1 , limit = 5 ) print ( searched_delegates ) >>> { 'meta' : { 'count' : 1 , ... }}","title":"Search Delegates"},{"location":"sdk/python/client/examples/#list-all-blocks-of-a-delegate","text":"delegate_blocks = client . delegates . blocks ( \"delegateName\" ) # With parameters delegate_blocks = client . delegates . blocks ( \"delegateName\" , page = 1 , limit = 20 ) print ( delegate_blocks ) >>> { 'meta' : { 'count' : 20 , ... }}","title":"List All Blocks of a Delegate"},{"location":"sdk/python/client/examples/#list-all-voters-of-a-delegate","text":"delegate_voters = client . delegates . voters ( \"delegateName\" ) # With parameters delegate_voters = client . delegates . voters ( \"delegateName\" , page = 1 , limit = 10 ) print ( delegate_voters ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"List All Voters of a Delegate"},{"location":"sdk/python/client/examples/#node","text":"The SXP network consists of different anonymous nodes (servers), maintaining the public ledger, validating transactions and blocks and providing APIs. The node resource allows for querying the health and configurations of the node used by the instantiated client.","title":"Node"},{"location":"sdk/python/client/examples/#retrieve-the-configuration","text":"configuration = client . node . configuration () print ( configuration ) >>> { 'data' : { 'nethash' : '6e84d08bd299ed97c212c886c98a57e36545c8f5d645ca7eeae63a8bd62d8988' , ... }}","title":"Retrieve the Configuration"},{"location":"sdk/python/client/examples/#retrieve-the-status","text":"status = client . node . status () print ( status ) >>> { 'data' : { 'synced' : True , 'now' : 6897158 , 'blocksCount' : - 1 }}","title":"Retrieve the Status"},{"location":"sdk/python/client/examples/#retrieve-the-syncing-status","text":"syncing_status = client . node . syncing () print ( syncing_status ) >>> { 'data' : { 'syncing' : False , 'blocks' : - 1 , 'height' : 6897160 , 'id' : '12905037940821862953' }}","title":"Retrieve the Syncing Status"},{"location":"sdk/python/client/examples/#retrieve-the-node-fees","text":"fees = client . node . fees () print ( fees ) >>> { \"meta\" :{ \"days\" : 7 , ... }}","title":"Retrieve the Node Fees"},{"location":"sdk/python/client/examples/#peers","text":"Each node is connected to a set of peers, which are Relay or Delegate Nodes as well. The peers resource provides access to all peers connected to our node. Peers have made their Public API available for use; however for mission-critical queries and transaction posting you should use a node which is under your control. We provide a guide to setting up a Relay Node here .","title":"Peers"},{"location":"sdk/python/client/examples/#list-all-peers","text":"peers = client . peers . all () # With parameters peers = client . peers . all ( os = \"\" , status = \"\" , port = 6002 , version = \"\" , orderBy = \"latency\" , page = 1 , limit = 10 ) print ( peers ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"List All Peers"},{"location":"sdk/python/client/examples/#retrieve-a-peer","text":"peer = client . peers . get ( \"peerIpAddress\" ) print ( peer ) >>> { 'data' : { 'count' : 20 , ... }} # Need to changes","title":"Retrieve a Peer"},{"location":"sdk/python/client/examples/#transactions","text":"The heart of any blockchain is formed by its transactions; state-altering payloads signed by a wallet. Most likely you will be querying for transactions most often, using the transaction resource . A transaction is the only object which may be posted by a non-delegate. It requires a signature from a wallet containing a sufficient amount of SXP.","title":"Transactions"},{"location":"sdk/python/client/examples/#create-a-transaction","text":"transaction = client . transactions . create ([ signed_transaction ]) print ( transaction ) >>> < class ' dict '> # Need to update","title":"Create a Transaction"},{"location":"sdk/python/client/examples/#retrieve-a-transaction","text":"transaction = client . transactions . get ( \"validTransactionId\" ) print ( transaction ) >>> < class ' dict '> # Need to update","title":"Retrieve a Transaction"},{"location":"sdk/python/client/examples/#list-all-transactions","text":"transactions = client . transactions . all () # With parameters transactions = client . transactions . all ( page = 1 , limit = 10 , { \"orderBy\" : \"amount\" }) # Available extra_parameters : # orderBy, ... >>> { 'meta' : { 'count' : 10 , ... }}","title":"List All Transactions"},{"location":"sdk/python/client/examples/#list-all-unconfirmed-transactions","text":"unconfirmed_transactions = client . transactions . all_unconfirmed () # With parameters unconfirmed_transactions = client . transactions . all_unconfirmed ( page = 1 , limit = 10 , { \"orderBy\" : \"amount\" }) # Available extra_parameters : # orderBy, ... print ( unconfirmed_transactions ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"List All Unconfirmed Transactions"},{"location":"sdk/python/client/examples/#get-unconfirmed-transaction","text":"unconfirmed_transaction = client . transactions . get_unconfirmed ( \"validTransactionId\" ) print ( unconfirmed_transaction ) >>> < class ' dict '> # Need to update","title":"Get Unconfirmed Transaction"},{"location":"sdk/python/client/examples/#search-transactions","text":"transactions = client . transactions . search ({ \"senderId\" : \"validPublicKey\" }) transactions = client . transactions . search ({ \"senderId\" : \"validPublicKey\" }, page = 1 , limit = 10 ) # Available keys : # senderId, ... print ( transactions ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"Search Transactions"},{"location":"sdk/python/client/examples/#list-transaction-types","text":"types = client . transactions . types () print ( types ) >>> { \"data\" :{ ... }}","title":"List Transaction Types"},{"location":"sdk/python/client/examples/#list-transaction-fees-non-dynamic","text":"fees = client . transactions . fees () >>> { \"data\" :{ ... }}","title":"List Transaction Fees (Non-Dynamic)"},{"location":"sdk/python/client/examples/#votes","text":"A vote is a transaction sub-type, where the asset field contains a votes object and the transaction.type is 3 .","title":"Votes"},{"location":"sdk/python/client/examples/#list-all-votes","text":"votes = client . votes . all () # With parameters votes = client . votes . all ( page = 1 , limit = 10 ) print ( votes ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"List All Votes"},{"location":"sdk/python/client/examples/#retrieve-a-vote","text":"vote = client . votes . get ( 'validVoteId' ) print ( vote ) >>> { 'data' : { ... }}","title":"Retrieve a Vote"},{"location":"sdk/python/client/examples/#wallets","text":"The wallet resource provides access to: Wallets. Incoming and outgoing transactions per wallet. Each wallet's votes.","title":"Wallets"},{"location":"sdk/python/client/examples/#retrieve-all-wallets","text":"wallets = client . wallets . all () # With parameters wallets = client . wallets . all ( page = 1 , limit = 10 ) print ( wallets ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"Retrieve All Wallets"},{"location":"sdk/python/client/examples/#retrieve-a-wallet","text":"wallet = client . wallets . get ( 'validWalletId' ) print ( wallet ) >>> { 'data' : { 'id' : 'validWalletId' ... }}","title":"Retrieve a Wallet"},{"location":"sdk/python/client/examples/#list-all-transactions-of-a-wallet","text":"wallet_transactions = client . wallets . transactions ( 'validWalletId' ) wallet_transactions = client . wallets . transactions ( 'validWalletId' , page = 1 , limit = 10 , { \"orderBy\" : \"amount\" }) # Available extra_parameters : # orderBy, ... print ( wallet_transactions ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"List All Transactions of a Wallet"},{"location":"sdk/python/client/examples/#list-all-received-transactions-of-a-wallet","text":"received_transactions = client . wallets . transactions_received ( 'validWalletId' ) # With parameters received_transactions = client . wallets . transactions_received ( 'validWalletId' , page = 1 , limit = 10 , { \"orderBy\" : \"amount\" }) # Available extra_parameters : # orderBy, ... print ( received_transactions ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"List All Received Transactions of a Wallet"},{"location":"sdk/python/client/examples/#list-all-sent-transactions-of-a-wallet","text":"sent_transactions = client . wallets . transactions_sent ( 'validWalletId' ) # With parameters sent_transactions = client . wallets . transactions_sent ( 'validWalletId' , page = 1 , limit = 10 , { \"orderBy\" : \"amount\" }) # Available extra_parameters : # orderBy, ... print ( sent_transactions ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"List All Sent Transactions of a Wallet"},{"location":"sdk/python/client/examples/#list-all-votes-of-a-wallet","text":"wallet_votes = client . wallets . votes ( 'validWalletId' ) # With parameters wallet_votes = client . wallets . votes ( 'validWalletId' , page = 1 , limit = 10 ) print ( wallet_votes ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"List All Votes of a Wallet"},{"location":"sdk/python/client/examples/#list-all-top-wallets","text":"top_wallets = client . wallets . top () # With parameters top_wallets = client . wallets . top ( page = 1 , limit = 10 ) print ( top_wallets ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"List All Top Wallets"},{"location":"sdk/python/client/examples/#search-all-wallets","text":"wallets = client . wallets . search ({ \"publicKey\" : \"validPublicKey\" }) # With parameters wallets = client . wallets . search ({ \"publicKey\" : \"validPublicKey\" }, page = 1 , limit = 10 ) # Available keys : # publicKey, ... print ( wallets ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"Search All Wallets"},{"location":"sdk/python/client/getting-started/","text":"Python installation \u00b6 Python can be downloaded here . For further information on how to install Python on your operating system : Windows guide Unix guide OSx guide On OSx you can also install Python through HomeBrew , which would also install pip along, to do so, you need to install HomeBrew and then run the following command : brew install python3 pip \u00b6 pip is the standard package manager for Python. It allows you to install and manage additional packages that are not part of the Python standard library. Install pip \u00b6 On Windows \u00b6 Download get-pip.py Open your terminal ( powershell , cmd , ...) and navigate to the folder containing get-pip.py Run the following command : python get-pip.py Pip is now installed On Unix \u00b6 Debian / Ubuntu : sudo apt install python3-pip CentOS / Rhel : sudo yum install epel-release sudo yum install python-pip Fedora : sudo dnf install python3 Arch Linux : sudo pacman -S python-pip openSUSE : sudo zypper install python3-pip On macOS : Download get-pip.py and then run it curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py python get-pip.py With Brew : brew install python3 You can verify that pip was installed properly by running the following command in your terminal : pip -V which should returns the version of the installed pip program. Development \u00b6 Fork the package . Clone your forked repository. git clone https://github.com/<githubusername>/python-client Next, move into the fresh cloned directory. cd python-client The next step would be to create something like a virtual environment to ensure no name clashes occur. Create and enter the virtual environment # With virtualenv (on Unix and OSx) mkdir my-amazing-solar-project cd my-amazing-solar-project virtualenv virtualEnvName source venv/bin/activate # With virtualenv (on Windows) mkdir my-amazing-solar-project cd my-amazing-solar-project virtualenv virtualEnvName . \\v env \\S cripts \\a ctivate.bat Once inside the virtualenv, you can proceed to install the dependencies. These are listed inside the setup.py file. pip install \\ requests \\ backoff \\ flake8 \\ flake8-import-order \\ flake8-print \\ flake8-quotes \\ pytest \\ pytest-responses \\ pytest-mock \\ pytest-cov Dependencies are now installed, you can now run the tests to see if everything is running as it should. pytest","title":"Getting Started"},{"location":"sdk/python/client/getting-started/#python-installation","text":"Python can be downloaded here . For further information on how to install Python on your operating system : Windows guide Unix guide OSx guide On OSx you can also install Python through HomeBrew , which would also install pip along, to do so, you need to install HomeBrew and then run the following command : brew install python3","title":"Python installation"},{"location":"sdk/python/client/getting-started/#pip","text":"pip is the standard package manager for Python. It allows you to install and manage additional packages that are not part of the Python standard library.","title":"pip"},{"location":"sdk/python/client/getting-started/#install-pip","text":"","title":"Install pip"},{"location":"sdk/python/client/getting-started/#on-windows","text":"Download get-pip.py Open your terminal ( powershell , cmd , ...) and navigate to the folder containing get-pip.py Run the following command : python get-pip.py Pip is now installed","title":"On Windows"},{"location":"sdk/python/client/getting-started/#on-unix","text":"Debian / Ubuntu : sudo apt install python3-pip CentOS / Rhel : sudo yum install epel-release sudo yum install python-pip Fedora : sudo dnf install python3 Arch Linux : sudo pacman -S python-pip openSUSE : sudo zypper install python3-pip On macOS : Download get-pip.py and then run it curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py python get-pip.py With Brew : brew install python3 You can verify that pip was installed properly by running the following command in your terminal : pip -V which should returns the version of the installed pip program.","title":"On Unix"},{"location":"sdk/python/client/getting-started/#development","text":"Fork the package . Clone your forked repository. git clone https://github.com/<githubusername>/python-client Next, move into the fresh cloned directory. cd python-client The next step would be to create something like a virtual environment to ensure no name clashes occur. Create and enter the virtual environment # With virtualenv (on Unix and OSx) mkdir my-amazing-solar-project cd my-amazing-solar-project virtualenv virtualEnvName source venv/bin/activate # With virtualenv (on Windows) mkdir my-amazing-solar-project cd my-amazing-solar-project virtualenv virtualEnvName . \\v env \\S cripts \\a ctivate.bat Once inside the virtualenv, you can proceed to install the dependencies. These are listed inside the setup.py file. pip install \\ requests \\ backoff \\ flake8 \\ flake8-import-order \\ flake8-print \\ flake8-quotes \\ pytest \\ pytest-responses \\ pytest-mock \\ pytest-cov Dependencies are now installed, you can now run the tests to see if everything is running as it should. pytest","title":"Development"},{"location":"sdk/python/client/intro/","text":"Client \u00b6 Development \u00b6 Fork the package . Clone your forked repository. git clone https://github.com/<githubusername>/python-client Next, move into the fresh cloned directory. cd python-client The next step would be to create something like a virtual environment to ensure no name clashes occur. Create and enter the virtual environment # With virtualenv (on Unix and OSx) mkdir my-amazing-solar-project cd my-amazing-solar-project virtualenv virtualEnvName source venv/bin/activate # With virtualenv (on Windows) mkdir my-amazing-solar-project cd my-amazing-solar-project virtualenv virtualEnvName . \\v env \\S cripts \\a ctivate.bat Once inside the virtualenv, you can proceed to install dependencies. python -m pip install -e . \"[dev]\" Dependencies are now installed, you can now run the tests to see if everything is running as it should. pytest","title":"Getting Started"},{"location":"sdk/python/client/intro/#client","text":"","title":"Client"},{"location":"sdk/python/client/intro/#development","text":"Fork the package . Clone your forked repository. git clone https://github.com/<githubusername>/python-client Next, move into the fresh cloned directory. cd python-client The next step would be to create something like a virtual environment to ensure no name clashes occur. Create and enter the virtual environment # With virtualenv (on Unix and OSx) mkdir my-amazing-solar-project cd my-amazing-solar-project virtualenv virtualEnvName source venv/bin/activate # With virtualenv (on Windows) mkdir my-amazing-solar-project cd my-amazing-solar-project virtualenv virtualEnvName . \\v env \\S cripts \\a ctivate.bat Once inside the virtualenv, you can proceed to install dependencies. python -m pip install -e . \"[dev]\" Dependencies are now installed, you can now run the tests to see if everything is running as it should. pytest","title":"Development"},{"location":"sdk/python/crypto/api-documentation/","text":"API Documentation \u00b6 crypto.configuration.fee \u00b6 get_fee() \u00b6 def get_fee ( transaction_type , type_group ): Get a fee for a given transaction type Parameters \u00b6 Type Name Required Description int transaction_type Yes Transaction type for which we wish to get a fee int type_group Yes transaction type group (TRANSACTION_TYPE_GROUP(Enum)) Return Value \u00b6 <class 'int'> set_fee() \u00b6 def set_fee ( transaction_type , type_group , value ): Set a fee Parameters \u00b6 Type Name Required Description int transaction_type Yes Transaction type for which we wish to set a fee int type_group Yes transaction type group (TRANSACTION_TYPE_GROUP(Enum)) int value Yes Fee for a given transaction type Return Value \u00b6 <class 'NoneType'> crypto.configuration.network \u00b6 set_network() \u00b6 def set_network ( network_object ): Set what network you want to use in the crypto library Parameters \u00b6 Type Name Required Description Network network_object Yes Testnet, Mainnet Return Value \u00b6 <class 'NoneType'> get_network() \u00b6 def get_network (): Get settings for a selected network, default network is Testnet Return Value \u00b6 <class 'dict'> set_custom_network() \u00b6 def set_custom_network ( epoch , version , wif ): Set custom network Parameters \u00b6 Type Name Required Description datetime epoch Yes Network epoch time int version Yes Network version int wif Yes Network WIF Return Value \u00b6 <class 'NoneType'> get_network_version() \u00b6 def get_network_version (): Get currently set network version Return Value \u00b6 <class 'Network'> crypto.identity.address \u00b6 address_from_public_key() \u00b6 def address_from_public_key ( public_key , network_version = None ): Get an address from a public key Parameters \u00b6 Type Name Required Description str public_key Yes Public key int network_version No Version of the network Return Value \u00b6 <class 'str'> address_from_private_key() \u00b6 def address_from_private_key ( private_key , network_version = None ): Get an address from private key Parameters \u00b6 Type Name Required Description str private_key Yes Private key int network_version No Version of the network Return Value \u00b6 <class 'str'> address_from_passphrase() \u00b6 def address_from_passphrase ( passphrase , network_version = None ): Get an address from passphrase Parameters \u00b6 Type Name Required Description str passphrase Yes Passphrase int network_version No Version of the network Return Value \u00b6 <class 'str'> validate_address() \u00b6 def validate_address ( address , network_version = None ): Validate a given address Parameters \u00b6 Type Name Required Description str address Yes Address to validate int network_version No Version of the network Return Value \u00b6 <class 'bool'> crypto.identity.private_key.PrivateKey \u00b6 __init__() \u00b6 def __init__ ( self , private_key ): Create a new PrivateKey instance Parameters \u00b6 Type Name Required Description str private_key Yes Hex private key Return Value \u00b6 <class 'solar_crypto.identity.private_key.PrivateKey'> sign() \u00b6 def sign ( self , message , nonce = None ): Sign a message with this private key object Parameters \u00b6 Type Name Required Description str message Yes Bytes data you want to sign int nonce No Deterministic nonce Return Value \u00b6 <class 'str'> to_hex() \u00b6 def to_hex ( self ): Returns a private key in hex format Return Value \u00b6 <class 'str'> from_passphrase() \u00b6 def from_passphrase ( cls , passphrase ): Create PrivateKey object from a given passphrase Parameters \u00b6 Type Name Required Description str passphrase Yes Passphrase Return Value \u00b6 <class 'PrivateKey'> from_hex() \u00b6 def from_hex ( cls , private_key ): Create PrivateKey object from a given hex private key Parameters \u00b6 Type Name Required Description str private_key Yes Private key Return Value \u00b6 <class 'PrivateKey'> crypto.identity.public_key.PublicKey \u00b6 to_hex() \u00b6 def to_hex ( self ): Returns a public key in hex format Return Value \u00b6 <class 'str'> from_passphrase() \u00b6 def from_passphrase ( cls , passphrase ): Create PublicKey object from a given passphrase Parameters \u00b6 Type Name Required Description str passphrase Yes Passphrase Return Value \u00b6 <class 'PublicKey'> from_hex() \u00b6 def from_hex ( cls , public_key ): Create PublicKey object from a given hex private key Parameters \u00b6 Type Name Required Description str public_key Yes Public key Return Value \u00b6 <class 'PublicKey'> crypto.identity.wif \u00b6 wif_from_passphrase() \u00b6 def wif_from_passphrase ( passphrase , network_wif = None ): Get wif from passphrase Parameters \u00b6 Type Name Required Description str passphrase Yes Passphrase int network_wif No Network WIF Return Value \u00b6 <class 'str'> crypto.transactions.builder.base.BaseTransactionBuilder \u00b6 to_dict() \u00b6 def to_dict ( self ): Convert the transaction to its dictionary representation. Return Value \u00b6 <class 'dict'> to_json() \u00b6 def to_json ( self ): Convert the transaction to its JSON representation Return Value \u00b6 <class 'dict'> sign() \u00b6 def sign ( self , passphrase ): Sign the transaction using the given passphrase Parameters \u00b6 Type Name Required Description str passphrase Yes Passphrase associated with the account sending this transaction Return Value \u00b6 <class 'NoneType'> second_sign() \u00b6 def second_sign ( self , passphrase ): Sign the transaction using the given second passphrase Parameters \u00b6 Type Name Required Description str passphrase Yes Second passphrase associated with the account sending this transaction Return Value \u00b6 <class 'NoneType'> multi_sign() \u00b6 def multi_sign ( self , passphrase , index ): Sign the transaction using the given passphrase. A signature will be generated inside the signatures array of the transaction at the specified index. Parameters \u00b6 Type Name Required Description str passphrase Yes Passphrase associated with the account sending this transaction int index Yes Index of the signature for the signatures array. Starts at 0. Return Value \u00b6 <class 'NoneType'> verify() \u00b6 def verify ( self ): Verify the transaction validity Return Value \u00b6 <class 'bool'> verify_multisig() \u00b6 def verify_multisig ( self ): Verify the multisignature transaction validity Return Value \u00b6 <class 'bool'> set_nonce() \u00b6 def set_nonce ( self , nonce ): Set the nonce of the transaction. Parameters \u00b6 Type Name Required Description int nonce Yes Sequential Nonce of the transaction Return Value \u00b6 <class 'NoneType'> set_fee() \u00b6 def set_fee ( self , fee : int ): Set a fee Parameters \u00b6 Type Name Required Description int fee Yes Transaction fee Return Value \u00b6 <class 'NoneType'> set_amount() \u00b6 def set_amount ( self , amount ): Set the amount of the transaction. Parameters \u00b6 Type Name Required Description int amount Yes Amount of the transaction Return Value \u00b6 <class 'NoneType'> set_sender_public_key() \u00b6 def set_sender_public_key ( self , public_key ): Set the Public Key of the transaction. Parameters \u00b6 Type Name Required Description str public_key Yes Public key of the transaction Return Value \u00b6 <class 'NoneType'> set_expiration() \u00b6 def set_expiration ( self , expiration ): Set the block-height or time when the transaction should expire. Parameters \u00b6 Type Name Required Description int, HTLC_LOCK_EXPIRATION_TYPE expiration Yes Expiration of the transaction Return Value \u00b6 <class 'NoneType'> set_type_group() \u00b6 def set_type_group ( self , type_group ): Set the type group of the transaction. Parameters \u00b6 Type Name Required Description int, TRANSACTION_TYPE_GROUP type_group Yes Type group of the transaction Return Value \u00b6 <class 'NoneType'> crypto.transactions.builder.burn.Burn \u00b6 __init__() \u00b6 def __init__ ( self , amount ): Create a new Burn transaction instance Parameters \u00b6 Type Name Required Description int amount Yes Burn amount Return Value \u00b6 <class 'solar_crypto.transactions.builder.burn.Burn'> crypto.transactions.builder.delegate_registration.DelegateRegistration \u00b6 __init__() \u00b6 def __init__ ( self , username , fee = None ): Create a new DelegateRegistration transaction instance Parameters \u00b6 Type Name Required Description str username Yes Delegate username int fee No Transaction fee Return Value \u00b6 <class 'solar_crypto.transactions.builder.delegate_registration.DelegateRegistration'> sign() \u00b6 def sign ( self , passphrase ): Sign the transaction using the given passphrase Parameters \u00b6 Type Name Required Description str passphrase Yes Passphrase Return Value \u00b6 <class 'NoneType'> crypto.transactions.builder.delegate_resignation.DelegateResignation \u00b6 __init__() \u00b6 def __init__ ( self , fee = None ): Create a new DelegateResignation transaction instance Parameters \u00b6 Type Name Required Description int fee No Transaction fee Return Value \u00b6 <class 'solar_crypto.transactions.builder.delegate_resignation.DelegateResignation'> get_type_group() \u00b6 def get_type_group ( self ): Get the type group of the Transaction. Return Value \u00b6 <class 'int'> crypto.transactions.builder.htlc_claim.HtlcClaim \u00b6 __init__() \u00b6 def __init__ ( self , lock_transaction_id , unlock_secret , hash_type : HashingType = HashingType . SHA256 , fee = None ): Create a new HtlcClaim transaction instance Parameters \u00b6 Type Name Required Description str lock_transaction_id Yes HTLC Lock transaction id str unlock_secret Yes Transaction secret hash HashingType hash_type No Hashing algorithm int fee No Transaction fee Return Value \u00b6 <class 'solar_crypto.transactions.builder.htlc_claim.HtlcClaim'> get_type_group() \u00b6 def get_type_group ( self ): Get the type group of the Transaction. Return Value \u00b6 <class 'int'> crypto.transactions.builder.htlc_lock.HtlcLock \u00b6 __init__() \u00b6 def __init__ ( self , recipient_id , amount , secret_hash , expiration_type , expiration_value , memo = None , fee = None ): Create a new HtlcLock transaction instance Parameters \u00b6 Type Name Required Description str recipient_id Yes Transaction recipient int amount Yes Transaction amount str secret_hash Yes Transaction secret hash. The same hash must be used in the corresponding \"claim\" transaction int expiration_type Yes Transaction expiration type. Either block height or network epoch timestamp based int expiration_value Yes Transaction expiration value. The block-height or time when the transaction should expire str memo Yes Transaction memo int fee No Transaction fee Return Value \u00b6 <class 'solar_crypto.transactions.builder.htlc_lock.HtlcLock'> get_type_group() \u00b6 def get_type_group ( self ): Get the type group of the Transaction. Return Value \u00b6 <class 'int'> crypto.transactions.builder.htlc_refund.HtlcRefund \u00b6 __init__() \u00b6 def __init__ ( self , lock_transaction_id , fee = None ): Create a new HtlcRefund transaction instance Parameters \u00b6 Type Name Required Description str lock_transaction_id Yes HTLC Lock transaction id int fee No Transaction fee Return Value \u00b6 <class 'solar_crypto.transactions.builder.htlc_refund.HtlcRefund'> get_type_group() \u00b6 def get_type_group ( self ): Get the type group of the Transaction. Return Value \u00b6 <class 'int'> crypto.transactions.builder.ipfs.IPFS \u00b6 __init__() \u00b6 def __init__ ( self , ipfs_cid = None , fee = None ): Create a new IPFS transaction instance Parameters \u00b6 Type Name Required Description str ipfs_cid No Content identifier int fee No Transaction fee Return Value \u00b6 <class 'solar_crypto.transactions.builder.ipfs.IPFS'> get_type_group() \u00b6 def get_type_group ( self ): Get the type group of the Transaction. Return Value \u00b6 <class 'int'> set_ipfs_cid() \u00b6 set_ipfs_cid ( self , cid : str ): Set the content identifier of the Transaction. Parameters \u00b6 Type Name Required Description str cid Yes Content identifier Return Value \u00b6 <class 'NoneType'> crypto.transactions.builder.transfer.Transfer \u00b6 __init__() \u00b6 def __init__ ( self , memo = None , fee = None ): Create a new Transfer transaction instance Parameters \u00b6 Type Name Required Description str memo No Transaction memo int fee No Transaction fee Return Value \u00b6 <class 'solar_crypto.transactions.builder.transfer.Transfer'> get_type_group() \u00b6 def get_type_group ( self ): Get the type group of the Transaction. Return Value \u00b6 <class 'int'> add_transfer() \u00b6 def add_transfer ( self , amount , recipient_id ): Add a transfer to the Transfers array of a Transaction. Parameters \u00b6 Type Name Required Description int amount Yes Transaction amount string recipient_id Yes Transaction recipient Return Value \u00b6 <class 'NoneType'> crypto.transactions.builder.multi_signature_registration.MultiSignatureRegistration \u00b6 __init__() \u00b6 def __init__ ( self , fee = None ): Create a new MultiSignatureRegistration transaction instance Parameters \u00b6 Type Name Required Description int fee No Transaction fee Return Value \u00b6 <class 'solar_crypto.transactions.builder.multi_signature_registration.MultiSignatureRegistration'> set_min() \u00b6 def set_min ( self , minimum_participants ): Set the minimum amount of participants of a Transaction. Parameters \u00b6 Type Name Required Description int minimum_participants Yes Transaction minimum participants Return Value \u00b6 <class 'NoneType'> set_public_keys() \u00b6 def set_public_keys ( self , public_keys ): Set the public keys of a Transaction. Parameters \u00b6 Type Name Required Description list public_keys Yes Transaction public keys participants Return Value \u00b6 <class 'NoneType'> add_participant() \u00b6 def add_participant ( self , public_key ): Add a participant with his public key to the Transaction. Parameters \u00b6 Type Name Required Description str public_key Yes Participant public key Return Value \u00b6 <class 'NoneType'> crypto.transactions.builder.second_signature_registration.SecondSignatureRegistration \u00b6 __init__() \u00b6 def __init__ ( self , second_passphrase , fee = None ): Create a new SecondSignatureRegistration transaction instance Parameters \u00b6 Type Name Required Description str second_passphrase No Second passphrase int fee No Transaction fee Return Value \u00b6 <class 'solar_crypto.transactions.builder.second_signature_registration.SecondSignatureRegistration'> crypto.transactions.builder.legacy_transfer.LegacyTransfer \u00b6 __init__() \u00b6 def __init__ ( self , recipientId , amount , memo = None , fee = None ): Create a new Legacy Transfer transaction instance Parameters \u00b6 Type Name Required Description str recipientId Yes Recipient identifier int amount Yes Transaction amount str memo No Transaction memo int fee No Transaction fee Return Value \u00b6 <class 'solar_crypto.transactions.builder.legacy_transfer.LegacyTransfer'> crypto.transactions.builder.legacy_vote.LegacyVote \u00b6 __init__() \u00b6 def __init__ ( self , vote = None , fee = None ): Create a new Legacy Vote transaction instance Parameters \u00b6 Type Name Required Description str vote No Delegate address to vote for int fee No Transaction fee Return Value \u00b6 <class 'solar_crypto.transactions.builder.legacy_vote.LegacyVote'> set_votes() \u00b6 def set_votes ( self , votes : typing . List [ str ]): Set legacy votes/cancel vote Parameters \u00b6 Type Name Required Description List[str] votes Yes list of votes Return Value \u00b6 <class 'NoneType'> sign() \u00b6 def sign ( self , passphrase ): Sign the transaction using the given passphrase Parameters \u00b6 Type Name Required Description str passphrase Yes Passphrase Return Value \u00b6 <class 'NoneType'> crypto.transactions.builder.vote.Vote \u00b6 __init__() \u00b6 def __init__ ( self ): Create a new Vote transaction instance Return Value \u00b6 <class 'solar_crypto.transactions.builder.vote.Vote'> set_votes() \u00b6 def set_votes ( self , votes : typing . Union [ typing . List [ str ], typing . Dict [ str , typing . Union [ int , float , Decimal ]]] = dict ): Set votes Parameters \u00b6 Type Name Required Description votes votes Yes list of votes Return Value \u00b6 <class 'NoneType'> crypto.transactions.deserializers.base.BaseDeserializer \u00b6 __init__() \u00b6 def __init__ ( self , serialized , asset_offset , transaction ): Create a new deserializer instance Parameters \u00b6 Type Name Required Description ??? serialized Yes Serialized ??? asset_offset Yes Offset ??? transaction Yes Transaction Return Value \u00b6 <class 'solar_crypto.transactions.deserializers.base.BaseDeserializer'> deserialize() \u00b6 def deserialize ( self ): Handle the deserialization of transaction data Return Value \u00b6 NotImplementedError crypto.transactions.deserializers.burn.BurnDeserializer \u00b6 deserialize() \u00b6 def deserialize ( self ): Handle the deserialization of \"burn\" data Return Value \u00b6 <class 'dict'> crypto.transactions.deserializers.delegate_registration.DelegateRegistrationDeserializer \u00b6 deserialize() \u00b6 def deserialize ( self ): Handle the deserialization of \"delegate registration\" data Return Value \u00b6 <class 'dict'> crypto.transactions.deserializers.delegate_resignation.DelegateResignationDeserializer \u00b6 deserialize() \u00b6 def deserialize ( self ): Handle the deserialization of \"delegate resignation\" data Return Value \u00b6 <class 'dict'> crypto.transactions.deserializers.htlc_claim.HtlcClaimDeserializer \u00b6 deserialize() \u00b6 def deserialize ( self ): Handle the deserialization of \"HTLC Claim\" data Return Value \u00b6 <class 'dict'> crypto.transactions.deserializers.htlc_lock.HtlcLockDeserializer \u00b6 deserialize() \u00b6 def deserialize ( self ): Handle the deserialization of \"HTLC Lock\" data Return Value \u00b6 <class 'dict'> crypto.transactions.deserializers.htlc_refund.HtlcRefundDeserializer \u00b6 deserialize() \u00b6 def deserialize ( self ): Handle the deserialization of \"HTLC refund\" data Return Value \u00b6 <class 'dict'> crypto.transactions.deserializers.ipfs.IPFSDeserializer \u00b6 deserialize() \u00b6 def deserialize ( self ): Handle the deserialization of \"IPFS\" data Return Value \u00b6 <class 'dict'> crypto.transactions.deserializers.transfer.TransferDeserializer \u00b6 deserialize() \u00b6 def deserialize ( self ): Handle the deserialization of \"transfer\" data Return Value \u00b6 <class 'dict'> crypto.transactions.deserializers.multi_signature_registration.MultiSignatureRegistrationDeserializer \u00b6 deserialize() \u00b6 def deserialize ( self ): Handle the deserialization of \"multi signature registration\" data Return Value \u00b6 <class 'dict'> crypto.transactions.deserializers.second_signature_registration.SecondSignatureRegistrationDeserializer \u00b6 deserialize() \u00b6 def deserialize ( self ): Handle the deserialization of \"second signature\" data. Return Value \u00b6 <class 'dict'> crypto.transactions.deserializers.legacy_transfer.LegacyTransferDeserializer \u00b6 deserialize() \u00b6 def deserialize ( self ): Handle the deserialization of \"legacy transfer\" data Return Value \u00b6 <class 'dict'> crypto.transactions.deserializers.legacy_vote.LegacyVoteDeserializer \u00b6 deserialize() \u00b6 def deserialize ( self ): Handle the deserialization of \"legacy vote\" data. Return Value \u00b6 <class 'dict'> crypto.transactions.deserializers.vote.VoteDeserializer \u00b6 deserialize() \u00b6 def deserialize ( self ): Handle the deserialization of \"vote\" data. Return Value \u00b6 <class 'dict'> crypto.transactions.serializers.base.BaseSerializer \u00b6 __init__() \u00b6 def __init__ ( self , transaction , byte_data = bytes ()): Create a new serializer instance Parameters \u00b6 Type Name Required Description Transaction transaction Yes Transaction bytes byte_data No ... Return Value \u00b6 <class 'solar_crypto.transactions.serializers.base.BaseSerializer'> serialize \u00b6 def serialize ( self ): Handle the serialization of transaction data Return Value \u00b6 NotImplementedError crypto.transactions.serializers.burn.BurnSerializer \u00b6 serialize \u00b6 def serialize ( self ): Handle the serialization of \"burn\" data Return Value \u00b6 <class 'bytes'> crypto.transactions.serializers.delegate_registration.DelegateRegistrationSerializer \u00b6 serialize \u00b6 def serialize ( self ): Handle the serialization of \"delegate registration\" data Return Value \u00b6 <class 'bytes'> crypto.transactions.serializers.delegate_resignationDelegateResignationSerializer \u00b6 serialize \u00b6 def serialize ( self ): Handle the serialization of \"delegate resignation\" data Return Value \u00b6 <class 'bytes'> crypto.transactions.serializers.htlc_claim.HtlcClaimSerializer \u00b6 serialize() \u00b6 def serialize ( self ): Handle the serialization of \"HTLC Claim\" data Return Value \u00b6 <class 'bytes'> crypto.transactions.serializers.htlc_lock.HtlcLockSerializer \u00b6 serialize() \u00b6 def serialize ( self ): Handle the serialization of \"HTLC Lock\" data Return Value \u00b6 <class 'bytes'> crypto.transactions.serializers.htlc_refund.HtlcRefundSerializer \u00b6 serialize() \u00b6 def serialize ( self ): Handle the serialization of \"HTLC Refund\" data Return Value \u00b6 <class 'bytes'> crypto.transactions.serializers.ipfs.IPFSSerializer \u00b6 serialize \u00b6 def serialize ( self ): Handle the serialization of \"ipfs\" data Return Value \u00b6 <class 'bytes'> crypto.transactions.serializers.transfer.TransferSerializer \u00b6 serialize \u00b6 def serialize ( self ): Handle the serialization of \"transfer\" data Return Value \u00b6 <class 'bytes'> crypto.transactions.serializers.multi_signature_registration.MultiSignatureSerializer \u00b6 serialize \u00b6 def serialize ( self ): Handle the serialization of \"multi signature\" data Return Value \u00b6 <class 'bytes'> crypto.transactions.serializers.second_signature_registration.SecondSignatureRegistrationSerializer \u00b6 serialize \u00b6 def serialize ( self ): Handle the serialization of \"second signature\" data Return Value \u00b6 <class 'bytes'> crypto.transactions.serializers.legacy_transfer.LegacyTransferSerializer \u00b6 serialize \u00b6 def serialize ( self ): Handle the serialization of \"legacy transfer\" data Return Value \u00b6 <class 'bytes'> crypto.transactions.serializers.legacy_vote.LegacyVoteSerializer \u00b6 serialize \u00b6 def serialize ( self ): Handle the serialization of \"legacy vote\" data Return Value \u00b6 <class 'bytes'> crypto.transactions.serializers.vote.VoteSerializer \u00b6 serialize \u00b6 def serialize ( self ): Handle the serialization of \"vote\" data Return Value \u00b6 <class 'bytes'> crypto.transactions.deserializer.Deserializer \u00b6 __init__ \u00b6 def __init__ ( self , serialized ): Create a new deserializer instance Parameters \u00b6 Type Name Required Description str serialized Yes Serialized Return Value \u00b6 <class 'solar_crypto.transactions.deserializer.Deserializer'> deserialize \u00b6 def deserialize ( self ): Perform AIP11 compliant deserialization Return Value \u00b6 <class 'solar_crypto.transactions.transaction.Transaction'> _handle_transaction_type \u00b6 def _handle_transaction_type ( self , asset_offset , transaction ): Handle the deserialization of transaction data Parameters \u00b6 Type Name Required Description int asset_offset Yes Offset transaction.Transaction transaction Yes Transaction Return Value \u00b6 <class 'solar_crypto.transactions.transaction.Transaction'> crypto.transactions.serializer.Serializer \u00b6 __init__ \u00b6 def __init__ ( self , transaction ): Create a new serializer instance Parameters \u00b6 Type Name Required Description transaction.Transaction transaction Yes Transaction Return Value \u00b6 <class 'solar_crypto.transactions.serializer.Serializer'> serialize \u00b6 def serialize ( self , skip_signature = True , skip_second_signature = True , skip_multi_signature = True , raw = False ): Perform AIP11 compliant serialization Parameters \u00b6 Type Name Required Description bool skip_signature No Should we skip the serialization of the signature bool skip_second_signature No Should we skip the serialization of the second signature bool skip_multi_signature No Should we skip the serialization of multiple signatures bool raw No Raw output Return Value \u00b6 <class 'str'> _handle_transaction_type \u00b6 def _handle_transaction_type ( self , bytes_data ): Handle the serialization of transaction data Parameters \u00b6 Type Name Required Description bytes bytes_data Yes ... Return Value \u00b6 <class 'bytes'> _handle_signature \u00b6 def _handle_signature ( self , bytes_data , skip_signature , skip_second_signature , skip_multi_signature ): Handle the serialization of \"signatures\" data Parameters \u00b6 Type Name Required Description bytes bytes_data Yes ... bool skip_signature Yes Should we skip the serialization of the signature bool skip_second_signature Yes Should we skip the serialization of the second signature bool skip_multi_signature Yes Should we skip the serialization of multiple signatures Return Value \u00b6 <class 'bytes'> crypto.transactions.transaction.Transaction \u00b6 __init__ \u00b6 def __init__ ( self , * args , ** kwargs ): Create a new transaction instance Parameters \u00b6 Type Name Required Description any *args No ... any **kwargs No ... Return Value \u00b6 <class 'solar_crypto.transactions.transaction.Transaction'> get_id \u00b6 def get_id ( self ): Convert the byte representation to a unique identifier Return Value \u00b6 <class 'str'> to_dict \u00b6 def to_dict ( self ): Convert the transaction to its dictionary representation. Return Value \u00b6 <class 'dict'> to_json \u00b6 def to_json ( self ): Convert the transaction to its JSON representation Return Value \u00b6 <class 'dict'> to_bytes \u00b6 def to_bytes ( self , skip_signature = True , skip_second_signature = True , skip_multi_signature = True ): Convert the transaction to its byte representation Parameters \u00b6 Type Name Required Description bool skip_signature Yes Skip first signature bool skip_second_signature Yes Skip second signature bool skip_multi_signature Yes Skip multi signatures Return Value \u00b6 <class 'bytes'> parse_signatures \u00b6 def parse_signatures ( self , serialized , start_offset ): Parse the signature, second signature and multi signatures Parameters \u00b6 Type Name Required Description str serialized Yes Serialized int start_offset Yes Offset Return Value \u00b6 <class 'NoneType'> serialize \u00b6 def serialize ( self , skip_signature = True , skip_second_signature = True , skip_multi_signature = True ): Perform AIP11 compliant serialization Parameters \u00b6 Type Name Required Description bool skip_signature Yes Skip first signature bool skip_second_signature Yes Skip second signature bool skip_multi_signature Yes Skip multi signatures Return Value \u00b6 <class 'str'> deserialize \u00b6 def deserialize ( self , serialized ): Perform AIP11 compliant deserialization Parameters \u00b6 Type Name Required Description str serialized Yes Serialized Return Value \u00b6 <class 'str'> verify \u00b6 def verify ( self ): Verify the transaction. Method will raise an exception if invalid, if it's valid it will returns True Return Value \u00b6 <class 'bool'> verify_secondsig \u00b6 def verify_secondsig ( self , secondPublicKey ): Verify the second signature. Method will raise an exception if invalid, if it's valid it will returns True Parameters \u00b6 Type Name Required Description str secondPublicKey Yes Second public key Return Value \u00b6 <class 'bool'> verify_signatures \u00b6 def verify_signatures ( self , multi_signature_asset ): Verify the multisignatures transaction. Method will raise an exception if invalid, it will returns True Parameters \u00b6 Type Name Required Description dict multi_signature_asset Yes Multisignature asset Return Value \u00b6 <class 'bool'> _handle_transaction_type \u00b6 def _handle_transaction_type ( self , bytes_data ): Handle each transaction type differently Parameters \u00b6 Type Name Required Description bytes bytes_data Yes Input the bytes data to which you want to append new bytes Return Value \u00b6 <class 'bytes'> _handle_signature \u00b6 def _handle_signature ( self , bytes_data , skip_signature , skip_second_signature , skip_multi_signature ): Handle the serialization of \"signatures\" data Parameters \u00b6 Type Name Required Description bytes bytes_data Yes Input the bytes data to which you want to append new bytes from signature bool skip_signature Yes Skip first signature bool skip_second_signature Yes Skip second signature bool skip_multi_signature Yes Skip multi signatures Return Value \u00b6 <class 'bytes'> crypto.utils.crypto \u00b6 sign_schnorr \u00b6 def sign_schnorr ( msg : bytes , private_key : PrivateKey , nonce : int = None ) -> str : Signs a message using Schnorr BIP340 and returns a hex string of the signature Parameters \u00b6 Type Name Required Description bytes msg Yes Message to be signed PrivateKey private_key Yes Private key object int nonce No Deterministic nonce Return Value \u00b6 <class 'str'> sign_schnorr_legacy \u00b6 def sign_schnorr_legacy ( msg : bytes , private_key : PrivateKey ) -> str : Signs a message using Legacy Schnorr and returns a hex string of the signature Parameters \u00b6 Type Name Required Description bytes msg Yes Message to be signed PrivateKey private_key Yes Private key object int nonce No Deterministic nonce Return Value \u00b6 <class 'str'> verify_schnorr \u00b6 def verify_schnorr ( msg : bytes , public_key : str , signature : str ) -> bool : Verifies a message using Schnorr BIP340 Parameters \u00b6 Type Name Required Description bytes msg Yes Message to be verified str public_key Yes Public key str signature Yes Signature Return Value \u00b6 <class 'bool'> verify_schnorr_legacy \u00b6 def verify_schnorr_legacy ( msg : bytes , public_key : str , signature : str ) -> bool : Verifies a message using Legacy Schnorr Parameters \u00b6 Type Name Required Description bytes msg Yes Message to be verified str public_key Yes Public key str signature Yes Signature Return Value \u00b6 <class 'bool'> crypto.utils.message.Message \u00b6 __init__ \u00b6 def __init__ ( self , ** kwargs ): Create a new message instance Parameters \u00b6 Type Name Required Description any **kwargs No ... Return Value \u00b6 <class 'solar_crypto.utils.message.Message'> sign \u00b6 def sign ( cls , message , passphrase ): Sign a message using the given passphrase Parameters \u00b6 Type Name Required Description str message Yes Message str passphrase Yes Passphrase Return Value \u00b6 <class 'solar_crypto.utils.message.Message'> verify \u00b6 def verify ( self ): Verify the message contents Return Value \u00b6 <class 'bool'> to_dict \u00b6 def to_dict ( self ): Convert the message to its dictionary representation Return Value \u00b6 <class 'dict'> to_json \u00b6 def to_json ( self ): Convert the message to its JSON representation Return Value \u00b6 <class 'dict'> crypto.utils.slot \u00b6 get_time \u00b6 def get_time (): Get the time diff between now and network start Return Value \u00b6 <class 'int'> get_epoch \u00b6 def get_epoch (): Get the network start epoch Return Value \u00b6 <class 'datetime'>","title":"API Documentation"},{"location":"sdk/python/crypto/api-documentation/#api-documentation","text":"","title":"API Documentation"},{"location":"sdk/python/crypto/api-documentation/#cryptoconfigurationfee","text":"","title":"crypto.configuration.fee"},{"location":"sdk/python/crypto/api-documentation/#get_fee","text":"def get_fee ( transaction_type , type_group ): Get a fee for a given transaction type","title":"get_fee()"},{"location":"sdk/python/crypto/api-documentation/#parameters","text":"Type Name Required Description int transaction_type Yes Transaction type for which we wish to get a fee int type_group Yes transaction type group (TRANSACTION_TYPE_GROUP(Enum))","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value","text":"<class 'int'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#set_fee","text":"def set_fee ( transaction_type , type_group , value ): Set a fee","title":"set_fee()"},{"location":"sdk/python/crypto/api-documentation/#parameters_1","text":"Type Name Required Description int transaction_type Yes Transaction type for which we wish to set a fee int type_group Yes transaction type group (TRANSACTION_TYPE_GROUP(Enum)) int value Yes Fee for a given transaction type","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_1","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptoconfigurationnetwork","text":"","title":"crypto.configuration.network"},{"location":"sdk/python/crypto/api-documentation/#set_network","text":"def set_network ( network_object ): Set what network you want to use in the crypto library","title":"set_network()"},{"location":"sdk/python/crypto/api-documentation/#parameters_2","text":"Type Name Required Description Network network_object Yes Testnet, Mainnet","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_2","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#get_network","text":"def get_network (): Get settings for a selected network, default network is Testnet","title":"get_network()"},{"location":"sdk/python/crypto/api-documentation/#return-value_3","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#set_custom_network","text":"def set_custom_network ( epoch , version , wif ): Set custom network","title":"set_custom_network()"},{"location":"sdk/python/crypto/api-documentation/#parameters_3","text":"Type Name Required Description datetime epoch Yes Network epoch time int version Yes Network version int wif Yes Network WIF","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_4","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#get_network_version","text":"def get_network_version (): Get currently set network version","title":"get_network_version()"},{"location":"sdk/python/crypto/api-documentation/#return-value_5","text":"<class 'Network'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptoidentityaddress","text":"","title":"crypto.identity.address"},{"location":"sdk/python/crypto/api-documentation/#address_from_public_key","text":"def address_from_public_key ( public_key , network_version = None ): Get an address from a public key","title":"address_from_public_key()"},{"location":"sdk/python/crypto/api-documentation/#parameters_4","text":"Type Name Required Description str public_key Yes Public key int network_version No Version of the network","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_6","text":"<class 'str'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#address_from_private_key","text":"def address_from_private_key ( private_key , network_version = None ): Get an address from private key","title":"address_from_private_key()"},{"location":"sdk/python/crypto/api-documentation/#parameters_5","text":"Type Name Required Description str private_key Yes Private key int network_version No Version of the network","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_7","text":"<class 'str'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#address_from_passphrase","text":"def address_from_passphrase ( passphrase , network_version = None ): Get an address from passphrase","title":"address_from_passphrase()"},{"location":"sdk/python/crypto/api-documentation/#parameters_6","text":"Type Name Required Description str passphrase Yes Passphrase int network_version No Version of the network","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_8","text":"<class 'str'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#validate_address","text":"def validate_address ( address , network_version = None ): Validate a given address","title":"validate_address()"},{"location":"sdk/python/crypto/api-documentation/#parameters_7","text":"Type Name Required Description str address Yes Address to validate int network_version No Version of the network","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_9","text":"<class 'bool'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptoidentityprivate_keyprivatekey","text":"","title":"crypto.identity.private_key.PrivateKey"},{"location":"sdk/python/crypto/api-documentation/#__init__","text":"def __init__ ( self , private_key ): Create a new PrivateKey instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_8","text":"Type Name Required Description str private_key Yes Hex private key","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_10","text":"<class 'solar_crypto.identity.private_key.PrivateKey'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#sign","text":"def sign ( self , message , nonce = None ): Sign a message with this private key object","title":"sign()"},{"location":"sdk/python/crypto/api-documentation/#parameters_9","text":"Type Name Required Description str message Yes Bytes data you want to sign int nonce No Deterministic nonce","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_11","text":"<class 'str'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#to_hex","text":"def to_hex ( self ): Returns a private key in hex format","title":"to_hex()"},{"location":"sdk/python/crypto/api-documentation/#return-value_12","text":"<class 'str'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#from_passphrase","text":"def from_passphrase ( cls , passphrase ): Create PrivateKey object from a given passphrase","title":"from_passphrase()"},{"location":"sdk/python/crypto/api-documentation/#parameters_10","text":"Type Name Required Description str passphrase Yes Passphrase","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_13","text":"<class 'PrivateKey'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#from_hex","text":"def from_hex ( cls , private_key ): Create PrivateKey object from a given hex private key","title":"from_hex()"},{"location":"sdk/python/crypto/api-documentation/#parameters_11","text":"Type Name Required Description str private_key Yes Private key","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_14","text":"<class 'PrivateKey'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptoidentitypublic_keypublickey","text":"","title":"crypto.identity.public_key.PublicKey"},{"location":"sdk/python/crypto/api-documentation/#to_hex_1","text":"def to_hex ( self ): Returns a public key in hex format","title":"to_hex()"},{"location":"sdk/python/crypto/api-documentation/#return-value_15","text":"<class 'str'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#from_passphrase_1","text":"def from_passphrase ( cls , passphrase ): Create PublicKey object from a given passphrase","title":"from_passphrase()"},{"location":"sdk/python/crypto/api-documentation/#parameters_12","text":"Type Name Required Description str passphrase Yes Passphrase","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_16","text":"<class 'PublicKey'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#from_hex_1","text":"def from_hex ( cls , public_key ): Create PublicKey object from a given hex private key","title":"from_hex()"},{"location":"sdk/python/crypto/api-documentation/#parameters_13","text":"Type Name Required Description str public_key Yes Public key","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_17","text":"<class 'PublicKey'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptoidentitywif","text":"","title":"crypto.identity.wif"},{"location":"sdk/python/crypto/api-documentation/#wif_from_passphrase","text":"def wif_from_passphrase ( passphrase , network_wif = None ): Get wif from passphrase","title":"wif_from_passphrase()"},{"location":"sdk/python/crypto/api-documentation/#parameters_14","text":"Type Name Required Description str passphrase Yes Passphrase int network_wif No Network WIF","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_18","text":"<class 'str'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsbuilderbasebasetransactionbuilder","text":"","title":"crypto.transactions.builder.base.BaseTransactionBuilder"},{"location":"sdk/python/crypto/api-documentation/#to_dict","text":"def to_dict ( self ): Convert the transaction to its dictionary representation.","title":"to_dict()"},{"location":"sdk/python/crypto/api-documentation/#return-value_19","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#to_json","text":"def to_json ( self ): Convert the transaction to its JSON representation","title":"to_json()"},{"location":"sdk/python/crypto/api-documentation/#return-value_20","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#sign_1","text":"def sign ( self , passphrase ): Sign the transaction using the given passphrase","title":"sign()"},{"location":"sdk/python/crypto/api-documentation/#parameters_15","text":"Type Name Required Description str passphrase Yes Passphrase associated with the account sending this transaction","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_21","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#second_sign","text":"def second_sign ( self , passphrase ): Sign the transaction using the given second passphrase","title":"second_sign()"},{"location":"sdk/python/crypto/api-documentation/#parameters_16","text":"Type Name Required Description str passphrase Yes Second passphrase associated with the account sending this transaction","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_22","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#multi_sign","text":"def multi_sign ( self , passphrase , index ): Sign the transaction using the given passphrase. A signature will be generated inside the signatures array of the transaction at the specified index.","title":"multi_sign()"},{"location":"sdk/python/crypto/api-documentation/#parameters_17","text":"Type Name Required Description str passphrase Yes Passphrase associated with the account sending this transaction int index Yes Index of the signature for the signatures array. Starts at 0.","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_23","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#verify","text":"def verify ( self ): Verify the transaction validity","title":"verify()"},{"location":"sdk/python/crypto/api-documentation/#return-value_24","text":"<class 'bool'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#verify_multisig","text":"def verify_multisig ( self ): Verify the multisignature transaction validity","title":"verify_multisig()"},{"location":"sdk/python/crypto/api-documentation/#return-value_25","text":"<class 'bool'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#set_nonce","text":"def set_nonce ( self , nonce ): Set the nonce of the transaction.","title":"set_nonce()"},{"location":"sdk/python/crypto/api-documentation/#parameters_18","text":"Type Name Required Description int nonce Yes Sequential Nonce of the transaction","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_26","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#set_fee_1","text":"def set_fee ( self , fee : int ): Set a fee","title":"set_fee()"},{"location":"sdk/python/crypto/api-documentation/#parameters_19","text":"Type Name Required Description int fee Yes Transaction fee","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_27","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#set_amount","text":"def set_amount ( self , amount ): Set the amount of the transaction.","title":"set_amount()"},{"location":"sdk/python/crypto/api-documentation/#parameters_20","text":"Type Name Required Description int amount Yes Amount of the transaction","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_28","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#set_sender_public_key","text":"def set_sender_public_key ( self , public_key ): Set the Public Key of the transaction.","title":"set_sender_public_key()"},{"location":"sdk/python/crypto/api-documentation/#parameters_21","text":"Type Name Required Description str public_key Yes Public key of the transaction","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_29","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#set_expiration","text":"def set_expiration ( self , expiration ): Set the block-height or time when the transaction should expire.","title":"set_expiration()"},{"location":"sdk/python/crypto/api-documentation/#parameters_22","text":"Type Name Required Description int, HTLC_LOCK_EXPIRATION_TYPE expiration Yes Expiration of the transaction","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_30","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#set_type_group","text":"def set_type_group ( self , type_group ): Set the type group of the transaction.","title":"set_type_group()"},{"location":"sdk/python/crypto/api-documentation/#parameters_23","text":"Type Name Required Description int, TRANSACTION_TYPE_GROUP type_group Yes Type group of the transaction","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_31","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsbuilderburnburn","text":"","title":"crypto.transactions.builder.burn.Burn"},{"location":"sdk/python/crypto/api-documentation/#__init___1","text":"def __init__ ( self , amount ): Create a new Burn transaction instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_24","text":"Type Name Required Description int amount Yes Burn amount","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_32","text":"<class 'solar_crypto.transactions.builder.burn.Burn'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsbuilderdelegate_registrationdelegateregistration","text":"","title":"crypto.transactions.builder.delegate_registration.DelegateRegistration"},{"location":"sdk/python/crypto/api-documentation/#__init___2","text":"def __init__ ( self , username , fee = None ): Create a new DelegateRegistration transaction instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_25","text":"Type Name Required Description str username Yes Delegate username int fee No Transaction fee","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_33","text":"<class 'solar_crypto.transactions.builder.delegate_registration.DelegateRegistration'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#sign_2","text":"def sign ( self , passphrase ): Sign the transaction using the given passphrase","title":"sign()"},{"location":"sdk/python/crypto/api-documentation/#parameters_26","text":"Type Name Required Description str passphrase Yes Passphrase","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_34","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsbuilderdelegate_resignationdelegateresignation","text":"","title":"crypto.transactions.builder.delegate_resignation.DelegateResignation"},{"location":"sdk/python/crypto/api-documentation/#__init___3","text":"def __init__ ( self , fee = None ): Create a new DelegateResignation transaction instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_27","text":"Type Name Required Description int fee No Transaction fee","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_35","text":"<class 'solar_crypto.transactions.builder.delegate_resignation.DelegateResignation'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#get_type_group","text":"def get_type_group ( self ): Get the type group of the Transaction.","title":"get_type_group()"},{"location":"sdk/python/crypto/api-documentation/#return-value_36","text":"<class 'int'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsbuilderhtlc_claimhtlcclaim","text":"","title":"crypto.transactions.builder.htlc_claim.HtlcClaim"},{"location":"sdk/python/crypto/api-documentation/#__init___4","text":"def __init__ ( self , lock_transaction_id , unlock_secret , hash_type : HashingType = HashingType . SHA256 , fee = None ): Create a new HtlcClaim transaction instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_28","text":"Type Name Required Description str lock_transaction_id Yes HTLC Lock transaction id str unlock_secret Yes Transaction secret hash HashingType hash_type No Hashing algorithm int fee No Transaction fee","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_37","text":"<class 'solar_crypto.transactions.builder.htlc_claim.HtlcClaim'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#get_type_group_1","text":"def get_type_group ( self ): Get the type group of the Transaction.","title":"get_type_group()"},{"location":"sdk/python/crypto/api-documentation/#return-value_38","text":"<class 'int'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsbuilderhtlc_lockhtlclock","text":"","title":"crypto.transactions.builder.htlc_lock.HtlcLock"},{"location":"sdk/python/crypto/api-documentation/#__init___5","text":"def __init__ ( self , recipient_id , amount , secret_hash , expiration_type , expiration_value , memo = None , fee = None ): Create a new HtlcLock transaction instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_29","text":"Type Name Required Description str recipient_id Yes Transaction recipient int amount Yes Transaction amount str secret_hash Yes Transaction secret hash. The same hash must be used in the corresponding \"claim\" transaction int expiration_type Yes Transaction expiration type. Either block height or network epoch timestamp based int expiration_value Yes Transaction expiration value. The block-height or time when the transaction should expire str memo Yes Transaction memo int fee No Transaction fee","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_39","text":"<class 'solar_crypto.transactions.builder.htlc_lock.HtlcLock'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#get_type_group_2","text":"def get_type_group ( self ): Get the type group of the Transaction.","title":"get_type_group()"},{"location":"sdk/python/crypto/api-documentation/#return-value_40","text":"<class 'int'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsbuilderhtlc_refundhtlcrefund","text":"","title":"crypto.transactions.builder.htlc_refund.HtlcRefund"},{"location":"sdk/python/crypto/api-documentation/#__init___6","text":"def __init__ ( self , lock_transaction_id , fee = None ): Create a new HtlcRefund transaction instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_30","text":"Type Name Required Description str lock_transaction_id Yes HTLC Lock transaction id int fee No Transaction fee","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_41","text":"<class 'solar_crypto.transactions.builder.htlc_refund.HtlcRefund'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#get_type_group_3","text":"def get_type_group ( self ): Get the type group of the Transaction.","title":"get_type_group()"},{"location":"sdk/python/crypto/api-documentation/#return-value_42","text":"<class 'int'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsbuilderipfsipfs","text":"","title":"crypto.transactions.builder.ipfs.IPFS"},{"location":"sdk/python/crypto/api-documentation/#__init___7","text":"def __init__ ( self , ipfs_cid = None , fee = None ): Create a new IPFS transaction instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_31","text":"Type Name Required Description str ipfs_cid No Content identifier int fee No Transaction fee","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_43","text":"<class 'solar_crypto.transactions.builder.ipfs.IPFS'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#get_type_group_4","text":"def get_type_group ( self ): Get the type group of the Transaction.","title":"get_type_group()"},{"location":"sdk/python/crypto/api-documentation/#return-value_44","text":"<class 'int'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#set_ipfs_cid","text":"set_ipfs_cid ( self , cid : str ): Set the content identifier of the Transaction.","title":"set_ipfs_cid()"},{"location":"sdk/python/crypto/api-documentation/#parameters_32","text":"Type Name Required Description str cid Yes Content identifier","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_45","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsbuildertransfertransfer","text":"","title":"crypto.transactions.builder.transfer.Transfer"},{"location":"sdk/python/crypto/api-documentation/#__init___8","text":"def __init__ ( self , memo = None , fee = None ): Create a new Transfer transaction instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_33","text":"Type Name Required Description str memo No Transaction memo int fee No Transaction fee","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_46","text":"<class 'solar_crypto.transactions.builder.transfer.Transfer'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#get_type_group_5","text":"def get_type_group ( self ): Get the type group of the Transaction.","title":"get_type_group()"},{"location":"sdk/python/crypto/api-documentation/#return-value_47","text":"<class 'int'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#add_transfer","text":"def add_transfer ( self , amount , recipient_id ): Add a transfer to the Transfers array of a Transaction.","title":"add_transfer()"},{"location":"sdk/python/crypto/api-documentation/#parameters_34","text":"Type Name Required Description int amount Yes Transaction amount string recipient_id Yes Transaction recipient","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_48","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsbuildermulti_signature_registrationmultisignatureregistration","text":"","title":"crypto.transactions.builder.multi_signature_registration.MultiSignatureRegistration"},{"location":"sdk/python/crypto/api-documentation/#__init___9","text":"def __init__ ( self , fee = None ): Create a new MultiSignatureRegistration transaction instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_35","text":"Type Name Required Description int fee No Transaction fee","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_49","text":"<class 'solar_crypto.transactions.builder.multi_signature_registration.MultiSignatureRegistration'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#set_min","text":"def set_min ( self , minimum_participants ): Set the minimum amount of participants of a Transaction.","title":"set_min()"},{"location":"sdk/python/crypto/api-documentation/#parameters_36","text":"Type Name Required Description int minimum_participants Yes Transaction minimum participants","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_50","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#set_public_keys","text":"def set_public_keys ( self , public_keys ): Set the public keys of a Transaction.","title":"set_public_keys()"},{"location":"sdk/python/crypto/api-documentation/#parameters_37","text":"Type Name Required Description list public_keys Yes Transaction public keys participants","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_51","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#add_participant","text":"def add_participant ( self , public_key ): Add a participant with his public key to the Transaction.","title":"add_participant()"},{"location":"sdk/python/crypto/api-documentation/#parameters_38","text":"Type Name Required Description str public_key Yes Participant public key","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_52","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsbuildersecond_signature_registrationsecondsignatureregistration","text":"","title":"crypto.transactions.builder.second_signature_registration.SecondSignatureRegistration"},{"location":"sdk/python/crypto/api-documentation/#__init___10","text":"def __init__ ( self , second_passphrase , fee = None ): Create a new SecondSignatureRegistration transaction instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_39","text":"Type Name Required Description str second_passphrase No Second passphrase int fee No Transaction fee","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_53","text":"<class 'solar_crypto.transactions.builder.second_signature_registration.SecondSignatureRegistration'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsbuilderlegacy_transferlegacytransfer","text":"","title":"crypto.transactions.builder.legacy_transfer.LegacyTransfer"},{"location":"sdk/python/crypto/api-documentation/#__init___11","text":"def __init__ ( self , recipientId , amount , memo = None , fee = None ): Create a new Legacy Transfer transaction instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_40","text":"Type Name Required Description str recipientId Yes Recipient identifier int amount Yes Transaction amount str memo No Transaction memo int fee No Transaction fee","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_54","text":"<class 'solar_crypto.transactions.builder.legacy_transfer.LegacyTransfer'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsbuilderlegacy_votelegacyvote","text":"","title":"crypto.transactions.builder.legacy_vote.LegacyVote"},{"location":"sdk/python/crypto/api-documentation/#__init___12","text":"def __init__ ( self , vote = None , fee = None ): Create a new Legacy Vote transaction instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_41","text":"Type Name Required Description str vote No Delegate address to vote for int fee No Transaction fee","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_55","text":"<class 'solar_crypto.transactions.builder.legacy_vote.LegacyVote'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#set_votes","text":"def set_votes ( self , votes : typing . List [ str ]): Set legacy votes/cancel vote","title":"set_votes()"},{"location":"sdk/python/crypto/api-documentation/#parameters_42","text":"Type Name Required Description List[str] votes Yes list of votes","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_56","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#sign_3","text":"def sign ( self , passphrase ): Sign the transaction using the given passphrase","title":"sign()"},{"location":"sdk/python/crypto/api-documentation/#parameters_43","text":"Type Name Required Description str passphrase Yes Passphrase","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_57","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsbuildervotevote","text":"","title":"crypto.transactions.builder.vote.Vote"},{"location":"sdk/python/crypto/api-documentation/#__init___13","text":"def __init__ ( self ): Create a new Vote transaction instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#return-value_58","text":"<class 'solar_crypto.transactions.builder.vote.Vote'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#set_votes_1","text":"def set_votes ( self , votes : typing . Union [ typing . List [ str ], typing . Dict [ str , typing . Union [ int , float , Decimal ]]] = dict ): Set votes","title":"set_votes()"},{"location":"sdk/python/crypto/api-documentation/#parameters_44","text":"Type Name Required Description votes votes Yes list of votes","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_59","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializersbasebasedeserializer","text":"","title":"crypto.transactions.deserializers.base.BaseDeserializer"},{"location":"sdk/python/crypto/api-documentation/#__init___14","text":"def __init__ ( self , serialized , asset_offset , transaction ): Create a new deserializer instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_45","text":"Type Name Required Description ??? serialized Yes Serialized ??? asset_offset Yes Offset ??? transaction Yes Transaction","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_60","text":"<class 'solar_crypto.transactions.deserializers.base.BaseDeserializer'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#deserialize","text":"def deserialize ( self ): Handle the deserialization of transaction data","title":"deserialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_61","text":"NotImplementedError","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializersburnburndeserializer","text":"","title":"crypto.transactions.deserializers.burn.BurnDeserializer"},{"location":"sdk/python/crypto/api-documentation/#deserialize_1","text":"def deserialize ( self ): Handle the deserialization of \"burn\" data","title":"deserialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_62","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializersdelegate_registrationdelegateregistrationdeserializer","text":"","title":"crypto.transactions.deserializers.delegate_registration.DelegateRegistrationDeserializer"},{"location":"sdk/python/crypto/api-documentation/#deserialize_2","text":"def deserialize ( self ): Handle the deserialization of \"delegate registration\" data","title":"deserialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_63","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializersdelegate_resignationdelegateresignationdeserializer","text":"","title":"crypto.transactions.deserializers.delegate_resignation.DelegateResignationDeserializer"},{"location":"sdk/python/crypto/api-documentation/#deserialize_3","text":"def deserialize ( self ): Handle the deserialization of \"delegate resignation\" data","title":"deserialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_64","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializershtlc_claimhtlcclaimdeserializer","text":"","title":"crypto.transactions.deserializers.htlc_claim.HtlcClaimDeserializer"},{"location":"sdk/python/crypto/api-documentation/#deserialize_4","text":"def deserialize ( self ): Handle the deserialization of \"HTLC Claim\" data","title":"deserialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_65","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializershtlc_lockhtlclockdeserializer","text":"","title":"crypto.transactions.deserializers.htlc_lock.HtlcLockDeserializer"},{"location":"sdk/python/crypto/api-documentation/#deserialize_5","text":"def deserialize ( self ): Handle the deserialization of \"HTLC Lock\" data","title":"deserialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_66","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializershtlc_refundhtlcrefunddeserializer","text":"","title":"crypto.transactions.deserializers.htlc_refund.HtlcRefundDeserializer"},{"location":"sdk/python/crypto/api-documentation/#deserialize_6","text":"def deserialize ( self ): Handle the deserialization of \"HTLC refund\" data","title":"deserialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_67","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializersipfsipfsdeserializer","text":"","title":"crypto.transactions.deserializers.ipfs.IPFSDeserializer"},{"location":"sdk/python/crypto/api-documentation/#deserialize_7","text":"def deserialize ( self ): Handle the deserialization of \"IPFS\" data","title":"deserialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_68","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializerstransfertransferdeserializer","text":"","title":"crypto.transactions.deserializers.transfer.TransferDeserializer"},{"location":"sdk/python/crypto/api-documentation/#deserialize_8","text":"def deserialize ( self ): Handle the deserialization of \"transfer\" data","title":"deserialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_69","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializersmulti_signature_registrationmultisignatureregistrationdeserializer","text":"","title":"crypto.transactions.deserializers.multi_signature_registration.MultiSignatureRegistrationDeserializer"},{"location":"sdk/python/crypto/api-documentation/#deserialize_9","text":"def deserialize ( self ): Handle the deserialization of \"multi signature registration\" data","title":"deserialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_70","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializerssecond_signature_registrationsecondsignatureregistrationdeserializer","text":"","title":"crypto.transactions.deserializers.second_signature_registration.SecondSignatureRegistrationDeserializer"},{"location":"sdk/python/crypto/api-documentation/#deserialize_10","text":"def deserialize ( self ): Handle the deserialization of \"second signature\" data.","title":"deserialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_71","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializerslegacy_transferlegacytransferdeserializer","text":"","title":"crypto.transactions.deserializers.legacy_transfer.LegacyTransferDeserializer"},{"location":"sdk/python/crypto/api-documentation/#deserialize_11","text":"def deserialize ( self ): Handle the deserialization of \"legacy transfer\" data","title":"deserialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_72","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializerslegacy_votelegacyvotedeserializer","text":"","title":"crypto.transactions.deserializers.legacy_vote.LegacyVoteDeserializer"},{"location":"sdk/python/crypto/api-documentation/#deserialize_12","text":"def deserialize ( self ): Handle the deserialization of \"legacy vote\" data.","title":"deserialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_73","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializersvotevotedeserializer","text":"","title":"crypto.transactions.deserializers.vote.VoteDeserializer"},{"location":"sdk/python/crypto/api-documentation/#deserialize_13","text":"def deserialize ( self ): Handle the deserialization of \"vote\" data.","title":"deserialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_74","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializersbasebaseserializer","text":"","title":"crypto.transactions.serializers.base.BaseSerializer"},{"location":"sdk/python/crypto/api-documentation/#__init___15","text":"def __init__ ( self , transaction , byte_data = bytes ()): Create a new serializer instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_46","text":"Type Name Required Description Transaction transaction Yes Transaction bytes byte_data No ...","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_75","text":"<class 'solar_crypto.transactions.serializers.base.BaseSerializer'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#serialize","text":"def serialize ( self ): Handle the serialization of transaction data","title":"serialize"},{"location":"sdk/python/crypto/api-documentation/#return-value_76","text":"NotImplementedError","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializersburnburnserializer","text":"","title":"crypto.transactions.serializers.burn.BurnSerializer"},{"location":"sdk/python/crypto/api-documentation/#serialize_1","text":"def serialize ( self ): Handle the serialization of \"burn\" data","title":"serialize"},{"location":"sdk/python/crypto/api-documentation/#return-value_77","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializersdelegate_registrationdelegateregistrationserializer","text":"","title":"crypto.transactions.serializers.delegate_registration.DelegateRegistrationSerializer"},{"location":"sdk/python/crypto/api-documentation/#serialize_2","text":"def serialize ( self ): Handle the serialization of \"delegate registration\" data","title":"serialize"},{"location":"sdk/python/crypto/api-documentation/#return-value_78","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializersdelegate_resignationdelegateresignationserializer","text":"","title":"crypto.transactions.serializers.delegate_resignationDelegateResignationSerializer"},{"location":"sdk/python/crypto/api-documentation/#serialize_3","text":"def serialize ( self ): Handle the serialization of \"delegate resignation\" data","title":"serialize"},{"location":"sdk/python/crypto/api-documentation/#return-value_79","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializershtlc_claimhtlcclaimserializer","text":"","title":"crypto.transactions.serializers.htlc_claim.HtlcClaimSerializer"},{"location":"sdk/python/crypto/api-documentation/#serialize_4","text":"def serialize ( self ): Handle the serialization of \"HTLC Claim\" data","title":"serialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_80","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializershtlc_lockhtlclockserializer","text":"","title":"crypto.transactions.serializers.htlc_lock.HtlcLockSerializer"},{"location":"sdk/python/crypto/api-documentation/#serialize_5","text":"def serialize ( self ): Handle the serialization of \"HTLC Lock\" data","title":"serialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_81","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializershtlc_refundhtlcrefundserializer","text":"","title":"crypto.transactions.serializers.htlc_refund.HtlcRefundSerializer"},{"location":"sdk/python/crypto/api-documentation/#serialize_6","text":"def serialize ( self ): Handle the serialization of \"HTLC Refund\" data","title":"serialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_82","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializersipfsipfsserializer","text":"","title":"crypto.transactions.serializers.ipfs.IPFSSerializer"},{"location":"sdk/python/crypto/api-documentation/#serialize_7","text":"def serialize ( self ): Handle the serialization of \"ipfs\" data","title":"serialize"},{"location":"sdk/python/crypto/api-documentation/#return-value_83","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializerstransfertransferserializer","text":"","title":"crypto.transactions.serializers.transfer.TransferSerializer"},{"location":"sdk/python/crypto/api-documentation/#serialize_8","text":"def serialize ( self ): Handle the serialization of \"transfer\" data","title":"serialize"},{"location":"sdk/python/crypto/api-documentation/#return-value_84","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializersmulti_signature_registrationmultisignatureserializer","text":"","title":"crypto.transactions.serializers.multi_signature_registration.MultiSignatureSerializer"},{"location":"sdk/python/crypto/api-documentation/#serialize_9","text":"def serialize ( self ): Handle the serialization of \"multi signature\" data","title":"serialize"},{"location":"sdk/python/crypto/api-documentation/#return-value_85","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializerssecond_signature_registrationsecondsignatureregistrationserializer","text":"","title":"crypto.transactions.serializers.second_signature_registration.SecondSignatureRegistrationSerializer"},{"location":"sdk/python/crypto/api-documentation/#serialize_10","text":"def serialize ( self ): Handle the serialization of \"second signature\" data","title":"serialize"},{"location":"sdk/python/crypto/api-documentation/#return-value_86","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializerslegacy_transferlegacytransferserializer","text":"","title":"crypto.transactions.serializers.legacy_transfer.LegacyTransferSerializer"},{"location":"sdk/python/crypto/api-documentation/#serialize_11","text":"def serialize ( self ): Handle the serialization of \"legacy transfer\" data","title":"serialize"},{"location":"sdk/python/crypto/api-documentation/#return-value_87","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializerslegacy_votelegacyvoteserializer","text":"","title":"crypto.transactions.serializers.legacy_vote.LegacyVoteSerializer"},{"location":"sdk/python/crypto/api-documentation/#serialize_12","text":"def serialize ( self ): Handle the serialization of \"legacy vote\" data","title":"serialize"},{"location":"sdk/python/crypto/api-documentation/#return-value_88","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializersvotevoteserializer","text":"","title":"crypto.transactions.serializers.vote.VoteSerializer"},{"location":"sdk/python/crypto/api-documentation/#serialize_13","text":"def serialize ( self ): Handle the serialization of \"vote\" data","title":"serialize"},{"location":"sdk/python/crypto/api-documentation/#return-value_89","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializerdeserializer","text":"","title":"crypto.transactions.deserializer.Deserializer"},{"location":"sdk/python/crypto/api-documentation/#__init___16","text":"def __init__ ( self , serialized ): Create a new deserializer instance","title":"__init__"},{"location":"sdk/python/crypto/api-documentation/#parameters_47","text":"Type Name Required Description str serialized Yes Serialized","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_90","text":"<class 'solar_crypto.transactions.deserializer.Deserializer'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#deserialize_14","text":"def deserialize ( self ): Perform AIP11 compliant deserialization","title":"deserialize"},{"location":"sdk/python/crypto/api-documentation/#return-value_91","text":"<class 'solar_crypto.transactions.transaction.Transaction'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#_handle_transaction_type","text":"def _handle_transaction_type ( self , asset_offset , transaction ): Handle the deserialization of transaction data","title":"_handle_transaction_type"},{"location":"sdk/python/crypto/api-documentation/#parameters_48","text":"Type Name Required Description int asset_offset Yes Offset transaction.Transaction transaction Yes Transaction","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_92","text":"<class 'solar_crypto.transactions.transaction.Transaction'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializerserializer","text":"","title":"crypto.transactions.serializer.Serializer"},{"location":"sdk/python/crypto/api-documentation/#__init___17","text":"def __init__ ( self , transaction ): Create a new serializer instance","title":"__init__"},{"location":"sdk/python/crypto/api-documentation/#parameters_49","text":"Type Name Required Description transaction.Transaction transaction Yes Transaction","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_93","text":"<class 'solar_crypto.transactions.serializer.Serializer'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#serialize_14","text":"def serialize ( self , skip_signature = True , skip_second_signature = True , skip_multi_signature = True , raw = False ): Perform AIP11 compliant serialization","title":"serialize"},{"location":"sdk/python/crypto/api-documentation/#parameters_50","text":"Type Name Required Description bool skip_signature No Should we skip the serialization of the signature bool skip_second_signature No Should we skip the serialization of the second signature bool skip_multi_signature No Should we skip the serialization of multiple signatures bool raw No Raw output","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_94","text":"<class 'str'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#_handle_transaction_type_1","text":"def _handle_transaction_type ( self , bytes_data ): Handle the serialization of transaction data","title":"_handle_transaction_type"},{"location":"sdk/python/crypto/api-documentation/#parameters_51","text":"Type Name Required Description bytes bytes_data Yes ...","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_95","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#_handle_signature","text":"def _handle_signature ( self , bytes_data , skip_signature , skip_second_signature , skip_multi_signature ): Handle the serialization of \"signatures\" data","title":"_handle_signature"},{"location":"sdk/python/crypto/api-documentation/#parameters_52","text":"Type Name Required Description bytes bytes_data Yes ... bool skip_signature Yes Should we skip the serialization of the signature bool skip_second_signature Yes Should we skip the serialization of the second signature bool skip_multi_signature Yes Should we skip the serialization of multiple signatures","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_96","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionstransactiontransaction","text":"","title":"crypto.transactions.transaction.Transaction"},{"location":"sdk/python/crypto/api-documentation/#__init___18","text":"def __init__ ( self , * args , ** kwargs ): Create a new transaction instance","title":"__init__"},{"location":"sdk/python/crypto/api-documentation/#parameters_53","text":"Type Name Required Description any *args No ... any **kwargs No ...","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_97","text":"<class 'solar_crypto.transactions.transaction.Transaction'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#get_id","text":"def get_id ( self ): Convert the byte representation to a unique identifier","title":"get_id"},{"location":"sdk/python/crypto/api-documentation/#return-value_98","text":"<class 'str'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#to_dict_1","text":"def to_dict ( self ): Convert the transaction to its dictionary representation.","title":"to_dict"},{"location":"sdk/python/crypto/api-documentation/#return-value_99","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#to_json_1","text":"def to_json ( self ): Convert the transaction to its JSON representation","title":"to_json"},{"location":"sdk/python/crypto/api-documentation/#return-value_100","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#to_bytes","text":"def to_bytes ( self , skip_signature = True , skip_second_signature = True , skip_multi_signature = True ): Convert the transaction to its byte representation","title":"to_bytes"},{"location":"sdk/python/crypto/api-documentation/#parameters_54","text":"Type Name Required Description bool skip_signature Yes Skip first signature bool skip_second_signature Yes Skip second signature bool skip_multi_signature Yes Skip multi signatures","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_101","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#parse_signatures","text":"def parse_signatures ( self , serialized , start_offset ): Parse the signature, second signature and multi signatures","title":"parse_signatures"},{"location":"sdk/python/crypto/api-documentation/#parameters_55","text":"Type Name Required Description str serialized Yes Serialized int start_offset Yes Offset","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_102","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#serialize_15","text":"def serialize ( self , skip_signature = True , skip_second_signature = True , skip_multi_signature = True ): Perform AIP11 compliant serialization","title":"serialize"},{"location":"sdk/python/crypto/api-documentation/#parameters_56","text":"Type Name Required Description bool skip_signature Yes Skip first signature bool skip_second_signature Yes Skip second signature bool skip_multi_signature Yes Skip multi signatures","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_103","text":"<class 'str'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#deserialize_15","text":"def deserialize ( self , serialized ): Perform AIP11 compliant deserialization","title":"deserialize"},{"location":"sdk/python/crypto/api-documentation/#parameters_57","text":"Type Name Required Description str serialized Yes Serialized","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_104","text":"<class 'str'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#verify_1","text":"def verify ( self ): Verify the transaction. Method will raise an exception if invalid, if it's valid it will returns True","title":"verify"},{"location":"sdk/python/crypto/api-documentation/#return-value_105","text":"<class 'bool'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#verify_secondsig","text":"def verify_secondsig ( self , secondPublicKey ): Verify the second signature. Method will raise an exception if invalid, if it's valid it will returns True","title":"verify_secondsig"},{"location":"sdk/python/crypto/api-documentation/#parameters_58","text":"Type Name Required Description str secondPublicKey Yes Second public key","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_106","text":"<class 'bool'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#verify_signatures","text":"def verify_signatures ( self , multi_signature_asset ): Verify the multisignatures transaction. Method will raise an exception if invalid, it will returns True","title":"verify_signatures"},{"location":"sdk/python/crypto/api-documentation/#parameters_59","text":"Type Name Required Description dict multi_signature_asset Yes Multisignature asset","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_107","text":"<class 'bool'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#_handle_transaction_type_2","text":"def _handle_transaction_type ( self , bytes_data ): Handle each transaction type differently","title":"_handle_transaction_type"},{"location":"sdk/python/crypto/api-documentation/#parameters_60","text":"Type Name Required Description bytes bytes_data Yes Input the bytes data to which you want to append new bytes","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_108","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#_handle_signature_1","text":"def _handle_signature ( self , bytes_data , skip_signature , skip_second_signature , skip_multi_signature ): Handle the serialization of \"signatures\" data","title":"_handle_signature"},{"location":"sdk/python/crypto/api-documentation/#parameters_61","text":"Type Name Required Description bytes bytes_data Yes Input the bytes data to which you want to append new bytes from signature bool skip_signature Yes Skip first signature bool skip_second_signature Yes Skip second signature bool skip_multi_signature Yes Skip multi signatures","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_109","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptoutilscrypto","text":"","title":"crypto.utils.crypto"},{"location":"sdk/python/crypto/api-documentation/#sign_schnorr","text":"def sign_schnorr ( msg : bytes , private_key : PrivateKey , nonce : int = None ) -> str : Signs a message using Schnorr BIP340 and returns a hex string of the signature","title":"sign_schnorr"},{"location":"sdk/python/crypto/api-documentation/#parameters_62","text":"Type Name Required Description bytes msg Yes Message to be signed PrivateKey private_key Yes Private key object int nonce No Deterministic nonce","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_110","text":"<class 'str'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#sign_schnorr_legacy","text":"def sign_schnorr_legacy ( msg : bytes , private_key : PrivateKey ) -> str : Signs a message using Legacy Schnorr and returns a hex string of the signature","title":"sign_schnorr_legacy"},{"location":"sdk/python/crypto/api-documentation/#parameters_63","text":"Type Name Required Description bytes msg Yes Message to be signed PrivateKey private_key Yes Private key object int nonce No Deterministic nonce","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_111","text":"<class 'str'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#verify_schnorr","text":"def verify_schnorr ( msg : bytes , public_key : str , signature : str ) -> bool : Verifies a message using Schnorr BIP340","title":"verify_schnorr"},{"location":"sdk/python/crypto/api-documentation/#parameters_64","text":"Type Name Required Description bytes msg Yes Message to be verified str public_key Yes Public key str signature Yes Signature","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_112","text":"<class 'bool'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#verify_schnorr_legacy","text":"def verify_schnorr_legacy ( msg : bytes , public_key : str , signature : str ) -> bool : Verifies a message using Legacy Schnorr","title":"verify_schnorr_legacy"},{"location":"sdk/python/crypto/api-documentation/#parameters_65","text":"Type Name Required Description bytes msg Yes Message to be verified str public_key Yes Public key str signature Yes Signature","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_113","text":"<class 'bool'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptoutilsmessagemessage","text":"","title":"crypto.utils.message.Message"},{"location":"sdk/python/crypto/api-documentation/#__init___19","text":"def __init__ ( self , ** kwargs ): Create a new message instance","title":"__init__"},{"location":"sdk/python/crypto/api-documentation/#parameters_66","text":"Type Name Required Description any **kwargs No ...","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_114","text":"<class 'solar_crypto.utils.message.Message'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#sign_4","text":"def sign ( cls , message , passphrase ): Sign a message using the given passphrase","title":"sign"},{"location":"sdk/python/crypto/api-documentation/#parameters_67","text":"Type Name Required Description str message Yes Message str passphrase Yes Passphrase","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_115","text":"<class 'solar_crypto.utils.message.Message'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#verify_2","text":"def verify ( self ): Verify the message contents","title":"verify"},{"location":"sdk/python/crypto/api-documentation/#return-value_116","text":"<class 'bool'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#to_dict_2","text":"def to_dict ( self ): Convert the message to its dictionary representation","title":"to_dict"},{"location":"sdk/python/crypto/api-documentation/#return-value_117","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#to_json_2","text":"def to_json ( self ): Convert the message to its JSON representation","title":"to_json"},{"location":"sdk/python/crypto/api-documentation/#return-value_118","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptoutilsslot","text":"","title":"crypto.utils.slot"},{"location":"sdk/python/crypto/api-documentation/#get_time","text":"def get_time (): Get the time diff between now and network start","title":"get_time"},{"location":"sdk/python/crypto/api-documentation/#return-value_119","text":"<class 'int'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#get_epoch","text":"def get_epoch (): Get the network start epoch","title":"get_epoch"},{"location":"sdk/python/crypto/api-documentation/#return-value_120","text":"<class 'datetime'>","title":"Return Value"},{"location":"sdk/python/crypto/examples/","text":"Examples \u00b6 Initialization \u00b6 from solar_crypto.transactions.builder.transfer import Transfer The transaction object used for this section: tx = { 'amount' : int , 'asset' : dict , 'fee' : int , 'id' : str , 'network' : int , 'recipientId' : str , 'secondSignature' : str , 'senderPublicKey' : str , 'signature' : str , 'signatures' : list , 'signSignature' : str , 'nonce' : int , 'type' : int , 'typeGroup' : int , 'memo' : str , 'version' : int , 'lockTransactionId' : str , 'lockSecret' : str , 'expiration' : int , } Transactions \u00b6 A transaction is an object specifying the transfer of funds from the sender's wallet to the recipient's. Each transaction must be signed by the sender's private key to prove authenticity and origin. After broadcasting through the client SDK , a transaction is permanently incorporated in the blockchain by a Delegate Node. Sign \u00b6 The crypto SDK can sign a transaction using your private key or passphrase (from which the private key is generated). Ensure you are familiar with digital signatures before using the crypto SDKs. For serializing and deserializing, we must require the Transaction model: from solar_crypto.transactions.transaction import Transaction # Serializing transaction = Transaction ( ** tx ) transaction . serialize () # Deserializing transaction = Transaction () transaction . deserialize ( ** tx [ 'serialized' ]) Using the Transaction builder class. transaction = Transfer ( recipientId = str , amount = int ) transaction . sign ( 'seedPass' ) Serialize (AIP11) \u00b6 Serialization of a transaction object ensures it is compact and properly formatted to be incorporated in the SXP blockchain. If you are using the crypto SDK in combination with the public API SDK, you should not need to serialize manually. from solar_crypto.transactions.serializer import Serializer serialized_transaction = Serializer ( tx ) . serialize () >>> < class ' str '> Deserialize (AIP11) \u00b6 A serialized transaction may be deserialized for inspection purposes. The public API does not return serialized transactions, so you should only need to deserialize in exceptional circumstances. from solar_crypto.transactions.deserializer import Deserializer transaction_data = Deserializer ( serialized_data ) . deserialize () >>> < class ' solar_crypto . transactions . transaction . Transaction '> Message \u00b6 The crypto SDK not only supports transactions but can also work with other arbitrary data (expressed as strings). Sign \u00b6 Signing a string works much like signing a transaction: in most implementations, the message is hashed, and the resulting hash is signed using the private key or passphrase . from solar_crypto.utils.message import Message message = Message . sign ( string , 'validSeedPass' ) >>> < class ' solar_crypto . utils . message . Message '> Verify \u00b6 A message's signature can easily be verified by hash, without the private key that signed the message, by using the verify method. from solar_crypto.utils.message import Message message = Message ( message = str , signature = str , publicKey = str ) message . verify () >>> < class ' bool '> Identities \u00b6 The identities class allows for the creation and inspection of keyPairs from passphrases . Here you find vital functions when creating transactions and managing wallets. Derive the Address from a Passphrase \u00b6 from solar_crypto.identity.address import address_from_passphrase address_from_passphrase ( 'validSeedPass' ) >>> < class ' str '> Derive the Address from a Public Key \u00b6 from solar_crypto.identity.address import address_from_public_key address_from_public_key ( 'validPublicKey' ) >>> < class ' str '> Derive the Address from a Private Key \u00b6 from solar_crypto.identity.address import address_from_private_key address_from_private_key ( 'validPrivateKey' ) >>> < class ' str '> Validate an Address \u00b6 from solar_crypto.identity.address import validate_address validate_address ( 'validAddress' ) >>> < class ' bool '> Private Key \u00b6 As the name implies, private keys and passphrases are to remain private. Never store these unencrypted and minimize access to these secrets Derive the Private Key from a Passphrase \u00b6 from solar_crypto.identity.private_key import PrivateKey private_key = PrivateKey . from_passphrase ( 'validSeedPass' ) . to_hex () >>> < class ' str '> Derive the Private Key Instance Object from a Hexadecimal Encoded String \u00b6 from solar_crypto.identity.private_key import PrivateKey private_key = PrivateKey . from_hex ( str ) >>> < class ' solar_crypto . identity . private_key . PrivateKey '> Derive the Private Key from a WIF \u00b6 This function has not been implemented in this client library . Public Key \u00b6 Public Keys may be freely shared, and are included in transaction objects to validate the authenticity. Derive the Public Key from a Passphrase \u00b6 from solar_crypto.identity.public_key import PublicKey public_key = PublicKey . from_passphrase ( 'this is a top secret passphrase' ) >>> < class ' str '> Derive the Public Key Instance Object from a Hexadecimal Encoded String \u00b6 from solar_crypto.identity.public_key import PublicKey public_key = PublicKey . from_hex ( str ) >>> < class ' solar_crypto . identity . public_key . PublicKey '> Validate a Public Key \u00b6 This function has not been implemented in this client library . WIF \u00b6 The WIF should remain secret, just like your passphrase and private key . Derive the WIF from a Passphrase \u00b6 from solar_crypto.identity.wif import wif_from_passphrase wif = wif_from_passphrase ( 'validSeedPass' ) >>> < class ' str '>","title":"Examples"},{"location":"sdk/python/crypto/examples/#examples","text":"","title":"Examples"},{"location":"sdk/python/crypto/examples/#initialization","text":"from solar_crypto.transactions.builder.transfer import Transfer The transaction object used for this section: tx = { 'amount' : int , 'asset' : dict , 'fee' : int , 'id' : str , 'network' : int , 'recipientId' : str , 'secondSignature' : str , 'senderPublicKey' : str , 'signature' : str , 'signatures' : list , 'signSignature' : str , 'nonce' : int , 'type' : int , 'typeGroup' : int , 'memo' : str , 'version' : int , 'lockTransactionId' : str , 'lockSecret' : str , 'expiration' : int , }","title":"Initialization"},{"location":"sdk/python/crypto/examples/#transactions","text":"A transaction is an object specifying the transfer of funds from the sender's wallet to the recipient's. Each transaction must be signed by the sender's private key to prove authenticity and origin. After broadcasting through the client SDK , a transaction is permanently incorporated in the blockchain by a Delegate Node.","title":"Transactions"},{"location":"sdk/python/crypto/examples/#sign","text":"The crypto SDK can sign a transaction using your private key or passphrase (from which the private key is generated). Ensure you are familiar with digital signatures before using the crypto SDKs. For serializing and deserializing, we must require the Transaction model: from solar_crypto.transactions.transaction import Transaction # Serializing transaction = Transaction ( ** tx ) transaction . serialize () # Deserializing transaction = Transaction () transaction . deserialize ( ** tx [ 'serialized' ]) Using the Transaction builder class. transaction = Transfer ( recipientId = str , amount = int ) transaction . sign ( 'seedPass' )","title":"Sign"},{"location":"sdk/python/crypto/examples/#serialize-aip11","text":"Serialization of a transaction object ensures it is compact and properly formatted to be incorporated in the SXP blockchain. If you are using the crypto SDK in combination with the public API SDK, you should not need to serialize manually. from solar_crypto.transactions.serializer import Serializer serialized_transaction = Serializer ( tx ) . serialize () >>> < class ' str '>","title":"Serialize (AIP11)"},{"location":"sdk/python/crypto/examples/#deserialize-aip11","text":"A serialized transaction may be deserialized for inspection purposes. The public API does not return serialized transactions, so you should only need to deserialize in exceptional circumstances. from solar_crypto.transactions.deserializer import Deserializer transaction_data = Deserializer ( serialized_data ) . deserialize () >>> < class ' solar_crypto . transactions . transaction . Transaction '>","title":"Deserialize (AIP11)"},{"location":"sdk/python/crypto/examples/#message","text":"The crypto SDK not only supports transactions but can also work with other arbitrary data (expressed as strings).","title":"Message"},{"location":"sdk/python/crypto/examples/#sign_1","text":"Signing a string works much like signing a transaction: in most implementations, the message is hashed, and the resulting hash is signed using the private key or passphrase . from solar_crypto.utils.message import Message message = Message . sign ( string , 'validSeedPass' ) >>> < class ' solar_crypto . utils . message . Message '>","title":"Sign"},{"location":"sdk/python/crypto/examples/#verify","text":"A message's signature can easily be verified by hash, without the private key that signed the message, by using the verify method. from solar_crypto.utils.message import Message message = Message ( message = str , signature = str , publicKey = str ) message . verify () >>> < class ' bool '>","title":"Verify"},{"location":"sdk/python/crypto/examples/#identities","text":"The identities class allows for the creation and inspection of keyPairs from passphrases . Here you find vital functions when creating transactions and managing wallets.","title":"Identities"},{"location":"sdk/python/crypto/examples/#derive-the-address-from-a-passphrase","text":"from solar_crypto.identity.address import address_from_passphrase address_from_passphrase ( 'validSeedPass' ) >>> < class ' str '>","title":"Derive the Address from a Passphrase"},{"location":"sdk/python/crypto/examples/#derive-the-address-from-a-public-key","text":"from solar_crypto.identity.address import address_from_public_key address_from_public_key ( 'validPublicKey' ) >>> < class ' str '>","title":"Derive the Address from a Public Key"},{"location":"sdk/python/crypto/examples/#derive-the-address-from-a-private-key","text":"from solar_crypto.identity.address import address_from_private_key address_from_private_key ( 'validPrivateKey' ) >>> < class ' str '>","title":"Derive the Address from a Private Key"},{"location":"sdk/python/crypto/examples/#validate-an-address","text":"from solar_crypto.identity.address import validate_address validate_address ( 'validAddress' ) >>> < class ' bool '>","title":"Validate an Address"},{"location":"sdk/python/crypto/examples/#private-key","text":"As the name implies, private keys and passphrases are to remain private. Never store these unencrypted and minimize access to these secrets","title":"Private Key"},{"location":"sdk/python/crypto/examples/#derive-the-private-key-from-a-passphrase","text":"from solar_crypto.identity.private_key import PrivateKey private_key = PrivateKey . from_passphrase ( 'validSeedPass' ) . to_hex () >>> < class ' str '>","title":"Derive the Private Key from a Passphrase"},{"location":"sdk/python/crypto/examples/#derive-the-private-key-instance-object-from-a-hexadecimal-encoded-string","text":"from solar_crypto.identity.private_key import PrivateKey private_key = PrivateKey . from_hex ( str ) >>> < class ' solar_crypto . identity . private_key . PrivateKey '>","title":"Derive the Private Key Instance Object from a Hexadecimal Encoded String"},{"location":"sdk/python/crypto/examples/#derive-the-private-key-from-a-wif","text":"This function has not been implemented in this client library .","title":"Derive the Private Key from a WIF"},{"location":"sdk/python/crypto/examples/#public-key","text":"Public Keys may be freely shared, and are included in transaction objects to validate the authenticity.","title":"Public Key"},{"location":"sdk/python/crypto/examples/#derive-the-public-key-from-a-passphrase","text":"from solar_crypto.identity.public_key import PublicKey public_key = PublicKey . from_passphrase ( 'this is a top secret passphrase' ) >>> < class ' str '>","title":"Derive the Public Key from a Passphrase"},{"location":"sdk/python/crypto/examples/#derive-the-public-key-instance-object-from-a-hexadecimal-encoded-string","text":"from solar_crypto.identity.public_key import PublicKey public_key = PublicKey . from_hex ( str ) >>> < class ' solar_crypto . identity . public_key . PublicKey '>","title":"Derive the Public Key Instance Object from a Hexadecimal Encoded String"},{"location":"sdk/python/crypto/examples/#validate-a-public-key","text":"This function has not been implemented in this client library .","title":"Validate a Public Key"},{"location":"sdk/python/crypto/examples/#wif","text":"The WIF should remain secret, just like your passphrase and private key .","title":"WIF"},{"location":"sdk/python/crypto/examples/#derive-the-wif-from-a-passphrase","text":"from solar_crypto.identity.wif import wif_from_passphrase wif = wif_from_passphrase ( 'validSeedPass' ) >>> < class ' str '>","title":"Derive the WIF from a Passphrase"},{"location":"sdk/python/crypto/intro/","text":"Crypto \u00b6 Development \u00b6 Fork the package . Clone your forked repository. git clone https://github.com/<githubusername>/python-crypto Next, move into the cloned directory. cd python-crypto The next step would be to create something like a virtual environment and install the dependencies of this package inside it. Create and enter the virtual environment # With virtualenv (on Unix and OSx) mkdir my-amazing-solar-project cd my-amazing-solar-project virtualenv virtualEnvName source venv/bin/activate # With virtualenv (on Windows) mkdir my-amazing-solar-project cd my-amazing-solar-project virtualenv virtualEnvName . \\v env \\S cripts \\a ctivate.bat Once inside the virtualenv, you can proceed to install dependencies. python -m pip install -e . \"[dev]\" Dependencies are now installed, you can now run the tests to see if everything is running as it should. pytest","title":"Getting Started"},{"location":"sdk/python/crypto/intro/#crypto","text":"","title":"Crypto"},{"location":"sdk/python/crypto/intro/#development","text":"Fork the package . Clone your forked repository. git clone https://github.com/<githubusername>/python-crypto Next, move into the cloned directory. cd python-crypto The next step would be to create something like a virtual environment and install the dependencies of this package inside it. Create and enter the virtual environment # With virtualenv (on Unix and OSx) mkdir my-amazing-solar-project cd my-amazing-solar-project virtualenv virtualEnvName source venv/bin/activate # With virtualenv (on Windows) mkdir my-amazing-solar-project cd my-amazing-solar-project virtualenv virtualEnvName . \\v env \\S cripts \\a ctivate.bat Once inside the virtualenv, you can proceed to install dependencies. python -m pip install -e . \"[dev]\" Dependencies are now installed, you can now run the tests to see if everything is running as it should. pytest","title":"Development"},{"location":"sdk/typescript/complementary-examples/","text":"Complementary Examples \u00b6 Prerequisites \u00b6 Before we get started we need to make sure that all of the required dependencies are installed. These dependencies are the Crypto SDK and Client SDK . You can head on over to their documentations to read more about them but for now we are only concerned with installing them to get up and running. Open your project and execute the following commands to install both SDKs. Make sure that those complete without any errors. If you encounter any errors, please open an issue with as much information as you can provide so that our developers can have a look and get to the bottom of the issue. yarn \u00b6 yarn add @solar-network/crypto yarn add @solar-network/client pnpm \u00b6 pnpm add @solar-network/crypto pnpm add @solar-network/client npm \u00b6 npm install @solar-network/crypto npm install @solar-network/client Now that we're setup and ready to go we'll look into some examples for the most common tasks you'll encounter when wanting to interact with the SXP Blockchain. Persisting your transaction on the blockchain \u00b6 The process of getting your transaction verified and persisted on the SXP Blockchain involves a few steps with which our SDKs will help you but lets break them down to get a better idea of what is happening. Install the Client SDK and configure it to use a node of your choosing to broadcast your transactions to. Always make sure that you have a fallback node that you can use for broadcasting in case your primary node goes offline or acts strange otherwise. Install the Crypto SDK and configure it to match the configuration of the network. This is the most important part as misconfiguration can lead to a myriad of issues as Core will reject your transactions. Retrieve the nonce of the sender wallet and increase it by 1. You can read about what a sequential nonce is and why it is important here . Create an instance of the builder for the type of transaction you want to create. This is the step where we actually create a transaction and sign it so that the SXP Blockchain can later on verify it and decide if it will be accepted, forged and finally. You can read the relevant API documentation if you want more detailed information about the design and usage. Turn the newly created transaction into JSON and broadcast it to the network through the Client SDK. You can read the relevant API documentation if you want more detailed information about the design and usage. Process the API response and verify that your transaction was accepted. If the network rejects your transaction you'll receive the reason as to why that is the case in the response which might mean that you need to create a new transaction and broadcast it. Troubleshooting \u00b6 A common issue when trying to get your transaction onto the blockchain is that you'll receive an error to the effect of Transaction Version 2 is not supported which indicates that your Crypto SDK configuration might be wrong. The solution to this is to make sure that your Crypto SDK instance is properly configured. This includes both the network preset and the height it's configured to assume the network has passed, if any of those don't match up you'll encounter the aforementioned issue with the version of your transactions. Mainnet \u00b6 Managers . configManager . setFromPreset ( \"mainnet\" ); Managers . configManager . setHeight ( 11273000 ); Testnet \u00b6 Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 4006000 ); Creating and Broadcasting a Transfer \u00b6 const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://sxp.testnet.sh/api\" ); // Ensure AIP11 is enabled for the Crypto SDK Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 4006000 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . transfer () . version ( 2 ) . nonce ( senderNonce . toFixed ()) . recipientId ( \"Address of Recipient\" ) . amount ( 1 * 1e8 ) . vendorField ( \"Hello World\" ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); The vendorField is optional and limited to a length of 255 characters. It can be a good idea to add a vendor field to your transactions if you want to be able to easily track them in the future. Creating and Broadcasting a Second Signature \u00b6 const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://sxp.testnet.sh/api\" ); // Ensure AIP11 is enabled for the Crypto SDK Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 4006000 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . secondSignature () . version ( 2 ) . nonce ( senderNonce . toFixed ()) . signatureAsset ( \"this is a top secret second passphrase\" ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); Creating and Broadcasting a Delegate Registration \u00b6 const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://sxp.testnet.sh/api\" ); // Ensure AIP11 is enabled for the Crypto SDK Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 4006000 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . delegateRegistration () . version ( 2 ) . nonce ( senderNonce . toFixed ()) . usernameAsset ( \"johndoe\" ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); Creating and Broadcasting a Vote \u00b6 const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://sxp.testnet.sh/api\" ); // Ensure AIP11 is enabled for the Crypto SDK Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 4006000 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . vote () . version ( 2 ) . nonce ( senderNonce . toFixed ()) . votesAsset ([ \"+public_key_of_a_delegate_wallet\" ]) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); Note the plus prefix for the public key that is passed to the votesAsset function. This prefix denotes that this is a transaction to remove a vote from the given delegate. Creating and Broadcasting an Unvote \u00b6 const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://sxp.testnet.sh/api\" ); // Ensure AIP11 is enabled for the Crypto SDK Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 4006000 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . vote () . version ( 2 ) . nonce ( senderNonce . toFixed ()) . votesAsset ([ \"-public_key_of_a_delegate_wallet\" ]) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); Note the minus prefix for the public key that is passed to the votesAsset function. This prefix denotes that this is a transaction to add a vote to the given delegate. Creating and Broadcasting a Multi Signature \u00b6 const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://sxp.testnet.sh/api\" ); // Ensure AIP11 is enabled for the Crypto SDK Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 4006000 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . multiSignature () . version ( 2 ) . nonce ( senderNonce . toFixed ()) . multiSignatureAsset ({ publicKeys : [ \"039180ea4a8a803ee11ecb462bb8f9613fcdb5fe917e292dbcc73409f0e98f8f22\" , \"028d3611c4f32feca3e6713992ae9387e18a0e01954046511878fe078703324dc0\" , \"021d3932ab673230486d0f956d05b9e88791ee298d9af2d6df7d9ed5bb861c92dd\" , ], min : 2 , }) . senderPublicKey ( \"039180ea4a8a803ee11ecb462bb8f9613fcdb5fe917e292dbcc73409f0e98f8f22\" ) . multiSign ( \"this is a top secret passphrase 1\" , 0 ) . multiSign ( \"this is a top secret passphrase 2\" , 1 ) . multiSign ( \"this is a top secret passphrase 3\" , 2 ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); Creating and Broadcasting a IPFS \u00b6 const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://sxp.testnet.sh/api\" ); // Ensure AIP11 is enabled for the Crypto SDK Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 4006000 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . ipfs () . version ( 2 ) . nonce ( senderNonce . toFixed ()) . ipfsAsset ( \"QmR45FmbVVrixReBwJkhEKde2qwHYaQzGxu4ZoDeswuF9w\" ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); Creating and Broadcasting a Multi Payment \u00b6 const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://sxp.testnet.sh/api\" ); // Ensure AIP11 is enabled for the Crypto SDK Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 4006000 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . multiPayment () . version ( 2 ) . nonce ( senderNonce . toFixed ()) . addPayment ( \"Address of Recipient Wallet 1\" , 1 * 1e8 ) . addPayment ( \"Address of Recipient Wallet 2\" , 1 * 1e8 ) . addPayment ( \"Address of Recipient Wallet 3\" , 1 * 1e8 ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); Creating and Broadcasting a Delegate Resignation \u00b6 const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://sxp.testnet.sh/api\" ); // Ensure AIP11 is enabled for the Crypto SDK Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 4006000 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . delegateResignation () . version ( 2 ) . nonce ( senderNonce . toFixed ()) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); A delegate resignation has to be sent from the delegate wallet itself to verify its identity. Creating and Broadcasting a HTLC Lock \u00b6 const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://sxp.testnet.sh/api\" ); // Ensure AIP11 is enabled for the Crypto SDK Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 4006000 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . htlcLock () . version ( 2 ) . nonce ( senderNonce . toFixed ()) . htlcLockAsset ({ secretHash : \"0f128d401958b1b30ad0d10406f47f9489321017b4614e6cb993fc63913c5454\" , expiration : { type : 1 , value : Math.floor ( Date . now () / 1000 ), }, }) . amount ( 1 * 1e8 ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); Creating and Broadcasting a HTLC Claim \u00b6 const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://sxp.testnet.sh/api\" ); // Ensure AIP11 is enabled for the Crypto SDK Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 4006000 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . htlcClaim () . version ( 2 ) . nonce ( senderNonce . toFixed ()) . htlcClaimAsset ({ lockTransactionId : \"943c220691e711c39c79d437ce185748a0018940e1a4144293af9d05627d2eb4\" , unlockSecret : \"c27f1ce845d8c29eebc9006be932b604fd06755521b1a8b0be4204c65377151a\" , }) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); The unlockSecret has to be a SHA256 hash of the plain text secret that you shared with the person that is allowed to claim the transaction. Creating and Broadcasting a HTLC Refund \u00b6 const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://sxp.testnet.sh/api\" ); // Ensure AIP11 is enabled for the Crypto SDK Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 4006000 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . htlcRefund () . version ( 2 ) . nonce ( senderNonce . toFixed ()) . htlcRefundAsset ({ lockTransactionId : \"943c220691e711c39c79d437ce185748a0018940e1a4144293af9d05627d2eb4\" , }) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })();","title":"Complementary Examples"},{"location":"sdk/typescript/complementary-examples/#complementary-examples","text":"","title":"Complementary Examples"},{"location":"sdk/typescript/complementary-examples/#prerequisites","text":"Before we get started we need to make sure that all of the required dependencies are installed. These dependencies are the Crypto SDK and Client SDK . You can head on over to their documentations to read more about them but for now we are only concerned with installing them to get up and running. Open your project and execute the following commands to install both SDKs. Make sure that those complete without any errors. If you encounter any errors, please open an issue with as much information as you can provide so that our developers can have a look and get to the bottom of the issue.","title":"Prerequisites"},{"location":"sdk/typescript/complementary-examples/#yarn","text":"yarn add @solar-network/crypto yarn add @solar-network/client","title":"yarn"},{"location":"sdk/typescript/complementary-examples/#pnpm","text":"pnpm add @solar-network/crypto pnpm add @solar-network/client","title":"pnpm"},{"location":"sdk/typescript/complementary-examples/#npm","text":"npm install @solar-network/crypto npm install @solar-network/client Now that we're setup and ready to go we'll look into some examples for the most common tasks you'll encounter when wanting to interact with the SXP Blockchain.","title":"npm"},{"location":"sdk/typescript/complementary-examples/#persisting-your-transaction-on-the-blockchain","text":"The process of getting your transaction verified and persisted on the SXP Blockchain involves a few steps with which our SDKs will help you but lets break them down to get a better idea of what is happening. Install the Client SDK and configure it to use a node of your choosing to broadcast your transactions to. Always make sure that you have a fallback node that you can use for broadcasting in case your primary node goes offline or acts strange otherwise. Install the Crypto SDK and configure it to match the configuration of the network. This is the most important part as misconfiguration can lead to a myriad of issues as Core will reject your transactions. Retrieve the nonce of the sender wallet and increase it by 1. You can read about what a sequential nonce is and why it is important here . Create an instance of the builder for the type of transaction you want to create. This is the step where we actually create a transaction and sign it so that the SXP Blockchain can later on verify it and decide if it will be accepted, forged and finally. You can read the relevant API documentation if you want more detailed information about the design and usage. Turn the newly created transaction into JSON and broadcast it to the network through the Client SDK. You can read the relevant API documentation if you want more detailed information about the design and usage. Process the API response and verify that your transaction was accepted. If the network rejects your transaction you'll receive the reason as to why that is the case in the response which might mean that you need to create a new transaction and broadcast it.","title":"Persisting your transaction on the blockchain"},{"location":"sdk/typescript/complementary-examples/#troubleshooting","text":"A common issue when trying to get your transaction onto the blockchain is that you'll receive an error to the effect of Transaction Version 2 is not supported which indicates that your Crypto SDK configuration might be wrong. The solution to this is to make sure that your Crypto SDK instance is properly configured. This includes both the network preset and the height it's configured to assume the network has passed, if any of those don't match up you'll encounter the aforementioned issue with the version of your transactions.","title":"Troubleshooting"},{"location":"sdk/typescript/complementary-examples/#mainnet","text":"Managers . configManager . setFromPreset ( \"mainnet\" ); Managers . configManager . setHeight ( 11273000 );","title":"Mainnet"},{"location":"sdk/typescript/complementary-examples/#testnet","text":"Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 4006000 );","title":"Testnet"},{"location":"sdk/typescript/complementary-examples/#creating-and-broadcasting-a-transfer","text":"const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://sxp.testnet.sh/api\" ); // Ensure AIP11 is enabled for the Crypto SDK Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 4006000 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . transfer () . version ( 2 ) . nonce ( senderNonce . toFixed ()) . recipientId ( \"Address of Recipient\" ) . amount ( 1 * 1e8 ) . vendorField ( \"Hello World\" ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); The vendorField is optional and limited to a length of 255 characters. It can be a good idea to add a vendor field to your transactions if you want to be able to easily track them in the future.","title":"Creating and Broadcasting a Transfer"},{"location":"sdk/typescript/complementary-examples/#creating-and-broadcasting-a-second-signature","text":"const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://sxp.testnet.sh/api\" ); // Ensure AIP11 is enabled for the Crypto SDK Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 4006000 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . secondSignature () . version ( 2 ) . nonce ( senderNonce . toFixed ()) . signatureAsset ( \"this is a top secret second passphrase\" ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })();","title":"Creating and Broadcasting a Second Signature"},{"location":"sdk/typescript/complementary-examples/#creating-and-broadcasting-a-delegate-registration","text":"const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://sxp.testnet.sh/api\" ); // Ensure AIP11 is enabled for the Crypto SDK Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 4006000 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . delegateRegistration () . version ( 2 ) . nonce ( senderNonce . toFixed ()) . usernameAsset ( \"johndoe\" ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })();","title":"Creating and Broadcasting a Delegate Registration"},{"location":"sdk/typescript/complementary-examples/#creating-and-broadcasting-a-vote","text":"const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://sxp.testnet.sh/api\" ); // Ensure AIP11 is enabled for the Crypto SDK Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 4006000 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . vote () . version ( 2 ) . nonce ( senderNonce . toFixed ()) . votesAsset ([ \"+public_key_of_a_delegate_wallet\" ]) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); Note the plus prefix for the public key that is passed to the votesAsset function. This prefix denotes that this is a transaction to remove a vote from the given delegate.","title":"Creating and Broadcasting a Vote"},{"location":"sdk/typescript/complementary-examples/#creating-and-broadcasting-an-unvote","text":"const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://sxp.testnet.sh/api\" ); // Ensure AIP11 is enabled for the Crypto SDK Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 4006000 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . vote () . version ( 2 ) . nonce ( senderNonce . toFixed ()) . votesAsset ([ \"-public_key_of_a_delegate_wallet\" ]) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); Note the minus prefix for the public key that is passed to the votesAsset function. This prefix denotes that this is a transaction to add a vote to the given delegate.","title":"Creating and Broadcasting an Unvote"},{"location":"sdk/typescript/complementary-examples/#creating-and-broadcasting-a-multi-signature","text":"const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://sxp.testnet.sh/api\" ); // Ensure AIP11 is enabled for the Crypto SDK Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 4006000 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . multiSignature () . version ( 2 ) . nonce ( senderNonce . toFixed ()) . multiSignatureAsset ({ publicKeys : [ \"039180ea4a8a803ee11ecb462bb8f9613fcdb5fe917e292dbcc73409f0e98f8f22\" , \"028d3611c4f32feca3e6713992ae9387e18a0e01954046511878fe078703324dc0\" , \"021d3932ab673230486d0f956d05b9e88791ee298d9af2d6df7d9ed5bb861c92dd\" , ], min : 2 , }) . senderPublicKey ( \"039180ea4a8a803ee11ecb462bb8f9613fcdb5fe917e292dbcc73409f0e98f8f22\" ) . multiSign ( \"this is a top secret passphrase 1\" , 0 ) . multiSign ( \"this is a top secret passphrase 2\" , 1 ) . multiSign ( \"this is a top secret passphrase 3\" , 2 ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })();","title":"Creating and Broadcasting a Multi Signature"},{"location":"sdk/typescript/complementary-examples/#creating-and-broadcasting-a-ipfs","text":"const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://sxp.testnet.sh/api\" ); // Ensure AIP11 is enabled for the Crypto SDK Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 4006000 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . ipfs () . version ( 2 ) . nonce ( senderNonce . toFixed ()) . ipfsAsset ( \"QmR45FmbVVrixReBwJkhEKde2qwHYaQzGxu4ZoDeswuF9w\" ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })();","title":"Creating and Broadcasting a IPFS"},{"location":"sdk/typescript/complementary-examples/#creating-and-broadcasting-a-multi-payment","text":"const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://sxp.testnet.sh/api\" ); // Ensure AIP11 is enabled for the Crypto SDK Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 4006000 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . multiPayment () . version ( 2 ) . nonce ( senderNonce . toFixed ()) . addPayment ( \"Address of Recipient Wallet 1\" , 1 * 1e8 ) . addPayment ( \"Address of Recipient Wallet 2\" , 1 * 1e8 ) . addPayment ( \"Address of Recipient Wallet 3\" , 1 * 1e8 ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })();","title":"Creating and Broadcasting a Multi Payment"},{"location":"sdk/typescript/complementary-examples/#creating-and-broadcasting-a-delegate-resignation","text":"const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://sxp.testnet.sh/api\" ); // Ensure AIP11 is enabled for the Crypto SDK Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 4006000 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . delegateResignation () . version ( 2 ) . nonce ( senderNonce . toFixed ()) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); A delegate resignation has to be sent from the delegate wallet itself to verify its identity.","title":"Creating and Broadcasting a Delegate Resignation"},{"location":"sdk/typescript/complementary-examples/#creating-and-broadcasting-a-htlc-lock","text":"const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://sxp.testnet.sh/api\" ); // Ensure AIP11 is enabled for the Crypto SDK Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 4006000 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . htlcLock () . version ( 2 ) . nonce ( senderNonce . toFixed ()) . htlcLockAsset ({ secretHash : \"0f128d401958b1b30ad0d10406f47f9489321017b4614e6cb993fc63913c5454\" , expiration : { type : 1 , value : Math.floor ( Date . now () / 1000 ), }, }) . amount ( 1 * 1e8 ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })();","title":"Creating and Broadcasting a HTLC Lock"},{"location":"sdk/typescript/complementary-examples/#creating-and-broadcasting-a-htlc-claim","text":"const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://sxp.testnet.sh/api\" ); // Ensure AIP11 is enabled for the Crypto SDK Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 4006000 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . htlcClaim () . version ( 2 ) . nonce ( senderNonce . toFixed ()) . htlcClaimAsset ({ lockTransactionId : \"943c220691e711c39c79d437ce185748a0018940e1a4144293af9d05627d2eb4\" , unlockSecret : \"c27f1ce845d8c29eebc9006be932b604fd06755521b1a8b0be4204c65377151a\" , }) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); The unlockSecret has to be a SHA256 hash of the plain text secret that you shared with the person that is allowed to claim the transaction.","title":"Creating and Broadcasting a HTLC Claim"},{"location":"sdk/typescript/complementary-examples/#creating-and-broadcasting-a-htlc-refund","text":"const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://sxp.testnet.sh/api\" ); // Ensure AIP11 is enabled for the Crypto SDK Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 4006000 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . htlcRefund () . version ( 2 ) . nonce ( senderNonce . toFixed ()) . htlcRefundAsset ({ lockTransactionId : \"943c220691e711c39c79d437ce185748a0018940e1a4144293af9d05627d2eb4\" , }) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })();","title":"Creating and Broadcasting a HTLC Refund"},{"location":"sdk/typescript/installation/","text":"Installation \u00b6 NodeJS installation \u00b6 NodeJS can be downloaded here . Alternatively you can install NodeJS through your operating system packager manager . An excellent way to manage your NodeJS installation and be able to work with multiple version is to go through NVM . Install Yarn Package Manager \u00b6 Yarn is a package manager for your code. It allows you to use and share code with other developers from around the world. Yarn does this quickly, securely, and reliably so you don\u2019t ever have to worry. Instructions on how to install Yarn can be found here","title":"Installation"},{"location":"sdk/typescript/installation/#installation","text":"","title":"Installation"},{"location":"sdk/typescript/installation/#nodejs-installation","text":"NodeJS can be downloaded here . Alternatively you can install NodeJS through your operating system packager manager . An excellent way to manage your NodeJS installation and be able to work with multiple version is to go through NVM .","title":"NodeJS installation"},{"location":"sdk/typescript/installation/#install-yarn-package-manager","text":"Yarn is a package manager for your code. It allows you to use and share code with other developers from around the world. Yarn does this quickly, securely, and reliably so you don\u2019t ever have to worry. Instructions on how to install Yarn can be found here","title":"Install Yarn Package Manager"},{"location":"sdk/typescript/client/api-documentation/","text":"API Documentation \u00b6 ConnectionManager \u00b6 connect() \u00b6 public connect ( host : string , name = \"main\" ) Connect to the given connection. Parameters \u00b6 Type Name Required Description string host Yes Node URL string name No Network name Return Value \u00b6 Connection disconnect() \u00b6 public disconnect ( name? : string ) Disconnect from the given connection. Parameters \u00b6 Type Name Required Description string name No Network Name Return Value \u00b6 void connection() \u00b6 public connection ( name? : string ) Get a connection instance. Parameters \u00b6 Type Name Required Description string name No Network Name Return Value \u00b6 Connection getDefaultConnection() \u00b6 public getDefaultConnection () Get the default connection name. Return Value \u00b6 string setDefaultConnection() \u00b6 public setDefaultConnection ( name : string ) Set the default connection name. Parameters \u00b6 Type Name Required Description string name No Network Name Return Value \u00b6 void getConnections() \u00b6 public getConnections () Return all of the created connections. Return Value \u00b6 Record<string, Connection> Connection \u00b6 constructor() \u00b6 public constructor ( private readonly host : string ) Create a new Connection class instance. Parameters \u00b6 Type Name Required Description string host Yes Node URL api() \u00b6 public api < T = any > ( name : string ) Instantiate new Api. Parameters \u00b6 Type Name Required Description string name Yes Network name Return Value \u00b6 T Type Name Required Description string host Yes Node URL withOptions() \u00b6 public withOptions ( opts : Record < string , any > ) Apply options to future connection requests. Parameters \u00b6 Type Name Required Description string opts Yes Connection options Return Value \u00b6 this get() \u00b6 public async get < T = any > ( url : string , opts? : Record < string , any > ) Send a GET request with query parameters. Parameters \u00b6 Type Name Required Description string url Yes Endpoint Record opts? No Query parameters Return Value \u00b6 Promise<IResponse<T>> post() \u00b6 public async post < T = any > ( url : string , opts? : Record < string , any > ) : Promise < IResponse < T >> Send a POST request with JSON-encoded parameters. Parameters \u00b6 Type Name Required Description string url Yes Endpoint Record opts? No Query parameters Return Value \u00b6 Promise<IResponse<T>> RequestError \u00b6 constructor() \u00b6 public constructor ( error ) Create a new RequestError class instance. Parameters \u00b6 Type Name Required Description string error Yes Error Resources\\Blocks \u00b6 all() \u00b6 public async all < T = any > ( query? : Record < string , any > ) Get all blocks. Parameters \u00b6 Type Name Required Description Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> get() \u00b6 public async get < T = any > ( id : string ) Get a block by the given id. Parameters \u00b6 Type Name Required Description string id Yes Block ID Return Value \u00b6 Promise<IResponse<T>> transactions() \u00b6 public async transactions < T = any > ( id : string , query? : Record < string , any > ) Get all transactions by the given block. Parameters \u00b6 Type Name Required Description string id Yes Block ID Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> search() \u00b6 public async search < T = any > ( payload? : Record < string , any > ) Filter all blocks by the given parameters. Parameters \u00b6 Type Name Required Description Record payload No Search parameters Return Value \u00b6 Promise<IResponse<T>> Resources\\Bridgechains \u00b6 all() \u00b6 public async all < T = any > ( query? : Record < string , any > ) Get all bridgechains. Parameters \u00b6 Type Name Required Description Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> get() \u00b6 public async get < T = any > ( id : string ) Get a bridgechain by the given id. Parameters \u00b6 Type Name Required Description string id Yes Bridgechain identifier Return Value \u00b6 Promise<IResponse<T>> search() \u00b6 public async search < T = any > ( payload? : Record < string , any > ) Search for a bridgechain with the given payload. Parameters \u00b6 Type Name Required Description Record payload No Search parameters Return Value \u00b6 Promise<IResponse<T>> Resources\\Businesses \u00b6 all() \u00b6 public async all < T = any > ( query? : Record < string , any > ) Get all businesses. Parameters \u00b6 Type Name Required Description Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> get() \u00b6 public async get < T = any > ( id : string ) Get a business by the given id. Parameters \u00b6 Type Name Required Description string id Yes Bridgechain identifier Return Value \u00b6 Promise<IResponse<T>> bridgechains() \u00b6 public async bridgechains < T = any > ( id : string , query? : Record < string , any > ) Get all bridgechains for a business. Parameters \u00b6 Type Name Required Description string id Yes Business identifier Record payload No Search parameters Return Value \u00b6 Promise<IResponse<T>> search() \u00b6 public async search < T = any > ( payload? : Record < string , any > ) Search for a business with the given payload. Parameters \u00b6 Type Name Required Description Record payload No Search parameters Return Value \u00b6 Promise<IResponse<T>> Resources\\Locks \u00b6 all() \u00b6 public async all < T = any > ( query? : Record < string , any > ) Get all locks. Parameters \u00b6 Type Name Required Description Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> get() \u00b6 public async get < T = any > ( id : string ) Get a lock by the given id. Parameters \u00b6 Type Name Required Description string id Yes Bridgechain identifier Return Value \u00b6 Promise<IResponse<T>> search() \u00b6 public async search < T = any > ( payload? : Record < string , any > ) Search for locks with given payload. Parameters \u00b6 Type Name Required Description Record payload No Search parameters Return Value \u00b6 Promise<IResponse<T>> unlocked() \u00b6 public async unlocked < T = any > ( payload? : Record < string , any > ) Search for unlocked locks. Parameters \u00b6 Type Name Required Description Record payload No Search parameters Return Value \u00b6 Promise<IResponse<T>> Resources\\Delegates \u00b6 all() \u00b6 public async all < T = any > ( query? : Record < string , any > ) Get all accounts. Parameters \u00b6 Type Name Required Description Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> get() \u00b6 public async get < T = any > ( id : string ) Get a delegate by the given id. Parameters \u00b6 Type Name Required Description string id Yes Delegate identifier Return Value \u00b6 Promise<IResponse<T>> blocks() \u00b6 public async blocks < T = any > ( id : string , query? : Record < string , any > ) Get all blocks for the given delegate. Parameters \u00b6 Type Name Required Description string id Yes Delegate identifier Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> voters() \u00b6 public async voters < T = any > ( id : string , query? : Record < string , any > ) Get all voters for the given delegate. Parameters \u00b6 Type Name Required Description string id Yes Delegate identifier Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> Resources\\Node \u00b6 configuration() \u00b6 public async configuration < T = any > () Get the node configuration. Return Value \u00b6 Promise<IResponse<T>> status() \u00b6 public async status < T = any > () Get the node status. Return Value \u00b6 Promise<IResponse<T>> syncing() \u00b6 public async syncing < T = any > () Get the node syncing status. Return Value \u00b6 Promise<IResponse<T>> crypto() \u00b6 public async crypto < T = any > () Get the node crypto configuration. Return Value \u00b6 Promise<IResponse<T>> fees() \u00b6 public async fees < T = any > ( days : number ) Get the node fee statistics. Parameters \u00b6 Type Name Required Description number days Yes Days Return Value \u00b6 Promise<IResponse<T>> Resources\\Peers \u00b6 all() \u00b6 public async all < T = any > ( query? : Record < string , any > ) Get all peers. Parameters \u00b6 Type Name Required Description Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> get() \u00b6 public async get < T = any > ( ip : string ) Get a peer by the given IP address. Parameters \u00b6 Type Name Required Description string ip Yes IP address Return Value \u00b6 Promise<IResponse<T>> Resources\\Rounds \u00b6 delegates() \u00b6 public async delegates < T = any > ( id : number ) Get delegates for a round. Parameters \u00b6 Type Name Required Description number id yes Round number Return Value \u00b6 Promise<IResponse<T>> Resources\\Transactions \u00b6 create() \u00b6 public async create < T = any > ( payload : object []) Create a new transaction. Parameters \u00b6 Type Name Required Description object[] payload Yes Transaction(s) to broadcast Return Value \u00b6 Promise<IResponse<T>> get() \u00b6 public async get < T = any > ( id : string ) Get a transaction by the given id. Parameters \u00b6 Type Name Required Description string id Yes Transaction ID Return Value \u00b6 Promise<IResponse<T>> all() \u00b6 public async all < T = any > ( query? : Record < string , any > ) Get all transactions. Parameters \u00b6 Type Name Required Description Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> allUnconfirmed() \u00b6 public async allUnconfirmed < T = any > ( query? : Record < string , any > ) Get all unconfirmed transactions. Parameters \u00b6 Type Name Required Description Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> getUnconfirmed() \u00b6 public async getUnconfirmed < T = any > ( id : string ) Get an unconfirmed transaction by the given id. Parameters \u00b6 Type Name Required Description string id Yes Transaction ID Return Value \u00b6 Promise<IResponse<T>> search() \u00b6 public async search < T = any > ( payload : Record < string , any > ) Filter all transactions by the given parameters. Parameters \u00b6 Type Name Required Description Record payload Yes Search parameters Return Value \u00b6 Promise<IResponse<T>> types() \u00b6 public async types < T = any > () Get a list of valid transaction types. Return Value \u00b6 Promise<IResponse<T>> fees() \u00b6 public async fees < T = any > () : Promise < IResponse < T >> Get the node fee statistics. Return Value \u00b6 Promise<IResponse<T>> Resources\\Votes \u00b6 all() \u00b6 public async all < T = any > ( query? : Record < string , any > ) Get all votes. Parameters \u00b6 Type Name Required Description Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> get() \u00b6 public async get < T = any > ( id : string ) Get a vote by the given id. Parameters \u00b6 Type Name Required Description string id Yes Vote ID Return Value \u00b6 Promise<IResponse<T>> Resources\\Wallets \u00b6 all() \u00b6 public async all < T = any > ( query? : Record < string , any > ) Get all wallets. Parameters \u00b6 Type Name Required Description Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> get() \u00b6 public async get < T = any > ( id : string ) Get a wallet by the given id. Parameters \u00b6 Type Name Required Description string id Yes Wallet identifier Return Value \u00b6 Promise<IResponse<T>> locks() \u00b6 public async locks < T = any > ( id : string , query? : Record < string , any > ) Get a wallet by the given id. Parameters \u00b6 Type Name Required Description string id Yes Wallet identifier Record query No Search parameters Return Value \u00b6 Promise<IResponse<T>> transactions() \u00b6 public async transactions < T = any > ( id : string , query? : Record < string , any > ) Get all transactions for the given wallet. Parameters \u00b6 Type Name Required Description string id Yes Wallet identifier Record query Yes Query parameters Return Value \u00b6 Promise<IResponse<T>> transactionsReceived() \u00b6 public async transactionsReceived < T = any > ( id : string , query? : Record < string , any > ) Get all transactions received by the given wallet. Parameters \u00b6 Type Name Required Description string id Yes Wallet identifier Record query Yes Query parameters Return Value \u00b6 Promise<IResponse<T>> transactionsSent() \u00b6 public async transactionsSent < T = any > ( id : string , query? : Record < string , any > ) Get all transactions sent by the given wallet. Parameters \u00b6 Type Name Required Description string id Yes Wallet identifier Record query Yes Query parameters Return Value \u00b6 Promise<IResponse<T>> votes() \u00b6 public async votes < T = any > ( id : string ) Get all votes by the given wallet. Parameters \u00b6 Type Name Required Description string id Yes Wallet identifier Return Value \u00b6 Promise<IResponse<T>> top() \u00b6 public async top < T = any > ( query? : Record < string , any > ) Get all wallets sorted by balance in descending order. Parameters \u00b6 Type Name Required Description Record query Yes Query parameters Return Value \u00b6 Promise<IResponse<T>> search() \u00b6 public async search < T = any > ( payload : Record < string , any > ) Filter all wallets by the given parameters. Parameters \u00b6 Type Name Required Description Record payload Yes Search parameters Return Value \u00b6 Promise<IResponse<T>>","title":"API Documentation"},{"location":"sdk/typescript/client/api-documentation/#api-documentation","text":"","title":"API Documentation"},{"location":"sdk/typescript/client/api-documentation/#connectionmanager","text":"","title":"ConnectionManager"},{"location":"sdk/typescript/client/api-documentation/#connect","text":"public connect ( host : string , name = \"main\" ) Connect to the given connection.","title":"connect()"},{"location":"sdk/typescript/client/api-documentation/#parameters","text":"Type Name Required Description string host Yes Node URL string name No Network name","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value","text":"Connection","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#disconnect","text":"public disconnect ( name? : string ) Disconnect from the given connection.","title":"disconnect()"},{"location":"sdk/typescript/client/api-documentation/#parameters_1","text":"Type Name Required Description string name No Network Name","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_1","text":"void","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#connection","text":"public connection ( name? : string ) Get a connection instance.","title":"connection()"},{"location":"sdk/typescript/client/api-documentation/#parameters_2","text":"Type Name Required Description string name No Network Name","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_2","text":"Connection","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#getdefaultconnection","text":"public getDefaultConnection () Get the default connection name.","title":"getDefaultConnection()"},{"location":"sdk/typescript/client/api-documentation/#return-value_3","text":"string","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#setdefaultconnection","text":"public setDefaultConnection ( name : string ) Set the default connection name.","title":"setDefaultConnection()"},{"location":"sdk/typescript/client/api-documentation/#parameters_3","text":"Type Name Required Description string name No Network Name","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_4","text":"void","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#getconnections","text":"public getConnections () Return all of the created connections.","title":"getConnections()"},{"location":"sdk/typescript/client/api-documentation/#return-value_5","text":"Record<string, Connection>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#connection_1","text":"","title":"Connection"},{"location":"sdk/typescript/client/api-documentation/#constructor","text":"public constructor ( private readonly host : string ) Create a new Connection class instance.","title":"constructor()"},{"location":"sdk/typescript/client/api-documentation/#parameters_4","text":"Type Name Required Description string host Yes Node URL","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#api","text":"public api < T = any > ( name : string ) Instantiate new Api.","title":"api()"},{"location":"sdk/typescript/client/api-documentation/#parameters_5","text":"Type Name Required Description string name Yes Network name","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_6","text":"T Type Name Required Description string host Yes Node URL","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#withoptions","text":"public withOptions ( opts : Record < string , any > ) Apply options to future connection requests.","title":"withOptions()"},{"location":"sdk/typescript/client/api-documentation/#parameters_6","text":"Type Name Required Description string opts Yes Connection options","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_7","text":"this","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#get","text":"public async get < T = any > ( url : string , opts? : Record < string , any > ) Send a GET request with query parameters.","title":"get()"},{"location":"sdk/typescript/client/api-documentation/#parameters_7","text":"Type Name Required Description string url Yes Endpoint Record opts? No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_8","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#post","text":"public async post < T = any > ( url : string , opts? : Record < string , any > ) : Promise < IResponse < T >> Send a POST request with JSON-encoded parameters.","title":"post()"},{"location":"sdk/typescript/client/api-documentation/#parameters_8","text":"Type Name Required Description string url Yes Endpoint Record opts? No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_9","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#requesterror","text":"","title":"RequestError"},{"location":"sdk/typescript/client/api-documentation/#constructor_1","text":"public constructor ( error ) Create a new RequestError class instance.","title":"constructor()"},{"location":"sdk/typescript/client/api-documentation/#parameters_9","text":"Type Name Required Description string error Yes Error","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#resourcesblocks","text":"","title":"Resources\\Blocks"},{"location":"sdk/typescript/client/api-documentation/#all","text":"public async all < T = any > ( query? : Record < string , any > ) Get all blocks.","title":"all()"},{"location":"sdk/typescript/client/api-documentation/#parameters_10","text":"Type Name Required Description Record query No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_10","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#get_1","text":"public async get < T = any > ( id : string ) Get a block by the given id.","title":"get()"},{"location":"sdk/typescript/client/api-documentation/#parameters_11","text":"Type Name Required Description string id Yes Block ID","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_11","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#transactions","text":"public async transactions < T = any > ( id : string , query? : Record < string , any > ) Get all transactions by the given block.","title":"transactions()"},{"location":"sdk/typescript/client/api-documentation/#parameters_12","text":"Type Name Required Description string id Yes Block ID Record query No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_12","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#search","text":"public async search < T = any > ( payload? : Record < string , any > ) Filter all blocks by the given parameters.","title":"search()"},{"location":"sdk/typescript/client/api-documentation/#parameters_13","text":"Type Name Required Description Record payload No Search parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_13","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#resourcesbridgechains","text":"","title":"Resources\\Bridgechains"},{"location":"sdk/typescript/client/api-documentation/#all_1","text":"public async all < T = any > ( query? : Record < string , any > ) Get all bridgechains.","title":"all()"},{"location":"sdk/typescript/client/api-documentation/#parameters_14","text":"Type Name Required Description Record query No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_14","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#get_2","text":"public async get < T = any > ( id : string ) Get a bridgechain by the given id.","title":"get()"},{"location":"sdk/typescript/client/api-documentation/#parameters_15","text":"Type Name Required Description string id Yes Bridgechain identifier","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_15","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#search_1","text":"public async search < T = any > ( payload? : Record < string , any > ) Search for a bridgechain with the given payload.","title":"search()"},{"location":"sdk/typescript/client/api-documentation/#parameters_16","text":"Type Name Required Description Record payload No Search parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_16","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#resourcesbusinesses","text":"","title":"Resources\\Businesses"},{"location":"sdk/typescript/client/api-documentation/#all_2","text":"public async all < T = any > ( query? : Record < string , any > ) Get all businesses.","title":"all()"},{"location":"sdk/typescript/client/api-documentation/#parameters_17","text":"Type Name Required Description Record query No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_17","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#get_3","text":"public async get < T = any > ( id : string ) Get a business by the given id.","title":"get()"},{"location":"sdk/typescript/client/api-documentation/#parameters_18","text":"Type Name Required Description string id Yes Bridgechain identifier","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_18","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#bridgechains","text":"public async bridgechains < T = any > ( id : string , query? : Record < string , any > ) Get all bridgechains for a business.","title":"bridgechains()"},{"location":"sdk/typescript/client/api-documentation/#parameters_19","text":"Type Name Required Description string id Yes Business identifier Record payload No Search parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_19","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#search_2","text":"public async search < T = any > ( payload? : Record < string , any > ) Search for a business with the given payload.","title":"search()"},{"location":"sdk/typescript/client/api-documentation/#parameters_20","text":"Type Name Required Description Record payload No Search parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_20","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#resourceslocks","text":"","title":"Resources\\Locks"},{"location":"sdk/typescript/client/api-documentation/#all_3","text":"public async all < T = any > ( query? : Record < string , any > ) Get all locks.","title":"all()"},{"location":"sdk/typescript/client/api-documentation/#parameters_21","text":"Type Name Required Description Record query No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_21","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#get_4","text":"public async get < T = any > ( id : string ) Get a lock by the given id.","title":"get()"},{"location":"sdk/typescript/client/api-documentation/#parameters_22","text":"Type Name Required Description string id Yes Bridgechain identifier","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_22","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#search_3","text":"public async search < T = any > ( payload? : Record < string , any > ) Search for locks with given payload.","title":"search()"},{"location":"sdk/typescript/client/api-documentation/#parameters_23","text":"Type Name Required Description Record payload No Search parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_23","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#unlocked","text":"public async unlocked < T = any > ( payload? : Record < string , any > ) Search for unlocked locks.","title":"unlocked()"},{"location":"sdk/typescript/client/api-documentation/#parameters_24","text":"Type Name Required Description Record payload No Search parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_24","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#resourcesdelegates","text":"","title":"Resources\\Delegates"},{"location":"sdk/typescript/client/api-documentation/#all_4","text":"public async all < T = any > ( query? : Record < string , any > ) Get all accounts.","title":"all()"},{"location":"sdk/typescript/client/api-documentation/#parameters_25","text":"Type Name Required Description Record query No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_25","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#get_5","text":"public async get < T = any > ( id : string ) Get a delegate by the given id.","title":"get()"},{"location":"sdk/typescript/client/api-documentation/#parameters_26","text":"Type Name Required Description string id Yes Delegate identifier","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_26","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#blocks","text":"public async blocks < T = any > ( id : string , query? : Record < string , any > ) Get all blocks for the given delegate.","title":"blocks()"},{"location":"sdk/typescript/client/api-documentation/#parameters_27","text":"Type Name Required Description string id Yes Delegate identifier Record query No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_27","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#voters","text":"public async voters < T = any > ( id : string , query? : Record < string , any > ) Get all voters for the given delegate.","title":"voters()"},{"location":"sdk/typescript/client/api-documentation/#parameters_28","text":"Type Name Required Description string id Yes Delegate identifier Record query No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_28","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#resourcesnode","text":"","title":"Resources\\Node"},{"location":"sdk/typescript/client/api-documentation/#configuration","text":"public async configuration < T = any > () Get the node configuration.","title":"configuration()"},{"location":"sdk/typescript/client/api-documentation/#return-value_29","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#status","text":"public async status < T = any > () Get the node status.","title":"status()"},{"location":"sdk/typescript/client/api-documentation/#return-value_30","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#syncing","text":"public async syncing < T = any > () Get the node syncing status.","title":"syncing()"},{"location":"sdk/typescript/client/api-documentation/#return-value_31","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#crypto","text":"public async crypto < T = any > () Get the node crypto configuration.","title":"crypto()"},{"location":"sdk/typescript/client/api-documentation/#return-value_32","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#fees","text":"public async fees < T = any > ( days : number ) Get the node fee statistics.","title":"fees()"},{"location":"sdk/typescript/client/api-documentation/#parameters_29","text":"Type Name Required Description number days Yes Days","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_33","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#resourcespeers","text":"","title":"Resources\\Peers"},{"location":"sdk/typescript/client/api-documentation/#all_5","text":"public async all < T = any > ( query? : Record < string , any > ) Get all peers.","title":"all()"},{"location":"sdk/typescript/client/api-documentation/#parameters_30","text":"Type Name Required Description Record query No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_34","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#get_6","text":"public async get < T = any > ( ip : string ) Get a peer by the given IP address.","title":"get()"},{"location":"sdk/typescript/client/api-documentation/#parameters_31","text":"Type Name Required Description string ip Yes IP address","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_35","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#resourcesrounds","text":"","title":"Resources\\Rounds"},{"location":"sdk/typescript/client/api-documentation/#delegates","text":"public async delegates < T = any > ( id : number ) Get delegates for a round.","title":"delegates()"},{"location":"sdk/typescript/client/api-documentation/#parameters_32","text":"Type Name Required Description number id yes Round number","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_36","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#resourcestransactions","text":"","title":"Resources\\Transactions"},{"location":"sdk/typescript/client/api-documentation/#create","text":"public async create < T = any > ( payload : object []) Create a new transaction.","title":"create()"},{"location":"sdk/typescript/client/api-documentation/#parameters_33","text":"Type Name Required Description object[] payload Yes Transaction(s) to broadcast","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_37","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#get_7","text":"public async get < T = any > ( id : string ) Get a transaction by the given id.","title":"get()"},{"location":"sdk/typescript/client/api-documentation/#parameters_34","text":"Type Name Required Description string id Yes Transaction ID","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_38","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#all_6","text":"public async all < T = any > ( query? : Record < string , any > ) Get all transactions.","title":"all()"},{"location":"sdk/typescript/client/api-documentation/#parameters_35","text":"Type Name Required Description Record query No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_39","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#allunconfirmed","text":"public async allUnconfirmed < T = any > ( query? : Record < string , any > ) Get all unconfirmed transactions.","title":"allUnconfirmed()"},{"location":"sdk/typescript/client/api-documentation/#parameters_36","text":"Type Name Required Description Record query No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_40","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#getunconfirmed","text":"public async getUnconfirmed < T = any > ( id : string ) Get an unconfirmed transaction by the given id.","title":"getUnconfirmed()"},{"location":"sdk/typescript/client/api-documentation/#parameters_37","text":"Type Name Required Description string id Yes Transaction ID","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_41","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#search_4","text":"public async search < T = any > ( payload : Record < string , any > ) Filter all transactions by the given parameters.","title":"search()"},{"location":"sdk/typescript/client/api-documentation/#parameters_38","text":"Type Name Required Description Record payload Yes Search parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_42","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#types","text":"public async types < T = any > () Get a list of valid transaction types.","title":"types()"},{"location":"sdk/typescript/client/api-documentation/#return-value_43","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#fees_1","text":"public async fees < T = any > () : Promise < IResponse < T >> Get the node fee statistics.","title":"fees()"},{"location":"sdk/typescript/client/api-documentation/#return-value_44","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#resourcesvotes","text":"","title":"Resources\\Votes"},{"location":"sdk/typescript/client/api-documentation/#all_7","text":"public async all < T = any > ( query? : Record < string , any > ) Get all votes.","title":"all()"},{"location":"sdk/typescript/client/api-documentation/#parameters_39","text":"Type Name Required Description Record query No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_45","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#get_8","text":"public async get < T = any > ( id : string ) Get a vote by the given id.","title":"get()"},{"location":"sdk/typescript/client/api-documentation/#parameters_40","text":"Type Name Required Description string id Yes Vote ID","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_46","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#resourceswallets","text":"","title":"Resources\\Wallets"},{"location":"sdk/typescript/client/api-documentation/#all_8","text":"public async all < T = any > ( query? : Record < string , any > ) Get all wallets.","title":"all()"},{"location":"sdk/typescript/client/api-documentation/#parameters_41","text":"Type Name Required Description Record query No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_47","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#get_9","text":"public async get < T = any > ( id : string ) Get a wallet by the given id.","title":"get()"},{"location":"sdk/typescript/client/api-documentation/#parameters_42","text":"Type Name Required Description string id Yes Wallet identifier","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_48","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#locks","text":"public async locks < T = any > ( id : string , query? : Record < string , any > ) Get a wallet by the given id.","title":"locks()"},{"location":"sdk/typescript/client/api-documentation/#parameters_43","text":"Type Name Required Description string id Yes Wallet identifier Record query No Search parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_49","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#transactions_1","text":"public async transactions < T = any > ( id : string , query? : Record < string , any > ) Get all transactions for the given wallet.","title":"transactions()"},{"location":"sdk/typescript/client/api-documentation/#parameters_44","text":"Type Name Required Description string id Yes Wallet identifier Record query Yes Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_50","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#transactionsreceived","text":"public async transactionsReceived < T = any > ( id : string , query? : Record < string , any > ) Get all transactions received by the given wallet.","title":"transactionsReceived()"},{"location":"sdk/typescript/client/api-documentation/#parameters_45","text":"Type Name Required Description string id Yes Wallet identifier Record query Yes Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_51","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#transactionssent","text":"public async transactionsSent < T = any > ( id : string , query? : Record < string , any > ) Get all transactions sent by the given wallet.","title":"transactionsSent()"},{"location":"sdk/typescript/client/api-documentation/#parameters_46","text":"Type Name Required Description string id Yes Wallet identifier Record query Yes Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_52","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#votes","text":"public async votes < T = any > ( id : string ) Get all votes by the given wallet.","title":"votes()"},{"location":"sdk/typescript/client/api-documentation/#parameters_47","text":"Type Name Required Description string id Yes Wallet identifier","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_53","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#top","text":"public async top < T = any > ( query? : Record < string , any > ) Get all wallets sorted by balance in descending order.","title":"top()"},{"location":"sdk/typescript/client/api-documentation/#parameters_48","text":"Type Name Required Description Record query Yes Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_54","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#search_5","text":"public async search < T = any > ( payload : Record < string , any > ) Filter all wallets by the given parameters.","title":"search()"},{"location":"sdk/typescript/client/api-documentation/#parameters_49","text":"Type Name Required Description Record payload Yes Search parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_55","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/examples/","text":"Examples \u00b6 Initialization \u00b6 const { Connection } = require ( \"@solar-network/client\" ); const client = new Connection ( ` ${ server } /api` ); Blocks \u00b6 This service API grants access to the blocks resource . A block is a signed set of transactions created by a delegate and permanently committed to the SXP blockchain. It is not possible to POST a block through the public API. Relay Nodes accept only blocks posted by a delegate at the correct time through the internal API. List All Blocks \u00b6 const response = client . api ( \"blocks\" ). all (); >>> Promise < IResponse < T >> Retrieve a Block \u00b6 const response = client . api ( \"blocks\" ). get ( \"validBlockId\" ); >>> Promise < IResponse < T >> List All Transactions of a Block \u00b6 const response = client . api ( \"blocks\" ). transactions ( \"validBlockId\" ); >>> Promise < IResponse < T >> Search All Blocks \u00b6 const response = client . api ( \"blocks\" ). search ({ \"id\" : \"validBlockId\" }); >>> Promise < IResponse < T >> Bridgechains \u00b6 This service API grants access to the bridgechain resource. This can be used to access all registered bridgechains on the network. List All Bridgechains \u00b6 const response = client . api ( \"bridgechains\" ). all (); >>> Promise < IResponse < T >> Retrieve a Bridgechain \u00b6 const response = client . api ( \"bridgechains\" ). get ( \"validId\" ); >>> Promise < IResponse < T >> Search All Bridgechains \u00b6 const response = client . api ( \"bridgechains\" ). search ({ \"bridgechainId\" : \"validId\" }); >>> Promise < IResponse < T >> Businesses \u00b6 This service API grants access to the business resource. This can be used to access all registered businesses on the network. List All Businesses \u00b6 const response = client . api ( \"businesses\" ). all (); >>> Promise < IResponse < T >> Retrieve a Business \u00b6 const response = client . api ( \"businesses\" ). get ( \"validId\" ); >>> Promise < IResponse < T >> Retrieve all Business Bridgechains \u00b6 const response = client . api ( \"businesses\" ). bridgechains ( \"validId\" ); >>> Promise < IResponse < T >> Search All Businesses \u00b6 const response = client . api ( \"businesses\" ). search ({ \"businessId\" : \"validId\" }); >>> Promise < IResponse < T >> Delegates \u00b6 The client SDK can be used to query the delegate resource . A delegate is a regular wallet that has broadcast a registration transaction, acquired a sufficient number of votes, and has a Relay Node configured to forge new blocks through a forger module. At any time only 51 delegates are active. They are cost-efficient miners running the SXP network. Voters are wallets which have broadcast a vote transaction on a delegate. A vote remains active until an un-vote transaction is sent (it does not have to be recast unless a wallet wishes to change from delegate). Voting for a delegate does not give the delegate access to the wallet nor does it lock the coins in it. List All Delegates \u00b6 const response = client . api ( \"delegates\" ). all (); >>> Promise < IResponse < T >> Retrieve a Delegate \u00b6 const response = client . api ( \"delegates\" ). get ( \"validId\" ); >>> Promise < IResponse < T >> List All Blocks of a Delegate \u00b6 const response = client . api ( \"delegates\" ). blocks ( \"validId\" ); >>> Promise < IResponse < T >> List All Voters of a Delegate \u00b6 const response = client . api ( \"delegates\" ). voters ( \"validId\" ); >>> Promise < IResponse < T >> Locks \u00b6 This service API grants access to the lock resource. This can be used to access all locks initiated for wallets. List All Locks \u00b6 const response = client . api ( \"locks\" ). all (); >>> Promise < IResponse < T >> Retrieve a Lock \u00b6 const response = client . api ( \"locks\" ). get ( \"validId\" ); >>> Promise < IResponse < T >> Search Locks \u00b6 const response = client . api ( \"locks\" ). search ({ \"lockId\" : \"validId\" }); >>> Promise < IResponse < T >> Get Unlocked Locks \u00b6 const response = client . api ( \"locks\" ). unlocked ({ ids : [ \"validId\" ]}); >>> Promise < IResponse < T >> Node \u00b6 The SXP network consists of different anonymous nodes (servers), maintaining the public ledger, validating transactions and blocks and providing APIs. The node resource allows for querying the health and configurations of the node used by the instantiated client. Retrieve the Configuration \u00b6 const response = client . api ( \"node\" ). configuration (); >>> Promise < IResponse < T >> Retrieve the Status \u00b6 const response = client . api ( \"node\" ). status (); >>> Promise < IResponse < T >> Retrieve the Syncing Status \u00b6 const response = client . api ( \"node\" ). syncing (); >>> Promise < IResponse < T >> Retrieve the Fees \u00b6 const response = client . api ( \"node\" ). fees (); >>> Promise < IResponse < T >> Peers \u00b6 Each node is connected to a set of peers, which are Relay or Delegate Nodes as well. The peers resource provides access to all peers connected to our node. Peers have made their Public API available for use; however for mission-critical queries and transaction posting you should use a node which is under your control. List All Peers \u00b6 const response = client . api ( \"peers\" ). all (); >>> Promise < IResponse < T >> Retrieve a Peer \u00b6 const response = client . api ( \"peers\" ). get ( \"validIpAddress\" ); >>> Promise < IResponse < T >> Rounds \u00b6 This service API grants access to the round resource. This can be used to access all round information for the network. List Delegates for a Round \u00b6 const response = client . api ( \"rounds\" ). delegates ( roundNumber ); >>> Promise < IResponse < T >> Transactions \u00b6 The heart of any blockchain is formed by its transactions; state-altering payloads signed by a wallet. Most likely you will be querying for transactions most often, using the transaction resource . A transaction is the only object which may be posted by a non-delegate. It requires a signature from a wallet containing a sufficient amount of SXP. Create a Transaction \u00b6 const response = client . api ( \"transactions\" ). create ([...]); >>> Promise < IResponse < T >> Retrieve a Transaction \u00b6 const response = client . api ( \"transactions\" ). get ( \"validId\" ); >>> Promise < IResponse < T >> List All Transactions \u00b6 const response = client . api ( \"transactions\" ). all (); >>> Promise < IResponse < T >> List All Unconfirmed Transactions \u00b6 const response = client . api ( \"transactions\" ). allUnconfirmed (); >>> Promise < IResponse < T >> Get Unconfirmed Transaction \u00b6 const response = client . api ( \"transactions\" ). getUnconfirmed ( \"validId\" ); >>> Promise < IResponse < T >> Search Transactions \u00b6 const response = client . api ( \"transactions\" ). search ({ \"id\" : \"validId\" }); >>> Promise < IResponse < T >> List Transaction Types \u00b6 const response = client . api ( \"transactions\" ). types (); >>> Promise < IResponse < T >> Votes \u00b6 A vote is a transaction sub-type, where the asset field contains a votes object and the transaction.type is 3 . List All Votes \u00b6 const response = client . api ( \"votes\" ). all (); >>> Promise < IResponse < T >> Retrieve a Vote \u00b6 const response = client . api ( \"votes\" ). get ( \"validId\" ); >>> Promise < IResponse < T >> Wallets \u00b6 The wallet resource provides access to: Wallets. Incoming and outgoing transactions per wallet. Each wallet's votes. Retrieve All Wallets \u00b6 const response = client . api ( \"wallets\" ). all (); >>> Promise < IResponse < T >> Retrieve a Wallet \u00b6 const response = client . api ( \"wallets\" ). get ( \"validId\" ); >>> Promise < IResponse < T >> List All Transactions of a Wallet \u00b6 const response = client . api ( \"wallets\" ). transactions ( \"validId\" ); >>> Promise < IResponse < T >> List All Received Transactions of a Wallet \u00b6 const response = client . api ( \"wallets\" ). transactionsReceived ( \"validId\" ); >>> Promise < IResponse < T >> List All Sent Transactions of a Wallet \u00b6 const response = client . api ( \"wallets\" ). transactionsSent ( \"validId\" ); >>> Promise < IResponse < T >> List All Votes of a Wallet \u00b6 const response = client . api ( \"wallets\" ). votes ( \"validId\" ); >>> Promise < IResponse < T >> List All Locks of a Wallet \u00b6 const response = client . api ( \"wallets\" ). locks ( \"validId\" ); >>> Promise < IResponse < T >> List All Top Wallets \u00b6 const response = client . api ( \"wallets\" ). top (); >>> Promise < IResponse < T >> Search All Wallets \u00b6 const response = client . api ( \"wallets\" ). search ({ \"address\" : \"validId\" }); >>> Promise < IResponse < T >>","title":"Examples"},{"location":"sdk/typescript/client/examples/#examples","text":"","title":"Examples"},{"location":"sdk/typescript/client/examples/#initialization","text":"const { Connection } = require ( \"@solar-network/client\" ); const client = new Connection ( ` ${ server } /api` );","title":"Initialization"},{"location":"sdk/typescript/client/examples/#blocks","text":"This service API grants access to the blocks resource . A block is a signed set of transactions created by a delegate and permanently committed to the SXP blockchain. It is not possible to POST a block through the public API. Relay Nodes accept only blocks posted by a delegate at the correct time through the internal API.","title":"Blocks"},{"location":"sdk/typescript/client/examples/#list-all-blocks","text":"const response = client . api ( \"blocks\" ). all (); >>> Promise < IResponse < T >>","title":"List All Blocks"},{"location":"sdk/typescript/client/examples/#retrieve-a-block","text":"const response = client . api ( \"blocks\" ). get ( \"validBlockId\" ); >>> Promise < IResponse < T >>","title":"Retrieve a Block"},{"location":"sdk/typescript/client/examples/#list-all-transactions-of-a-block","text":"const response = client . api ( \"blocks\" ). transactions ( \"validBlockId\" ); >>> Promise < IResponse < T >>","title":"List All Transactions of a Block"},{"location":"sdk/typescript/client/examples/#search-all-blocks","text":"const response = client . api ( \"blocks\" ). search ({ \"id\" : \"validBlockId\" }); >>> Promise < IResponse < T >>","title":"Search All Blocks"},{"location":"sdk/typescript/client/examples/#bridgechains","text":"This service API grants access to the bridgechain resource. This can be used to access all registered bridgechains on the network.","title":"Bridgechains"},{"location":"sdk/typescript/client/examples/#list-all-bridgechains","text":"const response = client . api ( \"bridgechains\" ). all (); >>> Promise < IResponse < T >>","title":"List All Bridgechains"},{"location":"sdk/typescript/client/examples/#retrieve-a-bridgechain","text":"const response = client . api ( \"bridgechains\" ). get ( \"validId\" ); >>> Promise < IResponse < T >>","title":"Retrieve a Bridgechain"},{"location":"sdk/typescript/client/examples/#search-all-bridgechains","text":"const response = client . api ( \"bridgechains\" ). search ({ \"bridgechainId\" : \"validId\" }); >>> Promise < IResponse < T >>","title":"Search All Bridgechains"},{"location":"sdk/typescript/client/examples/#businesses","text":"This service API grants access to the business resource. This can be used to access all registered businesses on the network.","title":"Businesses"},{"location":"sdk/typescript/client/examples/#list-all-businesses","text":"const response = client . api ( \"businesses\" ). all (); >>> Promise < IResponse < T >>","title":"List All Businesses"},{"location":"sdk/typescript/client/examples/#retrieve-a-business","text":"const response = client . api ( \"businesses\" ). get ( \"validId\" ); >>> Promise < IResponse < T >>","title":"Retrieve a Business"},{"location":"sdk/typescript/client/examples/#retrieve-all-business-bridgechains","text":"const response = client . api ( \"businesses\" ). bridgechains ( \"validId\" ); >>> Promise < IResponse < T >>","title":"Retrieve all Business Bridgechains"},{"location":"sdk/typescript/client/examples/#search-all-businesses","text":"const response = client . api ( \"businesses\" ). search ({ \"businessId\" : \"validId\" }); >>> Promise < IResponse < T >>","title":"Search All Businesses"},{"location":"sdk/typescript/client/examples/#delegates","text":"The client SDK can be used to query the delegate resource . A delegate is a regular wallet that has broadcast a registration transaction, acquired a sufficient number of votes, and has a Relay Node configured to forge new blocks through a forger module. At any time only 51 delegates are active. They are cost-efficient miners running the SXP network. Voters are wallets which have broadcast a vote transaction on a delegate. A vote remains active until an un-vote transaction is sent (it does not have to be recast unless a wallet wishes to change from delegate). Voting for a delegate does not give the delegate access to the wallet nor does it lock the coins in it.","title":"Delegates"},{"location":"sdk/typescript/client/examples/#list-all-delegates","text":"const response = client . api ( \"delegates\" ). all (); >>> Promise < IResponse < T >>","title":"List All Delegates"},{"location":"sdk/typescript/client/examples/#retrieve-a-delegate","text":"const response = client . api ( \"delegates\" ). get ( \"validId\" ); >>> Promise < IResponse < T >>","title":"Retrieve a Delegate"},{"location":"sdk/typescript/client/examples/#list-all-blocks-of-a-delegate","text":"const response = client . api ( \"delegates\" ). blocks ( \"validId\" ); >>> Promise < IResponse < T >>","title":"List All Blocks of a Delegate"},{"location":"sdk/typescript/client/examples/#list-all-voters-of-a-delegate","text":"const response = client . api ( \"delegates\" ). voters ( \"validId\" ); >>> Promise < IResponse < T >>","title":"List All Voters of a Delegate"},{"location":"sdk/typescript/client/examples/#locks","text":"This service API grants access to the lock resource. This can be used to access all locks initiated for wallets.","title":"Locks"},{"location":"sdk/typescript/client/examples/#list-all-locks","text":"const response = client . api ( \"locks\" ). all (); >>> Promise < IResponse < T >>","title":"List All Locks"},{"location":"sdk/typescript/client/examples/#retrieve-a-lock","text":"const response = client . api ( \"locks\" ). get ( \"validId\" ); >>> Promise < IResponse < T >>","title":"Retrieve a Lock"},{"location":"sdk/typescript/client/examples/#search-locks","text":"const response = client . api ( \"locks\" ). search ({ \"lockId\" : \"validId\" }); >>> Promise < IResponse < T >>","title":"Search Locks"},{"location":"sdk/typescript/client/examples/#get-unlocked-locks","text":"const response = client . api ( \"locks\" ). unlocked ({ ids : [ \"validId\" ]}); >>> Promise < IResponse < T >>","title":"Get Unlocked Locks"},{"location":"sdk/typescript/client/examples/#node","text":"The SXP network consists of different anonymous nodes (servers), maintaining the public ledger, validating transactions and blocks and providing APIs. The node resource allows for querying the health and configurations of the node used by the instantiated client.","title":"Node"},{"location":"sdk/typescript/client/examples/#retrieve-the-configuration","text":"const response = client . api ( \"node\" ). configuration (); >>> Promise < IResponse < T >>","title":"Retrieve the Configuration"},{"location":"sdk/typescript/client/examples/#retrieve-the-status","text":"const response = client . api ( \"node\" ). status (); >>> Promise < IResponse < T >>","title":"Retrieve the Status"},{"location":"sdk/typescript/client/examples/#retrieve-the-syncing-status","text":"const response = client . api ( \"node\" ). syncing (); >>> Promise < IResponse < T >>","title":"Retrieve the Syncing Status"},{"location":"sdk/typescript/client/examples/#retrieve-the-fees","text":"const response = client . api ( \"node\" ). fees (); >>> Promise < IResponse < T >>","title":"Retrieve the Fees"},{"location":"sdk/typescript/client/examples/#peers","text":"Each node is connected to a set of peers, which are Relay or Delegate Nodes as well. The peers resource provides access to all peers connected to our node. Peers have made their Public API available for use; however for mission-critical queries and transaction posting you should use a node which is under your control.","title":"Peers"},{"location":"sdk/typescript/client/examples/#list-all-peers","text":"const response = client . api ( \"peers\" ). all (); >>> Promise < IResponse < T >>","title":"List All Peers"},{"location":"sdk/typescript/client/examples/#retrieve-a-peer","text":"const response = client . api ( \"peers\" ). get ( \"validIpAddress\" ); >>> Promise < IResponse < T >>","title":"Retrieve a Peer"},{"location":"sdk/typescript/client/examples/#rounds","text":"This service API grants access to the round resource. This can be used to access all round information for the network.","title":"Rounds"},{"location":"sdk/typescript/client/examples/#list-delegates-for-a-round","text":"const response = client . api ( \"rounds\" ). delegates ( roundNumber ); >>> Promise < IResponse < T >>","title":"List Delegates for a Round"},{"location":"sdk/typescript/client/examples/#transactions","text":"The heart of any blockchain is formed by its transactions; state-altering payloads signed by a wallet. Most likely you will be querying for transactions most often, using the transaction resource . A transaction is the only object which may be posted by a non-delegate. It requires a signature from a wallet containing a sufficient amount of SXP.","title":"Transactions"},{"location":"sdk/typescript/client/examples/#create-a-transaction","text":"const response = client . api ( \"transactions\" ). create ([...]); >>> Promise < IResponse < T >>","title":"Create a Transaction"},{"location":"sdk/typescript/client/examples/#retrieve-a-transaction","text":"const response = client . api ( \"transactions\" ). get ( \"validId\" ); >>> Promise < IResponse < T >>","title":"Retrieve a Transaction"},{"location":"sdk/typescript/client/examples/#list-all-transactions","text":"const response = client . api ( \"transactions\" ). all (); >>> Promise < IResponse < T >>","title":"List All Transactions"},{"location":"sdk/typescript/client/examples/#list-all-unconfirmed-transactions","text":"const response = client . api ( \"transactions\" ). allUnconfirmed (); >>> Promise < IResponse < T >>","title":"List All Unconfirmed Transactions"},{"location":"sdk/typescript/client/examples/#get-unconfirmed-transaction","text":"const response = client . api ( \"transactions\" ). getUnconfirmed ( \"validId\" ); >>> Promise < IResponse < T >>","title":"Get Unconfirmed Transaction"},{"location":"sdk/typescript/client/examples/#search-transactions","text":"const response = client . api ( \"transactions\" ). search ({ \"id\" : \"validId\" }); >>> Promise < IResponse < T >>","title":"Search Transactions"},{"location":"sdk/typescript/client/examples/#list-transaction-types","text":"const response = client . api ( \"transactions\" ). types (); >>> Promise < IResponse < T >>","title":"List Transaction Types"},{"location":"sdk/typescript/client/examples/#votes","text":"A vote is a transaction sub-type, where the asset field contains a votes object and the transaction.type is 3 .","title":"Votes"},{"location":"sdk/typescript/client/examples/#list-all-votes","text":"const response = client . api ( \"votes\" ). all (); >>> Promise < IResponse < T >>","title":"List All Votes"},{"location":"sdk/typescript/client/examples/#retrieve-a-vote","text":"const response = client . api ( \"votes\" ). get ( \"validId\" ); >>> Promise < IResponse < T >>","title":"Retrieve a Vote"},{"location":"sdk/typescript/client/examples/#wallets","text":"The wallet resource provides access to: Wallets. Incoming and outgoing transactions per wallet. Each wallet's votes.","title":"Wallets"},{"location":"sdk/typescript/client/examples/#retrieve-all-wallets","text":"const response = client . api ( \"wallets\" ). all (); >>> Promise < IResponse < T >>","title":"Retrieve All Wallets"},{"location":"sdk/typescript/client/examples/#retrieve-a-wallet","text":"const response = client . api ( \"wallets\" ). get ( \"validId\" ); >>> Promise < IResponse < T >>","title":"Retrieve a Wallet"},{"location":"sdk/typescript/client/examples/#list-all-transactions-of-a-wallet","text":"const response = client . api ( \"wallets\" ). transactions ( \"validId\" ); >>> Promise < IResponse < T >>","title":"List All Transactions of a Wallet"},{"location":"sdk/typescript/client/examples/#list-all-received-transactions-of-a-wallet","text":"const response = client . api ( \"wallets\" ). transactionsReceived ( \"validId\" ); >>> Promise < IResponse < T >>","title":"List All Received Transactions of a Wallet"},{"location":"sdk/typescript/client/examples/#list-all-sent-transactions-of-a-wallet","text":"const response = client . api ( \"wallets\" ). transactionsSent ( \"validId\" ); >>> Promise < IResponse < T >>","title":"List All Sent Transactions of a Wallet"},{"location":"sdk/typescript/client/examples/#list-all-votes-of-a-wallet","text":"const response = client . api ( \"wallets\" ). votes ( \"validId\" ); >>> Promise < IResponse < T >>","title":"List All Votes of a Wallet"},{"location":"sdk/typescript/client/examples/#list-all-locks-of-a-wallet","text":"const response = client . api ( \"wallets\" ). locks ( \"validId\" ); >>> Promise < IResponse < T >>","title":"List All Locks of a Wallet"},{"location":"sdk/typescript/client/examples/#list-all-top-wallets","text":"const response = client . api ( \"wallets\" ). top (); >>> Promise < IResponse < T >>","title":"List All Top Wallets"},{"location":"sdk/typescript/client/examples/#search-all-wallets","text":"const response = client . api ( \"wallets\" ). search ({ \"address\" : \"validId\" }); >>> Promise < IResponse < T >>","title":"Search All Wallets"},{"location":"sdk/typescript/client/getting-started/","text":"NodeJS installation \u00b6 NodeJS can be downloaded here . Alternatively you can install NodeJS through your operating system packager manager . An excellent way to manage your NodeJS installation and be able to work with multiple version is to go through NVM . Yarn \u00b6 Yarn is a package manager for your code. It allows you to use and share code with other developers from around the world. Yarn does this quickly, securely, and reliably so you don\u2019t ever have to worry. Install Yarn \u00b6 Instructions on how to install Yarn can be found here Install package with Yarn \u00b6 yarn add @solar-network/client Development \u00b6 Fork the package . Clone your forked repository. git clone https://github.com/<githubusername>/javascript-client Next, move into the fresh cloned directory. cd javascript-client Proceed to install the dependencies. yarn install Dependencies are now installed, you can now run the tests to see if everything is running as it should. yarn test","title":"Getting Started"},{"location":"sdk/typescript/client/getting-started/#nodejs-installation","text":"NodeJS can be downloaded here . Alternatively you can install NodeJS through your operating system packager manager . An excellent way to manage your NodeJS installation and be able to work with multiple version is to go through NVM .","title":"NodeJS installation"},{"location":"sdk/typescript/client/getting-started/#yarn","text":"Yarn is a package manager for your code. It allows you to use and share code with other developers from around the world. Yarn does this quickly, securely, and reliably so you don\u2019t ever have to worry.","title":"Yarn"},{"location":"sdk/typescript/client/getting-started/#install-yarn","text":"Instructions on how to install Yarn can be found here","title":"Install Yarn"},{"location":"sdk/typescript/client/getting-started/#install-package-with-yarn","text":"yarn add @solar-network/client","title":"Install package with Yarn"},{"location":"sdk/typescript/client/getting-started/#development","text":"Fork the package . Clone your forked repository. git clone https://github.com/<githubusername>/javascript-client Next, move into the fresh cloned directory. cd javascript-client Proceed to install the dependencies. yarn install Dependencies are now installed, you can now run the tests to see if everything is running as it should. yarn test","title":"Development"},{"location":"sdk/typescript/client/intro/","text":"Client \u00b6 Install package with Yarn \u00b6 yarn add @solar-network/client Development \u00b6 Fork the package . Clone your forked repository. git clone https://github.com/<githubusername>/typescript-client Next, move into the fresh cloned directory. cd typescript-client Proceed to install the dependencies. yarn install Dependencies are now installed, you can now run the tests to see if everything is running as it should. yarn test","title":"Getting Started"},{"location":"sdk/typescript/client/intro/#client","text":"","title":"Client"},{"location":"sdk/typescript/client/intro/#install-package-with-yarn","text":"yarn add @solar-network/client","title":"Install package with Yarn"},{"location":"sdk/typescript/client/intro/#development","text":"Fork the package . Clone your forked repository. git clone https://github.com/<githubusername>/typescript-client Next, move into the fresh cloned directory. cd typescript-client Proceed to install the dependencies. yarn install Dependencies are now installed, you can now run the tests to see if everything is running as it should. yarn test","title":"Development"},{"location":"sdk/typescript/crypto/api-documentation/","text":"API Documentation \u00b6 Crypto\\Blocks\\BlockFactory \u00b6 fromHex() \u00b6 public static fromHex ( hex : string ) Generate Block object from HEX. Parameters \u00b6 Type Name Required Description string hex Yes Block content Return Value \u00b6 IBlock fromBytes() \u00b6 public static fromBytes ( buffer : Buffer ) Generate Block object from a Buffer. Parameters \u00b6 Type Name Required Description Buffer buffer Yes Block content Return Value \u00b6 IBlock fromJson() \u00b6 public static fromJson ( json : IBlockJson ) Generate Block object from JSON. Parameters \u00b6 Type Name Required Description IBlockJson json Yes Block content Return Value \u00b6 IBlock fromData() \u00b6 public static fromData ( data : IBlockData , options : { deserializeTransactionsUnchecked? : boolean } = {}) Generate Block object from Block data. Parameters \u00b6 Type Name Required Description IBlockData data Yes Block content object options Yes Options used for parsing block data Return Value \u00b6 IBlock Crypto\\Blocks\\Serializer \u00b6 size() \u00b6 public static size ( block : IBlock ) Get size of Block. Parameters \u00b6 Type Name Required Description IBlock block Yes Block object Return Value \u00b6 number serializeWithTransactions() \u00b6 public static serializeWithTransactions ( block : IBlockData ) Serialize Block with Transactions. Parameters \u00b6 Type Name Required Description IBlockData block Yes Block object Return Value \u00b6 Buffer serialize() \u00b6 public static serialize ( block : IBlockData , includeSignature : boolean = true ) Serialize Block without Transactions. Parameters \u00b6 Type Name Required Description IBlockData block Yes Block object boolean includeSignature Yes Whether to include signature in serialization Return Value \u00b6 Buffer Crypto\\Crypto\\HashAlgorithms \u00b6 ripemd160() \u00b6 public static ripemd160 ( buffer : Buffer | string ) Hash with RIPEMD-160. Parameters \u00b6 Type Name Required Description Buffer, string buffer Yes String or Buffer to generate hash for Return Value \u00b6 Buffer sha1() \u00b6 public static sha1 ( buffer : Buffer | string ) Hash with SHA-1. Parameters \u00b6 Type Name Required Description Buffer, string buffer Yes String or Buffer to generate hash for Return Value \u00b6 Buffer sha256() \u00b6 public static sha256 ( buffer : Buffer | string | Buffer []) Hash with SHA-256. Parameters \u00b6 Type Name Required Description Buffer, string buffer Yes String or Buffer to generate hash for Return Value \u00b6 Buffer hash160() \u00b6 public static hash160 ( buffer : Buffer | string ) Hash with Hash160. Parameters \u00b6 Type Name Required Description Buffer, string buffer Yes String or Buffer to generate hash for Return Value \u00b6 Buffer hash256() \u00b6 public static hash256 ( buffer : Buffer | string ) Hash with Hash256. Parameters \u00b6 Type Name Required Description Buffer, string buffer Yes String or Buffer to generate hash for Return Value \u00b6 Buffer Crypto\\Crypto\\Hash \u00b6 signECDSA() \u00b6 public static signECDSA ( hash : Buffer , keys : IKeyPair ) Sign hash with ECDSA. Parameters \u00b6 Type Name Required Description Buffer hash Yes Hash to sign IKeyPair keys Yes Keys to sign hash with Return Value \u00b6 string verifyECDSA() \u00b6 public static verifyECDSA ( hash : Buffer , signature : Buffer | string , publicKey : Buffer | string ) Verify ECDSA signature. Parameters \u00b6 Type Name Required Description Buffer hash Yes Hash to verify Buffer, string signature Yes Signature of hash Buffer, string publicKey Yes Public key of wallet which signed the hash Return Value \u00b6 boolean signSchnorr() \u00b6 public static signSchnorr ( hash : Buffer , keys : IKeyPair ) Sign hash with Schnorr. Parameters \u00b6 Type Name Required Description Buffer hash Yes Hash to sign IKeyPair keys Yes Keys to sign hash with Return Value \u00b6 string verifySchnorr() \u00b6 public static verifySchnorr ( hash : Buffer , signature : Buffer | string , publicKey : Buffer | string ) Verify Schnorr signature. Parameters \u00b6 Type Name Required Description Buffer hash Yes Hash to verify Buffer, string signature Yes Signature of hash Buffer, string publicKey Yes Public key of wallet which signed the hash Return Value \u00b6 boolean Crypto\\Crypto\\HDWallet \u00b6 fromMnemonic() \u00b6 public static fromMnemonic ( mnemonic : string , passphrase? : string ) Generate BIP32 Wallet from mnemonic. Parameters \u00b6 Type Name Required Description string mnemonic Yes INSERT_DESCRIPTION string passphrase No INSERT_DESCRIPTION Return Value \u00b6 BIP32Interface fromKeys() \u00b6 public static fromKeys ( keys : IKeyPair , chainCode : Buffer ) Generate BIP32 Wallet from KeyPair. Parameters \u00b6 Type Name Required Description IKeyPair keys Yes INSERT_DESCRIPTION Buffer chainCode Yes INSERT_DESCRIPTION Return Value \u00b6 BIP32Interface getKeys() \u00b6 public static getKeys ( node : BIP32Interface ) Get keys for BIP32 Wallet. Parameters \u00b6 Type Name Required Description BIP32Interface node Yes BIP32 Wallet to get keys for Return Value \u00b6 IKeyPair deriveSlip44() \u00b6 public static deriveSlip44 ( root : BIP32Interface , hardened : boolean = true ) Determine Slip44 for BIP32 Wallet. Parameters \u00b6 Type Name Required Description BIP32Interface root Yes BIP32 Wallet to determine Slip44 for boolean hardened Yes INSERT_DESCRIPTION Return Value \u00b6 BIP32Interface deriveNetwork() \u00b6 public static deriveNetwork ( root : BIP32Interface ) Determine Network for BIP32 Wallet. Parameters \u00b6 Type Name Required Description BIP32Interface root Yes BIP32 Wallet to determine network for Return Value \u00b6 BIP32Interface Crypto\\Crypto\\Message \u00b6 sign() \u00b6 public static sign ( message : string , passphrase : string ) Sign a message using the given passphrase. Parameters \u00b6 Type Name Required Description string message Yes Message string passphrase Yes Passphrase Return Value \u00b6 IMessage signWithWif() \u00b6 public static signWithWif ( message : string , wif : string , network? : INetwork ) Sign a message using the given WIF string. Parameters \u00b6 Type Name Required Description string message Yes Message string wif Yes Network WIF INetwork network No Network Return Value \u00b6 IMessage verify() \u00b6 public static verify ({ message , publicKey , signature } : IMessage ) Verify the message contents Parameters \u00b6 Type Name Required Description IMessage object Yes Message Return Value \u00b6 boolean Crypto\\Crypto\\Slots \u00b6 getTime() \u00b6 public static getTime ( time? : number ) Get the time diff between now and network start. Parameters \u00b6 Type Name Required Description number time No Network start time Return Value \u00b6 number getTimeInMsUntilNextSlot() \u00b6 public static getTimeInMsUntilNextSlot () Get the time (in milliseconds) until the start of the next slot. Return Value \u00b6 number getSlotNumber() \u00b6 public static getSlotNumber ( epoch? : number ) Get the slot number. Parameters \u00b6 Type Name Required Description number epoch No Epoch time Return Value \u00b6 number getSlotTime() \u00b6 public static getSlotTime ( slot : number ) Get the slot time. Parameters \u00b6 Type Name Required Description number slot Yes Slot Return Value \u00b6 number getNextSlot() \u00b6 public static getNextSlot () Get the next slot. Return Value \u00b6 number isForgingAllowed() \u00b6 public static isForgingAllowed ( epoch? : number ) Verify is forging is allowed. Parameters \u00b6 Type Name Required Description number epoch No Epoch time Return Value \u00b6 boolean Crypto\\Identities\\Address \u00b6 fromPassphrase() \u00b6 public static fromPassphrase ( passphrase : string , networkVersion? : number ) Derive the address from the given passphrase. Parameters \u00b6 Type Name Required Description string passphrase Yes Passphrase number networkVersion No Version of the network Return Value \u00b6 string fromPublicKey() \u00b6 public static fromPublicKey ( publicKey : string , networkVersion? : number ) Derive a (multisig) address from a multi signature asset. Parameters \u00b6 Type Name Required Description string publicKey Yes Public key number networkVersion No Version of the network Return Value \u00b6 string fromWIF() \u00b6 public static fromWIF ( wif : string , network? : NetworkType ) Derive the address from a WIF string. Parameters \u00b6 Type Name Required Description string wif Yes WIF NetworkType network No Network to generate address for Return Value \u00b6 string fromMultiSignatureAsset() \u00b6 public static fromMultiSignatureAsset ( asset : IMultiSignatureAsset , networkVersion? : number ) Derive the address from the given multi signature asset. Parameters \u00b6 Type Name Required Description IMultiSignatureAsset asset Yes Address to validate number networkVersion No Version of the network Return Value \u00b6 string fromPrivateKey() \u00b6 public static fromPrivateKey ( privateKey , networkVersion? : number ) Derive the address from the given private key. Parameters \u00b6 Type Name Required Description any privateKey Yes Private key to derive address for number networkVersion No Version of the network Return Value \u00b6 string fromBuffer() \u00b6 public static fromBuffer ( buffer : Buffer ) Derive the address from a Buffer. Parameters \u00b6 Type Name Required Description Buffer buffer Yes Buffer to derive address from Return Value \u00b6 string toBuffer() \u00b6 public static toBuffer ( address : string ) Convert address to a Buffer. Parameters \u00b6 Type Name Required Description string address Yes Address to convert to buffer Return Value \u00b6 { addressBuffer: Buffer; addressError?: string } validate() \u00b6 public static validate ( address : string , networkVersion? : number ) Validate the given address. Parameters \u00b6 Type Name Required Description string address Yes Address to validate number networkVersion No Version of the network Return Value \u00b6 boolean Crypto\\Identities\\Keys \u00b6 fromPassphrase() \u00b6 public static fromPassphrase ( passphrase : string , compressed : boolean = true ) Derive the keys from the given passphrase. Parameters \u00b6 Type Name Required Description string passphrase Yes Passphrase boolean compressed Yes Compression flag Return Value \u00b6 IKeyPair fromPrivateKey() \u00b6 public static fromPrivateKey ( privateKey : Buffer | string , compressed : boolean = true ) Derive the keys from the given private key. Parameters \u00b6 Type Name Required Description Buffer, string privateKey Yes Private Key to derive keys from boolean compressed Yes Compression flag Return Value \u00b6 IKeyPair fromWIF() \u00b6 public static fromWIF ( wifKey : string , network? : INetwork ) Derive the keys from the given WIF. Parameters \u00b6 Type Name Required Description string wifKey Yes Private key INetwork network No Network Return Value \u00b6 IKeyPair Crypto\\Identities\\PrivateKey \u00b6 fromPassphrase() \u00b6 public static fromPassphrase ( passphrase : string ) Derive the private key for the given passphrase. Parameters \u00b6 Type Name Required Description string passphrase Yes Passphrase Return Value \u00b6 string fromWIF() \u00b6 public static fromWIF ( wif : string , network? : NetworkType ) Create a private key instance from a hex string. Parameters \u00b6 Type Name Required Description string wif Yes Network WIF NetworkType network No Network Return Value \u00b6 string Crypto\\Identities\\PublicKey \u00b6 fromPassphrase() \u00b6 public static fromPassphrase ( passphrase : string ) Derive the public key from the given passphrase. Parameters \u00b6 Type Name Required Description string passphrase Yes Passphrase Return Value \u00b6 string fromWIF() \u00b6 public static fromWIF ( wif : string , network? : NetworkType ) Derive the public key from the given WIF. Parameters \u00b6 Type Name Required Description string wif Yes WIF to derive public key from NetworkType network No Network Return Value \u00b6 string fromMultiSignatureAsset() \u00b6 public static fromMultiSignatureAsset ( asset : IMultiSignatureAsset ) Derive the public key from the given multi signature asset. Parameters \u00b6 Type Name Required Description IMultiSignatureAsset asset Yes Asset Return Value \u00b6 string validate() \u00b6 public static validate ( publicKey : string , networkVersion? : number ) Validate the given public key. Parameters \u00b6 Type Name Required Description string publicKey Yes Public key number networkVersion No Network version Return Value \u00b6 boolean Crypto\\Identities\\WIF \u00b6 fromPassphrase() \u00b6 public static fromPassphrase ( passphrase : string , network? : INetwork ) Derive the WIF from the given passphrase. Parameters \u00b6 Type Name Required Description string passphrase Yes Passphrase to derive WIF from INetwork network No Network wif Return Value \u00b6 string fromKeys() \u00b6 public static fromKeys ( keys : IKeyPair , network? : INetwork ) Derive the WIF from the given keys. Parameters \u00b6 Type Name Required Description IKeyPair keys Yes Keys INetwork network No Network Return Value \u00b6 string Crypto\\Managers\\ConfigManager \u00b6 setConfig() \u00b6 public setConfig ( config : INetworkConfig ) Set the configuration. Parameters \u00b6 Type Name Required Description INetworkConfig config Yes Network configuration object Return Value \u00b6 void setFromPreset() \u00b6 public setFromPreset ( network : NetworkName ) Set the configuration from given presets. Parameters \u00b6 Type Name Required Description NetworkName network Yes Preset Return Value \u00b6 void getPreset() \u00b6 public getPreset ( network : NetworkName ) Get configuration preset. Parameters \u00b6 Type Name Required Description NetworkName network Yes Preset Return Value \u00b6 INetworkConfig all() \u00b6 public all () Get all configs. Return Value \u00b6 INetworkConfig set() \u00b6 public set < T = any > ( key : string , value : T ) Set a value for the specified network config key. Parameters \u00b6 Type Name Required Description string key Yes Key to set T value Yes Value to set Return Value \u00b6 void get() \u00b6 public get < T = any > ( key : string ) Get key. Parameters \u00b6 Type Name Required Description string key Yes Key to get Return Value \u00b6 T setHeight() \u00b6 public setHeight ( value : number ) Set network height. Parameters \u00b6 Type Name Required Description number value Yes Network height Return Value \u00b6 void getHeight() \u00b6 public getHeight () Get network height. Return Value \u00b6 number isNewMilestone() \u00b6 public isNewMilestone ( height? : number ) Verify if current height contains a milestone. Parameters \u00b6 Type Name Required Description number height No Height to check for milestone Return Value \u00b6 boolean getMilestone() \u00b6 public getMilestone ( height? : number ) Get milestone. Parameters \u00b6 Type Name Required Description number height No Network height Return Value \u00b6 { [key: string]: any } getMilestones() \u00b6 public getMilestones () Get all milestones. Return Value \u00b6 any Crypto\\Managers\\NetworkManager \u00b6 all() \u00b6 public static all () Get settings for all networks. Return Value \u00b6 Record<NetworkName, INetworkConfig> findByName() \u00b6 public static findByName ( name : NetworkName ) Get settings for a selected network, default network is testnet. Parameters \u00b6 Type Name Required Description NetworkName name Yes Network name Return Value \u00b6 INetworkConfig Crypto\\Transactions\\Deserializer \u00b6 deserialize() \u00b6 public static deserialize ( serialized : string | Buffer , options : IDeserializeOptions = {}) Deserialize Transaction into object. Parameters \u00b6 Type Name Required Description string, Buffer serialized Yes Serialized transaction IDeserializeOptions options Yes Options for deserializing Return Value \u00b6 ITransaction applyV1Compatibility() \u00b6 public static applyV1Compatibility ( transaction : ITransactionData ) Modify transaction to be v1 compatible. Parameters \u00b6 Type Name Required Description ITransactionData transaction Yes Transaction object Return Value \u00b6 void Crypto\\Transactions\\TransactionFactory \u00b6 fromHex() \u00b6 public static fromHex ( hex : string ) Create Transaction object from HEX. Parameters \u00b6 Type Name Required Description string hex Yes HEX of transaction Return Value \u00b6 ITransaction fromBytes() \u00b6 public static fromBytes ( buffer : Buffer , strict : boolean = true ) Create Transaction object from Buffer. Parameters \u00b6 Type Name Required Description Buffer buffer Yes Transaction buffer boolean strict Yes Strict creation from buffer Return Value \u00b6 ITransaction fromBytesUnsafe() \u00b6 public static fromBytesUnsafe ( buffer : Buffer , id? : string ) Create Transaction object from Buffer (unsafe). NOTE: Only use this internally when it is safe to assume the buffer has already been verified. Parameters \u00b6 Type Name Required Description Buffer buffer Yes Transaction buffer string id No ID override Return Value \u00b6 ITransaction fromJson() \u00b6 public static fromJson ( json : ITransactionJson ) Create Transaction object from JSON. Parameters \u00b6 Type Name Required Description ITransactionJson json Yes Transaction JSON object Return Value \u00b6 ITransaction fromData() \u00b6 public static fromData ( data : ITransactionData , strict : boolean = true ) Create Transaction object from Transaction data. Parameters \u00b6 Type Name Required Description ITransactionData data Yes Transaction object boolean strict Yes Strict conversion Return Value \u00b6 ITransaction Crypto\\Transactions\\Serializer \u00b6 getBytes() \u00b6 public static getBytes ( transaction : ITransactionData , options : ISerializeOptions = {}) Convert the transaction to its byte representation. Parameters \u00b6 Type Name Required Description ITransactionData transaction Yes Transaction ISerializeOptions options Yes Options Return Value \u00b6 Buffer serialize() \u00b6 public static serialize ( transaction : ITransaction , options : ISerializeOptions = {}) Perform AIP11 compliant serialization. Parameters \u00b6 Type Name Required Description ITransaction transaction Yes Transaction ISerializeOptions options Yes Options Return Value \u00b6 Buffer Crypto\\Transactions\\Signer \u00b6 sign() \u00b6 public static sign ( transaction : ITransactionData , keys : IKeyPair , options? : ISerializeOptions ) Sign the given transaction with the provided keys. Parameters \u00b6 Type Name Required Description ITransactionData transaction Yes Transaction IKeyPair keys Yes Keys ISerializeOptions options No Options Return Value \u00b6 string secondSign() \u00b6 public static secondSign ( transaction : ITransactionData , keys : IKeyPair ) Second sign the given transaction with the provided keys. Parameters \u00b6 Type Name Required Description ITransactionData transaction Yes Transaction IKeyPair keys Yes Keys Return Value \u00b6 string multiSign() \u00b6 public static multiSign ( transaction : ITransactionData , keys : IKeyPair , index : number = - 1 ) Multi sign the given transaction with the provided keys. Parameters \u00b6 Type Name Required Description ITransactionData transaction Yes Transaction IKeyPair keys Yes Keys number index Yes Index Return Value \u00b6 string Crypto\\Transactions\\Utils \u00b6 toBytes() \u00b6 public static toBytes ( data : ITransactionData ) Convert Transaction object to Buffer. Parameters \u00b6 Type Name Required Description ITransactionData data Yes Transaction object Return Value \u00b6 Buffer toHash() \u00b6 public static toHash ( transaction : ITransactionData , options? : ISerializeOptions ) Convert Transaction object to Hash. Parameters \u00b6 Type Name Required Description ITransactionData transaction Yes Transaction object ISerializeOptions options No Serialization options for generating hash Return Value \u00b6 Buffer getId() \u00b6 public static getId ( transaction : ITransactionData , options : ISerializeOptions = {}) Get Transaction ID of Transaction object. Parameters \u00b6 Type Name Required Description ITransactionData transaction Yes Transaction object ISerializeOptions options Yes Serialization options for generating hash Return Value \u00b6 string Crypto\\Transactions\\Verifier \u00b6 verify() \u00b6 public static verify ( data : ITransactionData ) Verify transaction. Parameters \u00b6 Type Name Required Description ITransactionData data Yes Transaction object Return Value \u00b6 boolean verifySecondSignature() \u00b6 public static verifySecondSignature ( transaction : ITransactionData , publicKey : string ) Verify second signature. Parameters \u00b6 Type Name Required Description ITransactionData transaction Yes Transaction object string publicKey Yes Public key Return Value \u00b6 boolean verifySignatures() \u00b6 public static verifySignatures ( transaction : ITransactionData , multiSignature : IMultiSignatureAsset ) Verify the signatures of a Transaction object. Parameters \u00b6 Type Name Required Description ITransactionData transaction Yes Transaction object IMultiSignatureAsset multiSignature Yes Asset for Multi-Signature wallets/transactions Return Value \u00b6 boolean verifyHash() \u00b6 public static verifyHash ( data : ITransactionData ) Verify transaction hash. Parameters \u00b6 Type Name Required Description ITransactionData data Yes Transaction Return Value \u00b6 boolean verifySchema() \u00b6 public static verifySchema ( data : ITransactionData , strict : boolean = true ) Verify transaction schema. Parameters \u00b6 Type Name Required Description ITransactionData data Yes Transaction boolean strict Yes Strict flag Return Value \u00b6 ISchemaValidationResult Crypto\\Transactions\\Builders\\BuilderFactory \u00b6 transfer() \u00b6 public static transfer () Initiate a Transfer transaction type. Return Value \u00b6 TransferBuilder secondSignature() \u00b6 public static secondSignature () Initiate a Second Signature transaction type. Return Value \u00b6 SecondSignatureBuilder delegateRegistration() \u00b6 public static delegateRegistration () Initiate a Delegate Resignation transaction type. Return Value \u00b6 DelegateRegistrationBuilder vote() \u00b6 public static vote () Initiate a Vote transaction type. Return Value \u00b6 VoteBuilder multiSignature() \u00b6 public static multiSignature () Initiate a Multi-Signature transaction type. Return Value \u00b6 MultiSignatureBuilder ipfs() \u00b6 public static ipfs () Initiate an IPFS transaction type. Return Value \u00b6 IPFSBuilder multiPayment() \u00b6 public static multiPayment () Initiate a Multi-Payment transaction type. Return Value \u00b6 MultiPaymentBuilder delegateResignation() \u00b6 public static delegateResignation () Initiate a Delegate Resignation transaction type. Return Value \u00b6 DelegateResignationBuilder htlcLock() \u00b6 public static htlcLock () Initiate a HTLC Lock transaction type. Return Value \u00b6 HtlcLockBuilder htlcClaim() \u00b6 public static htlcClaim () Initiate a HTLC Claim transaction type. Return Value \u00b6 HtlcClaimBuilder htlcRefund() \u00b6 public static htlcRefund () Initiate a HTLC Refund transaction type. Return Value \u00b6 HtlcRefundBuilder Crypto\\Transactions\\Builders\\Transactions\\DelegateRegistrationBuilder \u00b6 usernameAsset() \u00b6 public usernameAsset ( username : string ) Set the username to assign. Parameters \u00b6 Type Name Required Description string username Yes Delegate username Return Value \u00b6 DelegateRegistrationBuilder getStruct() \u00b6 public getStruct () Get transaction structure. Return Value \u00b6 ITransactionData Crypto\\Transactions\\Builders\\Transactions\\DelegateResignationBuilder \u00b6 getStruct() \u00b6 public getStruct () Get transaction structure. Return Value \u00b6 ITransactionData Crypto\\Transactions\\Builders\\Transactions\\HtlcClaimBuilder \u00b6 htlcClaimAsset() \u00b6 public htlcClaimAsset ( claimAsset : IHtlcClaimAsset ) Specify the HTLC Claim asset data for the Transaction. Parameters \u00b6 Type Name Required Description IHtlcClaimAsset claimAsset Yes Asset for a HTLC Claim Return Value \u00b6 HtlcClaimBuilder getStruct() \u00b6 public getStruct () Get transaction structure. Return Value \u00b6 ITransactionData Crypto\\Transactions\\Builders\\Transactions\\HtlcLockBuilder \u00b6 htlcLockAsset() \u00b6 public htlcLockAsset ( lockAsset : IHtlcLockAsset ) Specify the HTLC Lock asset data for the Transaction. Parameters \u00b6 Type Name Required Description IHtlcLockAsset lockAsset Yes Asset for a HTLC Lock Return Value \u00b6 HtlcLockBuilder getStruct() \u00b6 public getStruct () Get transaction structure. Return Value \u00b6 ITransactionData Crypto\\Transactions\\Builders\\Transactions\\HtlcRefundBuilder \u00b6 htlcRefundAsset() \u00b6 public htlcRefundAsset ( refundAsset : IHtlcRefundAsset ) Specify the HTLC Refund asset data for the Transaction. Parameters \u00b6 Type Name Required Description IHtlcRefundAsset refundAsset Yes Asset for a HTLC Refund Return Value \u00b6 HtlcRefundBuilder getStruct() \u00b6 public getStruct () Get transaction structure. Return Value \u00b6 ITransactionData Crypto\\Transactions\\Builders\\Transactions\\IPFSBuilder \u00b6 ipfsAsset() \u00b6 public ipfsAsset ( ipfsId : string ) Set IPFS asset. Parameters \u00b6 Type Name Required Description string ipfsId Yes IPFS ID Return Value \u00b6 IPFSBuilder getStruct() \u00b6 public getStruct () Get transaction structure. Return Value \u00b6 ITransactionData Crypto\\Transactions\\Builders\\Transactions\\MultiPaymentBuilder \u00b6 addPayment() \u00b6 public addPayment ( recipientId : string , amount : string ) Add a new payment to the collection. Parameters \u00b6 Type Name Required Description string recipientId Yes Recipient identifier string amount Yes Transaction amount Return Value \u00b6 MultiPaymentBuilder getStruct() \u00b6 public getStruct () Get transaction structure. Return Value \u00b6 ITransactionData Crypto\\Transactions\\Builders\\Transactions\\MultiSignatureBuilder \u00b6 participant() \u00b6 public participant ( publicKey : string ) Add participant to multi signature transaction. Parameters \u00b6 Type Name Required Description string publicKey Yes Public key Return Value \u00b6 MultiSignatureBuilder min() \u00b6 public min ( min : number ) Set the minimum required signatures. Parameters \u00b6 Type Name Required Description number min Yes Minimum required signatures Return Value \u00b6 MultiSignatureBuilder multiSignatureAsset() \u00b6 public multiSignatureAsset ( multiSignature : IMultiSignatureAsset ) Derive the address from the given multi signature asset. Parameters \u00b6 Type Name Required Description IMultiSignatureAsset multiSignature Yes Multi signature asset Return Value \u00b6 MultiSignatureBuilder getStruct() \u00b6 public getStruct () Get transaction structure. Return Value \u00b6 ITransactionData Crypto\\Transactions\\Builders\\Transactions\\SecondSignatureBuilder \u00b6 signatureAsset() \u00b6 public signatureAsset ( secondPassphrase : string ) Specify the Second Signature asset data for the Transaction. Parameters \u00b6 Type Name Required Description string secondPassphrase Yes Asset for a Second Signature Return Value \u00b6 SecondSignatureBuilder getStruct() \u00b6 public getStruct () Get transaction structure. Return Value \u00b6 ITransactionData Crypto\\Transactions\\Builders\\Transactions\\TransferBuilder \u00b6 expiration() \u00b6 public expiration ( expiration : number ) Set Transfer expiration. Parameters \u00b6 Type Name Required Description number expiration Yes The block-height or time when the transaction should expire Return Value \u00b6 TransferBuilder getStruct() \u00b6 public getStruct () Get transaction structure. Return Value \u00b6 ITransactionData Crypto\\Transactions\\Builders\\Transactions\\VoteBuilder \u00b6 votesAsset() \u00b6 public votesAsset ( votes : string []) Specify the Vote asset data for the Transaction. Parameters \u00b6 Type Name Required Description string votes Yes Asset for a Vote Return Value \u00b6 VoteBuilder getStruct() \u00b6 public getStruct () Get transaction structure. Return Value \u00b6 ITransactionData Crypto\\Transactions\\Types\\DelegateRegistrationTransaction \u00b6 getSchema() \u00b6 public static getSchema () Get transaction schema. Return Value \u00b6 schemas.TransactionSchema serialize() \u00b6 public serialize ( options? : ISerializeOptions ) Handle the serialization of \"delegate registration\" data. Parameters \u00b6 Type Name Required Description ISerializeOptions options No Options Return Value \u00b6 ByteBuffer deserialize() \u00b6 public deserialize ( buf : ByteBuffer ) Handle the deserialization of \"delegate registration\" data. Parameters \u00b6 Type Name Required Description ByteBuffer buf Yes Buffer Return Value \u00b6 void Crypto\\Transactions\\Types\\DelegateResignationTransaction \u00b6 getSchema() \u00b6 public static getSchema () Get transaction schema. Return Value \u00b6 schemas.TransactionSchema verify() \u00b6 public verify () Verify transaction. Return Value \u00b6 boolean serialize() \u00b6 public serialize ( options? : ISerializeOptions ) Handle the serialization of \"delegate resignation\" data. Parameters \u00b6 Type Name Required Description ISerializeOptions options No Options Return Value \u00b6 ByteBuffer deserialize() \u00b6 public deserialize ( buf : ByteBuffer ) Handle the deserialization of \"delegate resignation\" data. Parameters \u00b6 Type Name Required Description ByteBuffer buf Yes Buffer Return Value \u00b6 void Crypto\\Transactions\\Types\\TransactionTypeFactory \u00b6 initialize() \u00b6 public static initialize ( transactionTypes : Map < InternalTransactionType , TransactionConstructor > ) Initialize new transaction types factory. Parameters \u00b6 Type Name Required Description Map transactionTypes Yes INSERT_DESCRIPTION create() \u00b6 public static create ( data : ITransactionData ) Create new transaction type. Parameters \u00b6 Type Name Required Description ITransactionData data Yes Transaction object Return Value \u00b6 ITransaction get() \u00b6 public static get ( type : number , typeGroup? : number ) Get a transaction type. Parameters \u00b6 Type Name Required Description number type Yes Transaction type number typeGroup No Transaction group Return Value \u00b6 TransactionConstructor Crypto\\Transactions\\Types\\HtlcClaimTransaction \u00b6 getSchema() \u00b6 public static getSchema () Get transaction schema. Return Value \u00b6 schemas.TransactionSchema verify() \u00b6 public verify () Verify transaction. Return Value \u00b6 boolean serialize() \u00b6 public serialize ( options? : ISerializeOptions ) Serialize Transaction object. Parameters \u00b6 Type Name Required Description ISerializeOptions options No Serialization options Return Value \u00b6 ByteBuffer deserialize() \u00b6 public deserialize ( buf : ByteBuffer ) Deserialize into Transaction object. Parameters \u00b6 Type Name Required Description ByteBuffer buf Yes Buffer to deserialize Return Value \u00b6 void Crypto\\Transactions\\Types\\HtlcLockTransaction \u00b6 getSchema() \u00b6 public static getSchema () Get transaction schema. Return Value \u00b6 schemas.TransactionSchema verify() \u00b6 public verify () Verify transaction. Return Value \u00b6 boolean hasVendorField() \u00b6 public hasVendorField () Verify if the transaction contains a vendorfield. Return Value \u00b6 boolean serialize() \u00b6 public serialize ( options? : ISerializeOptions ) Serialize a Transaction object. Parameters \u00b6 Type Name Required Description ISerializeOptions options No Serialization options Return Value \u00b6 ByteBuffer deserialize() \u00b6 public deserialize ( buf : ByteBuffer ) Deserialize into a Transaction object. Parameters \u00b6 Type Name Required Description ByteBuffer buf Yes Buffer to deserialize Return Value \u00b6 void Crypto\\Transactions\\Types\\HtlcRefundTransaction \u00b6 getSchema() \u00b6 public static getSchema () Get transaction schema. Return Value \u00b6 schemas.TransactionSchema verify() \u00b6 public verify () Verify transaction. Return Value \u00b6 boolean serialize() \u00b6 public serialize ( options? : ISerializeOptions ) Serialize a Transaction object. Parameters \u00b6 Type Name Required Description ISerializeOptions options No Serialization options Return Value \u00b6 ByteBuffer deserialize() \u00b6 public deserialize ( buf : ByteBuffer ) Deserialize into a Transaction object. Parameters \u00b6 Type Name Required Description ByteBuffer buf Yes Buffer to deserialize Return Value \u00b6 void Crypto\\Transactions\\Types\\InternalTransactionType \u00b6 from() \u00b6 public static from ( type : number , typeGroup? : number ) Create new internal transaction type from existing type. Parameters \u00b6 Type Name Required Description number type Yes Transaction type number typeGroup No Transaction group Return Value \u00b6 InternalTransactionType toString() \u00b6 public toString () Convert transaction type to a group/type string representation (E.g. 1/0) Return Value \u00b6 string Crypto\\Transactions\\Types\\IpfsTransaction \u00b6 getSchema() \u00b6 public static getSchema () Get transaction schema. Return Value \u00b6 schemas.TransactionSchema verify() \u00b6 public verify () Verify transaction. Return Value \u00b6 boolean serialize() \u00b6 public serialize ( options? : ISerializeOptions ) Handle the serialization of \"IPFS\" data. Parameters \u00b6 Type Name Required Description ISerializeOptions options No Options Return Value \u00b6 ByteBuffer deserialize() \u00b6 public deserialize ( buf : ByteBuffer ) Handle the deserialization of \"IPFS\" data. Parameters \u00b6 Type Name Required Description ByteBuffer buf Yes Buffer Return Value \u00b6 void Crypto\\Transactions\\Types\\MultiPaymentTransaction \u00b6 getSchema() \u00b6 public static getSchema () Get transaction schema. Return Value \u00b6 schemas.TransactionSchema verify() \u00b6 public verify () Verify transaction. Return Value \u00b6 boolean hasVendorField() \u00b6 public hasVendorField () Verify if the transaction contains a vendorfield. Return Value \u00b6 boolean serialize() \u00b6 public serialize ( options? : ISerializeOptions ) Serialize a Transaction object. Parameters \u00b6 Type Name Required Description ISerializeOptions options No Serialization options Return Value \u00b6 ByteBuffer deserialize() \u00b6 public deserialize ( buf : ByteBuffer ) Deserialize into a Transaction object. Parameters \u00b6 Type Name Required Description ByteBuffer buf Yes Buffer to deserialize Return Value \u00b6 void Crypto\\Transactions\\Types\\MultiSignatureRegistrationTransaction \u00b6 getSchema() \u00b6 public static getSchema () Get transaction schema. Return Value \u00b6 schemas.TransactionSchema staticFee() \u00b6 public static staticFee ( feeContext : { height? : number ; data? : ITransactionData } = {}) Get the static fee for the Multi-Signature transaction type. Parameters \u00b6 Type Name Required Description object feeContext Yes Context for determining the static fee Return Value \u00b6 BigNumber verify() \u00b6 public verify () Verify transaction. Return Value \u00b6 boolean serialize() \u00b6 public serialize ( options? : ISerializeOptions ) Serialize a Transaction object. Parameters \u00b6 Type Name Required Description ISerializeOptions options No Serialization options Return Value \u00b6 ByteBuffer deserialize() \u00b6 public deserialize ( buf : ByteBuffer ) Deserialize into a Transaction object. Parameters \u00b6 Type Name Required Description ByteBuffer buf Yes Buffer to deserialize Return Value \u00b6 void Crypto\\Transactions\\Types\\SecondSignatureRegistrationTransaction \u00b6 getSchema() \u00b6 public static getSchema () Get transaction schema. Return Value \u00b6 schemas.TransactionSchema serialize() \u00b6 public serialize ( options? : ISerializeOptions ) Serialize a Transaction object. Parameters \u00b6 Type Name Required Description ISerializeOptions options No Serialization options Return Value \u00b6 ByteBuffer deserialize() \u00b6 public deserialize ( buf : ByteBuffer ) Deserialize into a Transaction object. Parameters \u00b6 Type Name Required Description ByteBuffer buf Yes Buffer to deserialize Return Value \u00b6 void Crypto\\Transactions\\Types\\TransferTransaction \u00b6 getSchema() \u00b6 public static getSchema () Get transaction schema. Return Value \u00b6 schemas.TransactionSchema hasVendorField() \u00b6 public hasVendorField () Verify if the transaction contains a vendorfield. Return Value \u00b6 boolean serialize() \u00b6 public serialize ( options? : ISerializeOptions ) Perform AIP11 compliant serialization. Parameters \u00b6 Type Name Required Description ISerializeOptions options No Serialization options Return Value \u00b6 ByteBuffer deserialize() \u00b6 public deserialize ( buf : ByteBuffer ) Perform AIP11 compliant deserialization. Parameters \u00b6 Type Name Required Description ByteBuffer buf Yes Buffer to deserialize Return Value \u00b6 void Crypto\\Transactions\\Types\\VoteTransaction \u00b6 getSchema() \u00b6 public static getSchema () Get transaction schema. Return Value \u00b6 schemas.TransactionSchema serialize() \u00b6 public serialize ( options? : ISerializeOptions ) Perform AIP11 compliant serialization. Parameters \u00b6 Type Name Required Description ISerializeOptions options No Serialization options Return Value \u00b6 ByteBuffer deserialize() \u00b6 public deserialize ( buf : ByteBuffer ) Perform AIP11 compliant deserialization. Parameters \u00b6 Type Name Required Description ByteBuffer buf Yes Buffer to deserialize Return Value \u00b6 void Crypto\\Validation\\Validator \u00b6 getInstance() \u00b6 public getInstance () Get an instance of the Validator object. Return Value \u00b6 Ajv.Ajv validate() \u00b6 public validate < T = any > ( schemaKeyRef : string | boolean | object , data : T ) Validate a schema object. Parameters \u00b6 Type Name Required Description string, boolean, object schemaKeyRef Yes Schema to validate against T data Yes Data to validate Return Value \u00b6 ISchemaValidationResult<T> validateException() \u00b6 public validateException < T = any > ( schemaKeyRef : string | boolean | object , data : T ) Validate a schema object for an exception. Parameters \u00b6 Type Name Required Description string, boolean, object schemaKeyRef Yes Schema to validate against T data Yes Data to validate Return Value \u00b6 ISchemaValidationResult<T> addFormat() \u00b6 public addFormat ( name : string , format : Ajv.FormatDefinition ) Add formatting definition used for validation. Parameters \u00b6 Type Name Required Description string name Yes Name of definition Ajv format Yes Format definition Return Value \u00b6 void addKeyword() \u00b6 public addKeyword ( keyword : string , definition : Ajv.KeywordDefinition ) Add keyword definition used for validation. Parameters \u00b6 Type Name Required Description string keyword Yes Name of definition Ajv definition Yes Keyword definition Return Value \u00b6 void addSchema() \u00b6 public addSchema ( schema : object | object [], key? : string ) Add schema used for validation. Parameters \u00b6 Type Name Required Description object schema Yes Name of schema string key No Schema Return Value \u00b6 void removeKeyword() \u00b6 public removeKeyword ( keyword : string ) Remove keyword definition from validation. Parameters \u00b6 Type Name Required Description string keyword Yes Name of definition Return Value \u00b6 void removeSchema() \u00b6 public removeSchema ( schemaKeyRef : string | boolean | object | RegExp ) Remove schema from validation. Parameters \u00b6 Type Name Required Description string, boolean, object, RegExp schemaKeyRef Yes Schema to remove Return Value \u00b6 void extendTransaction() \u00b6 public extendTransaction ( schema : TransactionSchema , remove? : boolean ) Extend a Transaction's schema for validation. Parameters \u00b6 Type Name Required Description TransactionSchema schema Yes Schema of transaction to extend boolean remove No Whether to remove the schema","title":"API Documentation"},{"location":"sdk/typescript/crypto/api-documentation/#api-documentation","text":"","title":"API Documentation"},{"location":"sdk/typescript/crypto/api-documentation/#cryptoblocksblockfactory","text":"","title":"Crypto\\Blocks\\BlockFactory"},{"location":"sdk/typescript/crypto/api-documentation/#fromhex","text":"public static fromHex ( hex : string ) Generate Block object from HEX.","title":"fromHex()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters","text":"Type Name Required Description string hex Yes Block content","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value","text":"IBlock","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#frombytes","text":"public static fromBytes ( buffer : Buffer ) Generate Block object from a Buffer.","title":"fromBytes()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_1","text":"Type Name Required Description Buffer buffer Yes Block content","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_1","text":"IBlock","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#fromjson","text":"public static fromJson ( json : IBlockJson ) Generate Block object from JSON.","title":"fromJson()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_2","text":"Type Name Required Description IBlockJson json Yes Block content","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_2","text":"IBlock","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#fromdata","text":"public static fromData ( data : IBlockData , options : { deserializeTransactionsUnchecked? : boolean } = {}) Generate Block object from Block data.","title":"fromData()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_3","text":"Type Name Required Description IBlockData data Yes Block content object options Yes Options used for parsing block data","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_3","text":"IBlock","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptoblocksserializer","text":"","title":"Crypto\\Blocks\\Serializer"},{"location":"sdk/typescript/crypto/api-documentation/#size","text":"public static size ( block : IBlock ) Get size of Block.","title":"size()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_4","text":"Type Name Required Description IBlock block Yes Block object","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_4","text":"number","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#serializewithtransactions","text":"public static serializeWithTransactions ( block : IBlockData ) Serialize Block with Transactions.","title":"serializeWithTransactions()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_5","text":"Type Name Required Description IBlockData block Yes Block object","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_5","text":"Buffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#serialize","text":"public static serialize ( block : IBlockData , includeSignature : boolean = true ) Serialize Block without Transactions.","title":"serialize()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_6","text":"Type Name Required Description IBlockData block Yes Block object boolean includeSignature Yes Whether to include signature in serialization","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_6","text":"Buffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptocryptohashalgorithms","text":"","title":"Crypto\\Crypto\\HashAlgorithms"},{"location":"sdk/typescript/crypto/api-documentation/#ripemd160","text":"public static ripemd160 ( buffer : Buffer | string ) Hash with RIPEMD-160.","title":"ripemd160()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_7","text":"Type Name Required Description Buffer, string buffer Yes String or Buffer to generate hash for","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_7","text":"Buffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#sha1","text":"public static sha1 ( buffer : Buffer | string ) Hash with SHA-1.","title":"sha1()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_8","text":"Type Name Required Description Buffer, string buffer Yes String or Buffer to generate hash for","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_8","text":"Buffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#sha256","text":"public static sha256 ( buffer : Buffer | string | Buffer []) Hash with SHA-256.","title":"sha256()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_9","text":"Type Name Required Description Buffer, string buffer Yes String or Buffer to generate hash for","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_9","text":"Buffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#hash160","text":"public static hash160 ( buffer : Buffer | string ) Hash with Hash160.","title":"hash160()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_10","text":"Type Name Required Description Buffer, string buffer Yes String or Buffer to generate hash for","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_10","text":"Buffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#hash256","text":"public static hash256 ( buffer : Buffer | string ) Hash with Hash256.","title":"hash256()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_11","text":"Type Name Required Description Buffer, string buffer Yes String or Buffer to generate hash for","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_11","text":"Buffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptocryptohash","text":"","title":"Crypto\\Crypto\\Hash"},{"location":"sdk/typescript/crypto/api-documentation/#signecdsa","text":"public static signECDSA ( hash : Buffer , keys : IKeyPair ) Sign hash with ECDSA.","title":"signECDSA()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_12","text":"Type Name Required Description Buffer hash Yes Hash to sign IKeyPair keys Yes Keys to sign hash with","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_12","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#verifyecdsa","text":"public static verifyECDSA ( hash : Buffer , signature : Buffer | string , publicKey : Buffer | string ) Verify ECDSA signature.","title":"verifyECDSA()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_13","text":"Type Name Required Description Buffer hash Yes Hash to verify Buffer, string signature Yes Signature of hash Buffer, string publicKey Yes Public key of wallet which signed the hash","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_13","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#signschnorr","text":"public static signSchnorr ( hash : Buffer , keys : IKeyPair ) Sign hash with Schnorr.","title":"signSchnorr()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_14","text":"Type Name Required Description Buffer hash Yes Hash to sign IKeyPair keys Yes Keys to sign hash with","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_14","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#verifyschnorr","text":"public static verifySchnorr ( hash : Buffer , signature : Buffer | string , publicKey : Buffer | string ) Verify Schnorr signature.","title":"verifySchnorr()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_15","text":"Type Name Required Description Buffer hash Yes Hash to verify Buffer, string signature Yes Signature of hash Buffer, string publicKey Yes Public key of wallet which signed the hash","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_15","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptocryptohdwallet","text":"","title":"Crypto\\Crypto\\HDWallet"},{"location":"sdk/typescript/crypto/api-documentation/#frommnemonic","text":"public static fromMnemonic ( mnemonic : string , passphrase? : string ) Generate BIP32 Wallet from mnemonic.","title":"fromMnemonic()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_16","text":"Type Name Required Description string mnemonic Yes INSERT_DESCRIPTION string passphrase No INSERT_DESCRIPTION","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_16","text":"BIP32Interface","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#fromkeys","text":"public static fromKeys ( keys : IKeyPair , chainCode : Buffer ) Generate BIP32 Wallet from KeyPair.","title":"fromKeys()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_17","text":"Type Name Required Description IKeyPair keys Yes INSERT_DESCRIPTION Buffer chainCode Yes INSERT_DESCRIPTION","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_17","text":"BIP32Interface","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getkeys","text":"public static getKeys ( node : BIP32Interface ) Get keys for BIP32 Wallet.","title":"getKeys()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_18","text":"Type Name Required Description BIP32Interface node Yes BIP32 Wallet to get keys for","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_18","text":"IKeyPair","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#deriveslip44","text":"public static deriveSlip44 ( root : BIP32Interface , hardened : boolean = true ) Determine Slip44 for BIP32 Wallet.","title":"deriveSlip44()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_19","text":"Type Name Required Description BIP32Interface root Yes BIP32 Wallet to determine Slip44 for boolean hardened Yes INSERT_DESCRIPTION","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_19","text":"BIP32Interface","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#derivenetwork","text":"public static deriveNetwork ( root : BIP32Interface ) Determine Network for BIP32 Wallet.","title":"deriveNetwork()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_20","text":"Type Name Required Description BIP32Interface root Yes BIP32 Wallet to determine network for","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_20","text":"BIP32Interface","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptocryptomessage","text":"","title":"Crypto\\Crypto\\Message"},{"location":"sdk/typescript/crypto/api-documentation/#sign","text":"public static sign ( message : string , passphrase : string ) Sign a message using the given passphrase.","title":"sign()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_21","text":"Type Name Required Description string message Yes Message string passphrase Yes Passphrase","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_21","text":"IMessage","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#signwithwif","text":"public static signWithWif ( message : string , wif : string , network? : INetwork ) Sign a message using the given WIF string.","title":"signWithWif()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_22","text":"Type Name Required Description string message Yes Message string wif Yes Network WIF INetwork network No Network","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_22","text":"IMessage","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#verify","text":"public static verify ({ message , publicKey , signature } : IMessage ) Verify the message contents","title":"verify()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_23","text":"Type Name Required Description IMessage object Yes Message","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_23","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptocryptoslots","text":"","title":"Crypto\\Crypto\\Slots"},{"location":"sdk/typescript/crypto/api-documentation/#gettime","text":"public static getTime ( time? : number ) Get the time diff between now and network start.","title":"getTime()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_24","text":"Type Name Required Description number time No Network start time","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_24","text":"number","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#gettimeinmsuntilnextslot","text":"public static getTimeInMsUntilNextSlot () Get the time (in milliseconds) until the start of the next slot.","title":"getTimeInMsUntilNextSlot()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_25","text":"number","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getslotnumber","text":"public static getSlotNumber ( epoch? : number ) Get the slot number.","title":"getSlotNumber()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_25","text":"Type Name Required Description number epoch No Epoch time","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_26","text":"number","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getslottime","text":"public static getSlotTime ( slot : number ) Get the slot time.","title":"getSlotTime()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_26","text":"Type Name Required Description number slot Yes Slot","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_27","text":"number","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getnextslot","text":"public static getNextSlot () Get the next slot.","title":"getNextSlot()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_28","text":"number","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#isforgingallowed","text":"public static isForgingAllowed ( epoch? : number ) Verify is forging is allowed.","title":"isForgingAllowed()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_27","text":"Type Name Required Description number epoch No Epoch time","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_29","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptoidentitiesaddress","text":"","title":"Crypto\\Identities\\Address"},{"location":"sdk/typescript/crypto/api-documentation/#frompassphrase","text":"public static fromPassphrase ( passphrase : string , networkVersion? : number ) Derive the address from the given passphrase.","title":"fromPassphrase()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_28","text":"Type Name Required Description string passphrase Yes Passphrase number networkVersion No Version of the network","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_30","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#frompublickey","text":"public static fromPublicKey ( publicKey : string , networkVersion? : number ) Derive a (multisig) address from a multi signature asset.","title":"fromPublicKey()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_29","text":"Type Name Required Description string publicKey Yes Public key number networkVersion No Version of the network","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_31","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#fromwif","text":"public static fromWIF ( wif : string , network? : NetworkType ) Derive the address from a WIF string.","title":"fromWIF()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_30","text":"Type Name Required Description string wif Yes WIF NetworkType network No Network to generate address for","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_32","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#frommultisignatureasset","text":"public static fromMultiSignatureAsset ( asset : IMultiSignatureAsset , networkVersion? : number ) Derive the address from the given multi signature asset.","title":"fromMultiSignatureAsset()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_31","text":"Type Name Required Description IMultiSignatureAsset asset Yes Address to validate number networkVersion No Version of the network","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_33","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#fromprivatekey","text":"public static fromPrivateKey ( privateKey , networkVersion? : number ) Derive the address from the given private key.","title":"fromPrivateKey()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_32","text":"Type Name Required Description any privateKey Yes Private key to derive address for number networkVersion No Version of the network","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_34","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#frombuffer","text":"public static fromBuffer ( buffer : Buffer ) Derive the address from a Buffer.","title":"fromBuffer()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_33","text":"Type Name Required Description Buffer buffer Yes Buffer to derive address from","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_35","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#tobuffer","text":"public static toBuffer ( address : string ) Convert address to a Buffer.","title":"toBuffer()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_34","text":"Type Name Required Description string address Yes Address to convert to buffer","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_36","text":"{ addressBuffer: Buffer; addressError?: string }","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#validate","text":"public static validate ( address : string , networkVersion? : number ) Validate the given address.","title":"validate()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_35","text":"Type Name Required Description string address Yes Address to validate number networkVersion No Version of the network","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_37","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptoidentitieskeys","text":"","title":"Crypto\\Identities\\Keys"},{"location":"sdk/typescript/crypto/api-documentation/#frompassphrase_1","text":"public static fromPassphrase ( passphrase : string , compressed : boolean = true ) Derive the keys from the given passphrase.","title":"fromPassphrase()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_36","text":"Type Name Required Description string passphrase Yes Passphrase boolean compressed Yes Compression flag","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_38","text":"IKeyPair","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#fromprivatekey_1","text":"public static fromPrivateKey ( privateKey : Buffer | string , compressed : boolean = true ) Derive the keys from the given private key.","title":"fromPrivateKey()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_37","text":"Type Name Required Description Buffer, string privateKey Yes Private Key to derive keys from boolean compressed Yes Compression flag","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_39","text":"IKeyPair","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#fromwif_1","text":"public static fromWIF ( wifKey : string , network? : INetwork ) Derive the keys from the given WIF.","title":"fromWIF()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_38","text":"Type Name Required Description string wifKey Yes Private key INetwork network No Network","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_40","text":"IKeyPair","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptoidentitiesprivatekey","text":"","title":"Crypto\\Identities\\PrivateKey"},{"location":"sdk/typescript/crypto/api-documentation/#frompassphrase_2","text":"public static fromPassphrase ( passphrase : string ) Derive the private key for the given passphrase.","title":"fromPassphrase()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_39","text":"Type Name Required Description string passphrase Yes Passphrase","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_41","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#fromwif_2","text":"public static fromWIF ( wif : string , network? : NetworkType ) Create a private key instance from a hex string.","title":"fromWIF()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_40","text":"Type Name Required Description string wif Yes Network WIF NetworkType network No Network","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_42","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptoidentitiespublickey","text":"","title":"Crypto\\Identities\\PublicKey"},{"location":"sdk/typescript/crypto/api-documentation/#frompassphrase_3","text":"public static fromPassphrase ( passphrase : string ) Derive the public key from the given passphrase.","title":"fromPassphrase()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_41","text":"Type Name Required Description string passphrase Yes Passphrase","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_43","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#fromwif_3","text":"public static fromWIF ( wif : string , network? : NetworkType ) Derive the public key from the given WIF.","title":"fromWIF()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_42","text":"Type Name Required Description string wif Yes WIF to derive public key from NetworkType network No Network","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_44","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#frommultisignatureasset_1","text":"public static fromMultiSignatureAsset ( asset : IMultiSignatureAsset ) Derive the public key from the given multi signature asset.","title":"fromMultiSignatureAsset()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_43","text":"Type Name Required Description IMultiSignatureAsset asset Yes Asset","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_45","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#validate_1","text":"public static validate ( publicKey : string , networkVersion? : number ) Validate the given public key.","title":"validate()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_44","text":"Type Name Required Description string publicKey Yes Public key number networkVersion No Network version","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_46","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptoidentitieswif","text":"","title":"Crypto\\Identities\\WIF"},{"location":"sdk/typescript/crypto/api-documentation/#frompassphrase_4","text":"public static fromPassphrase ( passphrase : string , network? : INetwork ) Derive the WIF from the given passphrase.","title":"fromPassphrase()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_45","text":"Type Name Required Description string passphrase Yes Passphrase to derive WIF from INetwork network No Network wif","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_47","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#fromkeys_1","text":"public static fromKeys ( keys : IKeyPair , network? : INetwork ) Derive the WIF from the given keys.","title":"fromKeys()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_46","text":"Type Name Required Description IKeyPair keys Yes Keys INetwork network No Network","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_48","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptomanagersconfigmanager","text":"","title":"Crypto\\Managers\\ConfigManager"},{"location":"sdk/typescript/crypto/api-documentation/#setconfig","text":"public setConfig ( config : INetworkConfig ) Set the configuration.","title":"setConfig()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_47","text":"Type Name Required Description INetworkConfig config Yes Network configuration object","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_49","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#setfrompreset","text":"public setFromPreset ( network : NetworkName ) Set the configuration from given presets.","title":"setFromPreset()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_48","text":"Type Name Required Description NetworkName network Yes Preset","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_50","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getpreset","text":"public getPreset ( network : NetworkName ) Get configuration preset.","title":"getPreset()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_49","text":"Type Name Required Description NetworkName network Yes Preset","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_51","text":"INetworkConfig","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#all","text":"public all () Get all configs.","title":"all()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_52","text":"INetworkConfig","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#set","text":"public set < T = any > ( key : string , value : T ) Set a value for the specified network config key.","title":"set()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_50","text":"Type Name Required Description string key Yes Key to set T value Yes Value to set","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_53","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#get","text":"public get < T = any > ( key : string ) Get key.","title":"get()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_51","text":"Type Name Required Description string key Yes Key to get","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_54","text":"T","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#setheight","text":"public setHeight ( value : number ) Set network height.","title":"setHeight()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_52","text":"Type Name Required Description number value Yes Network height","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_55","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getheight","text":"public getHeight () Get network height.","title":"getHeight()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_56","text":"number","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#isnewmilestone","text":"public isNewMilestone ( height? : number ) Verify if current height contains a milestone.","title":"isNewMilestone()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_53","text":"Type Name Required Description number height No Height to check for milestone","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_57","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getmilestone","text":"public getMilestone ( height? : number ) Get milestone.","title":"getMilestone()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_54","text":"Type Name Required Description number height No Network height","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_58","text":"{ [key: string]: any }","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getmilestones","text":"public getMilestones () Get all milestones.","title":"getMilestones()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_59","text":"any","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptomanagersnetworkmanager","text":"","title":"Crypto\\Managers\\NetworkManager"},{"location":"sdk/typescript/crypto/api-documentation/#all_1","text":"public static all () Get settings for all networks.","title":"all()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_60","text":"Record<NetworkName, INetworkConfig>","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#findbyname","text":"public static findByName ( name : NetworkName ) Get settings for a selected network, default network is testnet.","title":"findByName()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_55","text":"Type Name Required Description NetworkName name Yes Network name","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_61","text":"INetworkConfig","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsdeserializer","text":"","title":"Crypto\\Transactions\\Deserializer"},{"location":"sdk/typescript/crypto/api-documentation/#deserialize","text":"public static deserialize ( serialized : string | Buffer , options : IDeserializeOptions = {}) Deserialize Transaction into object.","title":"deserialize()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_56","text":"Type Name Required Description string, Buffer serialized Yes Serialized transaction IDeserializeOptions options Yes Options for deserializing","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_62","text":"ITransaction","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#applyv1compatibility","text":"public static applyV1Compatibility ( transaction : ITransactionData ) Modify transaction to be v1 compatible.","title":"applyV1Compatibility()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_57","text":"Type Name Required Description ITransactionData transaction Yes Transaction object","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_63","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionstransactionfactory","text":"","title":"Crypto\\Transactions\\TransactionFactory"},{"location":"sdk/typescript/crypto/api-documentation/#fromhex_1","text":"public static fromHex ( hex : string ) Create Transaction object from HEX.","title":"fromHex()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_58","text":"Type Name Required Description string hex Yes HEX of transaction","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_64","text":"ITransaction","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#frombytes_1","text":"public static fromBytes ( buffer : Buffer , strict : boolean = true ) Create Transaction object from Buffer.","title":"fromBytes()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_59","text":"Type Name Required Description Buffer buffer Yes Transaction buffer boolean strict Yes Strict creation from buffer","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_65","text":"ITransaction","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#frombytesunsafe","text":"public static fromBytesUnsafe ( buffer : Buffer , id? : string ) Create Transaction object from Buffer (unsafe). NOTE: Only use this internally when it is safe to assume the buffer has already been verified.","title":"fromBytesUnsafe()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_60","text":"Type Name Required Description Buffer buffer Yes Transaction buffer string id No ID override","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_66","text":"ITransaction","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#fromjson_1","text":"public static fromJson ( json : ITransactionJson ) Create Transaction object from JSON.","title":"fromJson()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_61","text":"Type Name Required Description ITransactionJson json Yes Transaction JSON object","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_67","text":"ITransaction","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#fromdata_1","text":"public static fromData ( data : ITransactionData , strict : boolean = true ) Create Transaction object from Transaction data.","title":"fromData()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_62","text":"Type Name Required Description ITransactionData data Yes Transaction object boolean strict Yes Strict conversion","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_68","text":"ITransaction","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsserializer","text":"","title":"Crypto\\Transactions\\Serializer"},{"location":"sdk/typescript/crypto/api-documentation/#getbytes","text":"public static getBytes ( transaction : ITransactionData , options : ISerializeOptions = {}) Convert the transaction to its byte representation.","title":"getBytes()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_63","text":"Type Name Required Description ITransactionData transaction Yes Transaction ISerializeOptions options Yes Options","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_69","text":"Buffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#serialize_1","text":"public static serialize ( transaction : ITransaction , options : ISerializeOptions = {}) Perform AIP11 compliant serialization.","title":"serialize()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_64","text":"Type Name Required Description ITransaction transaction Yes Transaction ISerializeOptions options Yes Options","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_70","text":"Buffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionssigner","text":"","title":"Crypto\\Transactions\\Signer"},{"location":"sdk/typescript/crypto/api-documentation/#sign_1","text":"public static sign ( transaction : ITransactionData , keys : IKeyPair , options? : ISerializeOptions ) Sign the given transaction with the provided keys.","title":"sign()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_65","text":"Type Name Required Description ITransactionData transaction Yes Transaction IKeyPair keys Yes Keys ISerializeOptions options No Options","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_71","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#secondsign","text":"public static secondSign ( transaction : ITransactionData , keys : IKeyPair ) Second sign the given transaction with the provided keys.","title":"secondSign()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_66","text":"Type Name Required Description ITransactionData transaction Yes Transaction IKeyPair keys Yes Keys","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_72","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#multisign","text":"public static multiSign ( transaction : ITransactionData , keys : IKeyPair , index : number = - 1 ) Multi sign the given transaction with the provided keys.","title":"multiSign()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_67","text":"Type Name Required Description ITransactionData transaction Yes Transaction IKeyPair keys Yes Keys number index Yes Index","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_73","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsutils","text":"","title":"Crypto\\Transactions\\Utils"},{"location":"sdk/typescript/crypto/api-documentation/#tobytes","text":"public static toBytes ( data : ITransactionData ) Convert Transaction object to Buffer.","title":"toBytes()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_68","text":"Type Name Required Description ITransactionData data Yes Transaction object","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_74","text":"Buffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#tohash","text":"public static toHash ( transaction : ITransactionData , options? : ISerializeOptions ) Convert Transaction object to Hash.","title":"toHash()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_69","text":"Type Name Required Description ITransactionData transaction Yes Transaction object ISerializeOptions options No Serialization options for generating hash","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_75","text":"Buffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getid","text":"public static getId ( transaction : ITransactionData , options : ISerializeOptions = {}) Get Transaction ID of Transaction object.","title":"getId()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_70","text":"Type Name Required Description ITransactionData transaction Yes Transaction object ISerializeOptions options Yes Serialization options for generating hash","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_76","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsverifier","text":"","title":"Crypto\\Transactions\\Verifier"},{"location":"sdk/typescript/crypto/api-documentation/#verify_1","text":"public static verify ( data : ITransactionData ) Verify transaction.","title":"verify()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_71","text":"Type Name Required Description ITransactionData data Yes Transaction object","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_77","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#verifysecondsignature","text":"public static verifySecondSignature ( transaction : ITransactionData , publicKey : string ) Verify second signature.","title":"verifySecondSignature()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_72","text":"Type Name Required Description ITransactionData transaction Yes Transaction object string publicKey Yes Public key","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_78","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#verifysignatures","text":"public static verifySignatures ( transaction : ITransactionData , multiSignature : IMultiSignatureAsset ) Verify the signatures of a Transaction object.","title":"verifySignatures()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_73","text":"Type Name Required Description ITransactionData transaction Yes Transaction object IMultiSignatureAsset multiSignature Yes Asset for Multi-Signature wallets/transactions","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_79","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#verifyhash","text":"public static verifyHash ( data : ITransactionData ) Verify transaction hash.","title":"verifyHash()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_74","text":"Type Name Required Description ITransactionData data Yes Transaction","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_80","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#verifyschema","text":"public static verifySchema ( data : ITransactionData , strict : boolean = true ) Verify transaction schema.","title":"verifySchema()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_75","text":"Type Name Required Description ITransactionData data Yes Transaction boolean strict Yes Strict flag","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_81","text":"ISchemaValidationResult","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsbuildersbuilderfactory","text":"","title":"Crypto\\Transactions\\Builders\\BuilderFactory"},{"location":"sdk/typescript/crypto/api-documentation/#transfer","text":"public static transfer () Initiate a Transfer transaction type.","title":"transfer()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_82","text":"TransferBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#secondsignature","text":"public static secondSignature () Initiate a Second Signature transaction type.","title":"secondSignature()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_83","text":"SecondSignatureBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#delegateregistration","text":"public static delegateRegistration () Initiate a Delegate Resignation transaction type.","title":"delegateRegistration()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_84","text":"DelegateRegistrationBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#vote","text":"public static vote () Initiate a Vote transaction type.","title":"vote()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_85","text":"VoteBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#multisignature","text":"public static multiSignature () Initiate a Multi-Signature transaction type.","title":"multiSignature()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_86","text":"MultiSignatureBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#ipfs","text":"public static ipfs () Initiate an IPFS transaction type.","title":"ipfs()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_87","text":"IPFSBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#multipayment","text":"public static multiPayment () Initiate a Multi-Payment transaction type.","title":"multiPayment()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_88","text":"MultiPaymentBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#delegateresignation","text":"public static delegateResignation () Initiate a Delegate Resignation transaction type.","title":"delegateResignation()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_89","text":"DelegateResignationBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#htlclock","text":"public static htlcLock () Initiate a HTLC Lock transaction type.","title":"htlcLock()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_90","text":"HtlcLockBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#htlcclaim","text":"public static htlcClaim () Initiate a HTLC Claim transaction type.","title":"htlcClaim()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_91","text":"HtlcClaimBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#htlcrefund","text":"public static htlcRefund () Initiate a HTLC Refund transaction type.","title":"htlcRefund()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_92","text":"HtlcRefundBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsbuilderstransactionsdelegateregistrationbuilder","text":"","title":"Crypto\\Transactions\\Builders\\Transactions\\DelegateRegistrationBuilder"},{"location":"sdk/typescript/crypto/api-documentation/#usernameasset","text":"public usernameAsset ( username : string ) Set the username to assign.","title":"usernameAsset()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_76","text":"Type Name Required Description string username Yes Delegate username","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_93","text":"DelegateRegistrationBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getstruct","text":"public getStruct () Get transaction structure.","title":"getStruct()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_94","text":"ITransactionData","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsbuilderstransactionsdelegateresignationbuilder","text":"","title":"Crypto\\Transactions\\Builders\\Transactions\\DelegateResignationBuilder"},{"location":"sdk/typescript/crypto/api-documentation/#getstruct_1","text":"public getStruct () Get transaction structure.","title":"getStruct()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_95","text":"ITransactionData","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsbuilderstransactionshtlcclaimbuilder","text":"","title":"Crypto\\Transactions\\Builders\\Transactions\\HtlcClaimBuilder"},{"location":"sdk/typescript/crypto/api-documentation/#htlcclaimasset","text":"public htlcClaimAsset ( claimAsset : IHtlcClaimAsset ) Specify the HTLC Claim asset data for the Transaction.","title":"htlcClaimAsset()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_77","text":"Type Name Required Description IHtlcClaimAsset claimAsset Yes Asset for a HTLC Claim","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_96","text":"HtlcClaimBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getstruct_2","text":"public getStruct () Get transaction structure.","title":"getStruct()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_97","text":"ITransactionData","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsbuilderstransactionshtlclockbuilder","text":"","title":"Crypto\\Transactions\\Builders\\Transactions\\HtlcLockBuilder"},{"location":"sdk/typescript/crypto/api-documentation/#htlclockasset","text":"public htlcLockAsset ( lockAsset : IHtlcLockAsset ) Specify the HTLC Lock asset data for the Transaction.","title":"htlcLockAsset()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_78","text":"Type Name Required Description IHtlcLockAsset lockAsset Yes Asset for a HTLC Lock","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_98","text":"HtlcLockBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getstruct_3","text":"public getStruct () Get transaction structure.","title":"getStruct()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_99","text":"ITransactionData","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsbuilderstransactionshtlcrefundbuilder","text":"","title":"Crypto\\Transactions\\Builders\\Transactions\\HtlcRefundBuilder"},{"location":"sdk/typescript/crypto/api-documentation/#htlcrefundasset","text":"public htlcRefundAsset ( refundAsset : IHtlcRefundAsset ) Specify the HTLC Refund asset data for the Transaction.","title":"htlcRefundAsset()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_79","text":"Type Name Required Description IHtlcRefundAsset refundAsset Yes Asset for a HTLC Refund","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_100","text":"HtlcRefundBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getstruct_4","text":"public getStruct () Get transaction structure.","title":"getStruct()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_101","text":"ITransactionData","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsbuilderstransactionsipfsbuilder","text":"","title":"Crypto\\Transactions\\Builders\\Transactions\\IPFSBuilder"},{"location":"sdk/typescript/crypto/api-documentation/#ipfsasset","text":"public ipfsAsset ( ipfsId : string ) Set IPFS asset.","title":"ipfsAsset()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_80","text":"Type Name Required Description string ipfsId Yes IPFS ID","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_102","text":"IPFSBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getstruct_5","text":"public getStruct () Get transaction structure.","title":"getStruct()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_103","text":"ITransactionData","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsbuilderstransactionsmultipaymentbuilder","text":"","title":"Crypto\\Transactions\\Builders\\Transactions\\MultiPaymentBuilder"},{"location":"sdk/typescript/crypto/api-documentation/#addpayment","text":"public addPayment ( recipientId : string , amount : string ) Add a new payment to the collection.","title":"addPayment()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_81","text":"Type Name Required Description string recipientId Yes Recipient identifier string amount Yes Transaction amount","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_104","text":"MultiPaymentBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getstruct_6","text":"public getStruct () Get transaction structure.","title":"getStruct()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_105","text":"ITransactionData","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsbuilderstransactionsmultisignaturebuilder","text":"","title":"Crypto\\Transactions\\Builders\\Transactions\\MultiSignatureBuilder"},{"location":"sdk/typescript/crypto/api-documentation/#participant","text":"public participant ( publicKey : string ) Add participant to multi signature transaction.","title":"participant()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_82","text":"Type Name Required Description string publicKey Yes Public key","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_106","text":"MultiSignatureBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#min","text":"public min ( min : number ) Set the minimum required signatures.","title":"min()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_83","text":"Type Name Required Description number min Yes Minimum required signatures","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_107","text":"MultiSignatureBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#multisignatureasset","text":"public multiSignatureAsset ( multiSignature : IMultiSignatureAsset ) Derive the address from the given multi signature asset.","title":"multiSignatureAsset()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_84","text":"Type Name Required Description IMultiSignatureAsset multiSignature Yes Multi signature asset","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_108","text":"MultiSignatureBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getstruct_7","text":"public getStruct () Get transaction structure.","title":"getStruct()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_109","text":"ITransactionData","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsbuilderstransactionssecondsignaturebuilder","text":"","title":"Crypto\\Transactions\\Builders\\Transactions\\SecondSignatureBuilder"},{"location":"sdk/typescript/crypto/api-documentation/#signatureasset","text":"public signatureAsset ( secondPassphrase : string ) Specify the Second Signature asset data for the Transaction.","title":"signatureAsset()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_85","text":"Type Name Required Description string secondPassphrase Yes Asset for a Second Signature","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_110","text":"SecondSignatureBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getstruct_8","text":"public getStruct () Get transaction structure.","title":"getStruct()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_111","text":"ITransactionData","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsbuilderstransactionstransferbuilder","text":"","title":"Crypto\\Transactions\\Builders\\Transactions\\TransferBuilder"},{"location":"sdk/typescript/crypto/api-documentation/#expiration","text":"public expiration ( expiration : number ) Set Transfer expiration.","title":"expiration()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_86","text":"Type Name Required Description number expiration Yes The block-height or time when the transaction should expire","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_112","text":"TransferBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getstruct_9","text":"public getStruct () Get transaction structure.","title":"getStruct()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_113","text":"ITransactionData","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsbuilderstransactionsvotebuilder","text":"","title":"Crypto\\Transactions\\Builders\\Transactions\\VoteBuilder"},{"location":"sdk/typescript/crypto/api-documentation/#votesasset","text":"public votesAsset ( votes : string []) Specify the Vote asset data for the Transaction.","title":"votesAsset()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_87","text":"Type Name Required Description string votes Yes Asset for a Vote","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_114","text":"VoteBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getstruct_10","text":"public getStruct () Get transaction structure.","title":"getStruct()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_115","text":"ITransactionData","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionstypesdelegateregistrationtransaction","text":"","title":"Crypto\\Transactions\\Types\\DelegateRegistrationTransaction"},{"location":"sdk/typescript/crypto/api-documentation/#getschema","text":"public static getSchema () Get transaction schema.","title":"getSchema()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_116","text":"schemas.TransactionSchema","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#serialize_2","text":"public serialize ( options? : ISerializeOptions ) Handle the serialization of \"delegate registration\" data.","title":"serialize()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_88","text":"Type Name Required Description ISerializeOptions options No Options","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_117","text":"ByteBuffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#deserialize_1","text":"public deserialize ( buf : ByteBuffer ) Handle the deserialization of \"delegate registration\" data.","title":"deserialize()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_89","text":"Type Name Required Description ByteBuffer buf Yes Buffer","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_118","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionstypesdelegateresignationtransaction","text":"","title":"Crypto\\Transactions\\Types\\DelegateResignationTransaction"},{"location":"sdk/typescript/crypto/api-documentation/#getschema_1","text":"public static getSchema () Get transaction schema.","title":"getSchema()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_119","text":"schemas.TransactionSchema","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#verify_2","text":"public verify () Verify transaction.","title":"verify()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_120","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#serialize_3","text":"public serialize ( options? : ISerializeOptions ) Handle the serialization of \"delegate resignation\" data.","title":"serialize()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_90","text":"Type Name Required Description ISerializeOptions options No Options","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_121","text":"ByteBuffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#deserialize_2","text":"public deserialize ( buf : ByteBuffer ) Handle the deserialization of \"delegate resignation\" data.","title":"deserialize()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_91","text":"Type Name Required Description ByteBuffer buf Yes Buffer","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_122","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionstypestransactiontypefactory","text":"","title":"Crypto\\Transactions\\Types\\TransactionTypeFactory"},{"location":"sdk/typescript/crypto/api-documentation/#initialize","text":"public static initialize ( transactionTypes : Map < InternalTransactionType , TransactionConstructor > ) Initialize new transaction types factory.","title":"initialize()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_92","text":"Type Name Required Description Map transactionTypes Yes INSERT_DESCRIPTION","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#create","text":"public static create ( data : ITransactionData ) Create new transaction type.","title":"create()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_93","text":"Type Name Required Description ITransactionData data Yes Transaction object","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_123","text":"ITransaction","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#get_1","text":"public static get ( type : number , typeGroup? : number ) Get a transaction type.","title":"get()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_94","text":"Type Name Required Description number type Yes Transaction type number typeGroup No Transaction group","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_124","text":"TransactionConstructor","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionstypeshtlcclaimtransaction","text":"","title":"Crypto\\Transactions\\Types\\HtlcClaimTransaction"},{"location":"sdk/typescript/crypto/api-documentation/#getschema_2","text":"public static getSchema () Get transaction schema.","title":"getSchema()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_125","text":"schemas.TransactionSchema","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#verify_3","text":"public verify () Verify transaction.","title":"verify()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_126","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#serialize_4","text":"public serialize ( options? : ISerializeOptions ) Serialize Transaction object.","title":"serialize()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_95","text":"Type Name Required Description ISerializeOptions options No Serialization options","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_127","text":"ByteBuffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#deserialize_3","text":"public deserialize ( buf : ByteBuffer ) Deserialize into Transaction object.","title":"deserialize()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_96","text":"Type Name Required Description ByteBuffer buf Yes Buffer to deserialize","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_128","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionstypeshtlclocktransaction","text":"","title":"Crypto\\Transactions\\Types\\HtlcLockTransaction"},{"location":"sdk/typescript/crypto/api-documentation/#getschema_3","text":"public static getSchema () Get transaction schema.","title":"getSchema()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_129","text":"schemas.TransactionSchema","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#verify_4","text":"public verify () Verify transaction.","title":"verify()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_130","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#hasvendorfield","text":"public hasVendorField () Verify if the transaction contains a vendorfield.","title":"hasVendorField()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_131","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#serialize_5","text":"public serialize ( options? : ISerializeOptions ) Serialize a Transaction object.","title":"serialize()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_97","text":"Type Name Required Description ISerializeOptions options No Serialization options","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_132","text":"ByteBuffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#deserialize_4","text":"public deserialize ( buf : ByteBuffer ) Deserialize into a Transaction object.","title":"deserialize()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_98","text":"Type Name Required Description ByteBuffer buf Yes Buffer to deserialize","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_133","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionstypeshtlcrefundtransaction","text":"","title":"Crypto\\Transactions\\Types\\HtlcRefundTransaction"},{"location":"sdk/typescript/crypto/api-documentation/#getschema_4","text":"public static getSchema () Get transaction schema.","title":"getSchema()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_134","text":"schemas.TransactionSchema","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#verify_5","text":"public verify () Verify transaction.","title":"verify()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_135","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#serialize_6","text":"public serialize ( options? : ISerializeOptions ) Serialize a Transaction object.","title":"serialize()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_99","text":"Type Name Required Description ISerializeOptions options No Serialization options","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_136","text":"ByteBuffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#deserialize_5","text":"public deserialize ( buf : ByteBuffer ) Deserialize into a Transaction object.","title":"deserialize()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_100","text":"Type Name Required Description ByteBuffer buf Yes Buffer to deserialize","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_137","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionstypesinternaltransactiontype","text":"","title":"Crypto\\Transactions\\Types\\InternalTransactionType"},{"location":"sdk/typescript/crypto/api-documentation/#from","text":"public static from ( type : number , typeGroup? : number ) Create new internal transaction type from existing type.","title":"from()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_101","text":"Type Name Required Description number type Yes Transaction type number typeGroup No Transaction group","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_138","text":"InternalTransactionType","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#tostring","text":"public toString () Convert transaction type to a group/type string representation (E.g. 1/0)","title":"toString()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_139","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionstypesipfstransaction","text":"","title":"Crypto\\Transactions\\Types\\IpfsTransaction"},{"location":"sdk/typescript/crypto/api-documentation/#getschema_5","text":"public static getSchema () Get transaction schema.","title":"getSchema()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_140","text":"schemas.TransactionSchema","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#verify_6","text":"public verify () Verify transaction.","title":"verify()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_141","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#serialize_7","text":"public serialize ( options? : ISerializeOptions ) Handle the serialization of \"IPFS\" data.","title":"serialize()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_102","text":"Type Name Required Description ISerializeOptions options No Options","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_142","text":"ByteBuffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#deserialize_6","text":"public deserialize ( buf : ByteBuffer ) Handle the deserialization of \"IPFS\" data.","title":"deserialize()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_103","text":"Type Name Required Description ByteBuffer buf Yes Buffer","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_143","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionstypesmultipaymenttransaction","text":"","title":"Crypto\\Transactions\\Types\\MultiPaymentTransaction"},{"location":"sdk/typescript/crypto/api-documentation/#getschema_6","text":"public static getSchema () Get transaction schema.","title":"getSchema()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_144","text":"schemas.TransactionSchema","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#verify_7","text":"public verify () Verify transaction.","title":"verify()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_145","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#hasvendorfield_1","text":"public hasVendorField () Verify if the transaction contains a vendorfield.","title":"hasVendorField()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_146","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#serialize_8","text":"public serialize ( options? : ISerializeOptions ) Serialize a Transaction object.","title":"serialize()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_104","text":"Type Name Required Description ISerializeOptions options No Serialization options","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_147","text":"ByteBuffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#deserialize_7","text":"public deserialize ( buf : ByteBuffer ) Deserialize into a Transaction object.","title":"deserialize()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_105","text":"Type Name Required Description ByteBuffer buf Yes Buffer to deserialize","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_148","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionstypesmultisignatureregistrationtransaction","text":"","title":"Crypto\\Transactions\\Types\\MultiSignatureRegistrationTransaction"},{"location":"sdk/typescript/crypto/api-documentation/#getschema_7","text":"public static getSchema () Get transaction schema.","title":"getSchema()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_149","text":"schemas.TransactionSchema","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#staticfee","text":"public static staticFee ( feeContext : { height? : number ; data? : ITransactionData } = {}) Get the static fee for the Multi-Signature transaction type.","title":"staticFee()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_106","text":"Type Name Required Description object feeContext Yes Context for determining the static fee","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_150","text":"BigNumber","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#verify_8","text":"public verify () Verify transaction.","title":"verify()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_151","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#serialize_9","text":"public serialize ( options? : ISerializeOptions ) Serialize a Transaction object.","title":"serialize()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_107","text":"Type Name Required Description ISerializeOptions options No Serialization options","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_152","text":"ByteBuffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#deserialize_8","text":"public deserialize ( buf : ByteBuffer ) Deserialize into a Transaction object.","title":"deserialize()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_108","text":"Type Name Required Description ByteBuffer buf Yes Buffer to deserialize","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_153","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionstypessecondsignatureregistrationtransaction","text":"","title":"Crypto\\Transactions\\Types\\SecondSignatureRegistrationTransaction"},{"location":"sdk/typescript/crypto/api-documentation/#getschema_8","text":"public static getSchema () Get transaction schema.","title":"getSchema()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_154","text":"schemas.TransactionSchema","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#serialize_10","text":"public serialize ( options? : ISerializeOptions ) Serialize a Transaction object.","title":"serialize()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_109","text":"Type Name Required Description ISerializeOptions options No Serialization options","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_155","text":"ByteBuffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#deserialize_9","text":"public deserialize ( buf : ByteBuffer ) Deserialize into a Transaction object.","title":"deserialize()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_110","text":"Type Name Required Description ByteBuffer buf Yes Buffer to deserialize","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_156","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionstypestransfertransaction","text":"","title":"Crypto\\Transactions\\Types\\TransferTransaction"},{"location":"sdk/typescript/crypto/api-documentation/#getschema_9","text":"public static getSchema () Get transaction schema.","title":"getSchema()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_157","text":"schemas.TransactionSchema","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#hasvendorfield_2","text":"public hasVendorField () Verify if the transaction contains a vendorfield.","title":"hasVendorField()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_158","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#serialize_11","text":"public serialize ( options? : ISerializeOptions ) Perform AIP11 compliant serialization.","title":"serialize()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_111","text":"Type Name Required Description ISerializeOptions options No Serialization options","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_159","text":"ByteBuffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#deserialize_10","text":"public deserialize ( buf : ByteBuffer ) Perform AIP11 compliant deserialization.","title":"deserialize()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_112","text":"Type Name Required Description ByteBuffer buf Yes Buffer to deserialize","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_160","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionstypesvotetransaction","text":"","title":"Crypto\\Transactions\\Types\\VoteTransaction"},{"location":"sdk/typescript/crypto/api-documentation/#getschema_10","text":"public static getSchema () Get transaction schema.","title":"getSchema()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_161","text":"schemas.TransactionSchema","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#serialize_12","text":"public serialize ( options? : ISerializeOptions ) Perform AIP11 compliant serialization.","title":"serialize()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_113","text":"Type Name Required Description ISerializeOptions options No Serialization options","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_162","text":"ByteBuffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#deserialize_11","text":"public deserialize ( buf : ByteBuffer ) Perform AIP11 compliant deserialization.","title":"deserialize()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_114","text":"Type Name Required Description ByteBuffer buf Yes Buffer to deserialize","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_163","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptovalidationvalidator","text":"","title":"Crypto\\Validation\\Validator"},{"location":"sdk/typescript/crypto/api-documentation/#getinstance","text":"public getInstance () Get an instance of the Validator object.","title":"getInstance()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_164","text":"Ajv.Ajv","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#validate_2","text":"public validate < T = any > ( schemaKeyRef : string | boolean | object , data : T ) Validate a schema object.","title":"validate()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_115","text":"Type Name Required Description string, boolean, object schemaKeyRef Yes Schema to validate against T data Yes Data to validate","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_165","text":"ISchemaValidationResult<T>","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#validateexception","text":"public validateException < T = any > ( schemaKeyRef : string | boolean | object , data : T ) Validate a schema object for an exception.","title":"validateException()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_116","text":"Type Name Required Description string, boolean, object schemaKeyRef Yes Schema to validate against T data Yes Data to validate","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_166","text":"ISchemaValidationResult<T>","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#addformat","text":"public addFormat ( name : string , format : Ajv.FormatDefinition ) Add formatting definition used for validation.","title":"addFormat()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_117","text":"Type Name Required Description string name Yes Name of definition Ajv format Yes Format definition","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_167","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#addkeyword","text":"public addKeyword ( keyword : string , definition : Ajv.KeywordDefinition ) Add keyword definition used for validation.","title":"addKeyword()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_118","text":"Type Name Required Description string keyword Yes Name of definition Ajv definition Yes Keyword definition","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_168","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#addschema","text":"public addSchema ( schema : object | object [], key? : string ) Add schema used for validation.","title":"addSchema()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_119","text":"Type Name Required Description object schema Yes Name of schema string key No Schema","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_169","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#removekeyword","text":"public removeKeyword ( keyword : string ) Remove keyword definition from validation.","title":"removeKeyword()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_120","text":"Type Name Required Description string keyword Yes Name of definition","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_170","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#removeschema","text":"public removeSchema ( schemaKeyRef : string | boolean | object | RegExp ) Remove schema from validation.","title":"removeSchema()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_121","text":"Type Name Required Description string, boolean, object, RegExp schemaKeyRef Yes Schema to remove","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_171","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#extendtransaction","text":"public extendTransaction ( schema : TransactionSchema , remove? : boolean ) Extend a Transaction's schema for validation.","title":"extendTransaction()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_122","text":"Type Name Required Description TransactionSchema schema Yes Schema of transaction to extend boolean remove No Whether to remove the schema","title":"Parameters"},{"location":"sdk/typescript/crypto/examples/","text":"Examples \u00b6 Initialization \u00b6 const { Identities } = require ( \"@solar-network/crypto\" ); // Throughout this document, the keys object used is: const keys = Identities . Keys . fromPassphrase ( \"this is a top-secret passphrase\" ); // Throughout this document, the recipientId variable used is: const recipientId = Identities . Address . fromPassphrase ( \"this is a top-secret passphrase\" ); // Throughout this document, the senderPublicKey variable used is: const senderPublicKey = Identities . PublicKey . fromPassphrase ( \"this is a top-secret passphrase\" ); Transactions \u00b6 A transaction is an object specifying the transfer of funds from the sender's wallet to the recipient's. Each transaction must be signed by the sender's private key to prove authenticity and origin. After broadcasting through the client SDK , a transaction is permanently incorporated in the blockchain by a Delegate Node. Sign \u00b6 The crypto SDK can sign a transaction using your private key or passphrase (from which the private key is generated). Ensure you are familiar with digital signatures before using the crypto SDKs. const { Transactions } = require ( \"@solar-network/crypto\" ); const transaction = { type : 0 , amount : 1000 , fee : 2000 , recipientId , timestamp : 121212 , asset : {}, senderPublicKey }; Transactions . Signer . sign ( transaction , keys ); >>> string Serialize (AIP11) \u00b6 Serialization of a transaction object ensures it is compact and properly formatted to be incorporated in the SXP blockchain. If you are using the crypto SDK in combination with the public API SDK, you should not need to serialize manually. const { Transactions } = require ( \"@solar-network/crypto\" ); const transaction = Transactions . BuilderFactory . transfer () . amount ( 1000 ) . fee ( 2000 ) . recipientId ( recipientId ) . senderPublicKey ( senderPublicKey ) . sign ( \"sender\" ) . build (); const serialized = Transactions . Serializer . serialize ( transaction ). toString ( \"hex\" ); >>> string Deserialize (AIP11) \u00b6 A serialized transaction may be deserialized for inspection purposes. The public API does not return serialized transactions, so you should only need to deserialize in exceptional circumstances. const { Transactions } = require ( \"@solar-network/crypto\" ); const deserialized = Transactions . deserializer . deserialize ( serialized ); >>> ITransaction Message \u00b6 The crypto SDK not only supports transactions but can also work with other arbitrary data (expressed as strings). Sign \u00b6 Signing a string works much like signing a transaction: in most implementations, the message is hashed, and the resulting hash is signed using the private key or passphrase . ECDSA \u00b6 const { Crypto } = require ( \"@solar-network/crypto\" ); const message = \"Arbitrary entry of data\" ; const hash = Crypto . HashAlgorithms . sha256 ( message ); const signature = Crypto . Hash . signECDSA ( hash , keys ); const signed = { message , hash , signature }; >>> IMessage Schnorr \u00b6 const { Crypto } = require ( \"@solar-network/crypto\" ); const message = \"Arbitrary entry of data\" ; const hash = Crypto . HashAlgorithms . sha256 ( message ); const signature = Crypto . Hash . signSchnorr ( hash , keys ); const signed = { message , hash , signature }; >>> IMessage Verify \u00b6 A message's signature can easily be verified by hash, without the private key that signed the message, by using the verify method. ECDSA \u00b6 Crypto . Hash . verifyECDSA ( signed . hash , signed . signature , \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b\" ); >>> boolean Schnorr \u00b6 Crypto . Hash . verifySchnorr ( signed . hash , signed . signature , \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b\" ); >>> boolean Identities \u00b6 The identities class allows for the creation and inspection of keyPairs from passphrases . Here you find vital functions when creating transactions and managing wallets. Derive the Address from a Passphrase \u00b6 const { Identities } = require ( \"@solar-network/crypto\" ); Identities . Address . fromPassphrase ( \"this is a top secret passphrase\" ); >>> string Derive the Address from a Public Key \u00b6 const { Identities } = require ( \"@solar-network/crypto\" ); Identities . Address . fromPublicKey ( \"validPublicKey\" ); >>> string Derive the Address from a Private Key \u00b6 const { Identities } = require ( \"@solar-network/crypto\" ); Identities . Address . fromPrivateKey ( \"validPrivateKey\" ); >>> string Derive the Address from a WIF \u00b6 const { Identities } = require ( \"@solar-network/crypto\" ); Identities . Address . fromWIF ( \"validWif\" ); >>> string Validate an Address \u00b6 const { Identities } = require ( \"@solar-network/crypto\" ); Identities . Address . validate ( \"validAddress\" ); >>> boolean Private Key \u00b6 As the name implies, private keys and passphrases are to remain private. Never store these unencrypted and minimize access to these secrets Derive the Private Key from a Passphrase \u00b6 const { Identities } = require ( \"@solar-network/crypto\" ); Identities . PrivateKey . fromPassphrase ( \"this is a top secret passphrase\" ); >>> string Derive the Private Key Instance Object from a Hexadecimal Encoded String \u00b6 This function has not been implemented in this client library . Derive the Private Key from a WIF \u00b6 const { Identities } = require ( \"@solar-network/crypto\" ); Identities . PrivateKey . fromWIF ( \"validWif\" ); >>> string Public Key \u00b6 Public Keys may be freely shared, and are included in transaction objects to validate the authenticity. Derive the Public Key from a Passphrase \u00b6 const { Identities } = require ( \"@solar-network/crypto\" ); Identities . PublicKey . fromPassphrase ( \"this is a top secret passphrase\" ); >>> string Derive the Public Key Instance Object from a Hexadecimal Encoded String \u00b6 This function has not been implemented in this client library . Validate a Public Key \u00b6 const { Identities } = require ( \"@solar-network/crypto\" ); Identities . PublicKey . validate ( \"validPublicKey\" ); >>> boolean WIF \u00b6 The WIF should remain secret, just like your passphrase and private key . Derive the WIF from a Passphrase \u00b6 const { Identities } = require ( \"@solar-network/crypto\" ); Identities . WIF . fromPassphrase ( \"this is a top secret passphrase\" ); >>> string","title":"Examples"},{"location":"sdk/typescript/crypto/examples/#examples","text":"","title":"Examples"},{"location":"sdk/typescript/crypto/examples/#initialization","text":"const { Identities } = require ( \"@solar-network/crypto\" ); // Throughout this document, the keys object used is: const keys = Identities . Keys . fromPassphrase ( \"this is a top-secret passphrase\" ); // Throughout this document, the recipientId variable used is: const recipientId = Identities . Address . fromPassphrase ( \"this is a top-secret passphrase\" ); // Throughout this document, the senderPublicKey variable used is: const senderPublicKey = Identities . PublicKey . fromPassphrase ( \"this is a top-secret passphrase\" );","title":"Initialization"},{"location":"sdk/typescript/crypto/examples/#transactions","text":"A transaction is an object specifying the transfer of funds from the sender's wallet to the recipient's. Each transaction must be signed by the sender's private key to prove authenticity and origin. After broadcasting through the client SDK , a transaction is permanently incorporated in the blockchain by a Delegate Node.","title":"Transactions"},{"location":"sdk/typescript/crypto/examples/#sign","text":"The crypto SDK can sign a transaction using your private key or passphrase (from which the private key is generated). Ensure you are familiar with digital signatures before using the crypto SDKs. const { Transactions } = require ( \"@solar-network/crypto\" ); const transaction = { type : 0 , amount : 1000 , fee : 2000 , recipientId , timestamp : 121212 , asset : {}, senderPublicKey }; Transactions . Signer . sign ( transaction , keys ); >>> string","title":"Sign"},{"location":"sdk/typescript/crypto/examples/#serialize-aip11","text":"Serialization of a transaction object ensures it is compact and properly formatted to be incorporated in the SXP blockchain. If you are using the crypto SDK in combination with the public API SDK, you should not need to serialize manually. const { Transactions } = require ( \"@solar-network/crypto\" ); const transaction = Transactions . BuilderFactory . transfer () . amount ( 1000 ) . fee ( 2000 ) . recipientId ( recipientId ) . senderPublicKey ( senderPublicKey ) . sign ( \"sender\" ) . build (); const serialized = Transactions . Serializer . serialize ( transaction ). toString ( \"hex\" ); >>> string","title":"Serialize (AIP11)"},{"location":"sdk/typescript/crypto/examples/#deserialize-aip11","text":"A serialized transaction may be deserialized for inspection purposes. The public API does not return serialized transactions, so you should only need to deserialize in exceptional circumstances. const { Transactions } = require ( \"@solar-network/crypto\" ); const deserialized = Transactions . deserializer . deserialize ( serialized ); >>> ITransaction","title":"Deserialize (AIP11)"},{"location":"sdk/typescript/crypto/examples/#message","text":"The crypto SDK not only supports transactions but can also work with other arbitrary data (expressed as strings).","title":"Message"},{"location":"sdk/typescript/crypto/examples/#sign_1","text":"Signing a string works much like signing a transaction: in most implementations, the message is hashed, and the resulting hash is signed using the private key or passphrase .","title":"Sign"},{"location":"sdk/typescript/crypto/examples/#ecdsa","text":"const { Crypto } = require ( \"@solar-network/crypto\" ); const message = \"Arbitrary entry of data\" ; const hash = Crypto . HashAlgorithms . sha256 ( message ); const signature = Crypto . Hash . signECDSA ( hash , keys ); const signed = { message , hash , signature }; >>> IMessage","title":"ECDSA"},{"location":"sdk/typescript/crypto/examples/#schnorr","text":"const { Crypto } = require ( \"@solar-network/crypto\" ); const message = \"Arbitrary entry of data\" ; const hash = Crypto . HashAlgorithms . sha256 ( message ); const signature = Crypto . Hash . signSchnorr ( hash , keys ); const signed = { message , hash , signature }; >>> IMessage","title":"Schnorr"},{"location":"sdk/typescript/crypto/examples/#verify","text":"A message's signature can easily be verified by hash, without the private key that signed the message, by using the verify method.","title":"Verify"},{"location":"sdk/typescript/crypto/examples/#ecdsa_1","text":"Crypto . Hash . verifyECDSA ( signed . hash , signed . signature , \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b\" ); >>> boolean","title":"ECDSA"},{"location":"sdk/typescript/crypto/examples/#schnorr_1","text":"Crypto . Hash . verifySchnorr ( signed . hash , signed . signature , \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b\" ); >>> boolean","title":"Schnorr"},{"location":"sdk/typescript/crypto/examples/#identities","text":"The identities class allows for the creation and inspection of keyPairs from passphrases . Here you find vital functions when creating transactions and managing wallets.","title":"Identities"},{"location":"sdk/typescript/crypto/examples/#derive-the-address-from-a-passphrase","text":"const { Identities } = require ( \"@solar-network/crypto\" ); Identities . Address . fromPassphrase ( \"this is a top secret passphrase\" ); >>> string","title":"Derive the Address from a Passphrase"},{"location":"sdk/typescript/crypto/examples/#derive-the-address-from-a-public-key","text":"const { Identities } = require ( \"@solar-network/crypto\" ); Identities . Address . fromPublicKey ( \"validPublicKey\" ); >>> string","title":"Derive the Address from a Public Key"},{"location":"sdk/typescript/crypto/examples/#derive-the-address-from-a-private-key","text":"const { Identities } = require ( \"@solar-network/crypto\" ); Identities . Address . fromPrivateKey ( \"validPrivateKey\" ); >>> string","title":"Derive the Address from a Private Key"},{"location":"sdk/typescript/crypto/examples/#derive-the-address-from-a-wif","text":"const { Identities } = require ( \"@solar-network/crypto\" ); Identities . Address . fromWIF ( \"validWif\" ); >>> string","title":"Derive the Address from a WIF"},{"location":"sdk/typescript/crypto/examples/#validate-an-address","text":"const { Identities } = require ( \"@solar-network/crypto\" ); Identities . Address . validate ( \"validAddress\" ); >>> boolean","title":"Validate an Address"},{"location":"sdk/typescript/crypto/examples/#private-key","text":"As the name implies, private keys and passphrases are to remain private. Never store these unencrypted and minimize access to these secrets","title":"Private Key"},{"location":"sdk/typescript/crypto/examples/#derive-the-private-key-from-a-passphrase","text":"const { Identities } = require ( \"@solar-network/crypto\" ); Identities . PrivateKey . fromPassphrase ( \"this is a top secret passphrase\" ); >>> string","title":"Derive the Private Key from a Passphrase"},{"location":"sdk/typescript/crypto/examples/#derive-the-private-key-instance-object-from-a-hexadecimal-encoded-string","text":"This function has not been implemented in this client library .","title":"Derive the Private Key Instance Object from a Hexadecimal Encoded String"},{"location":"sdk/typescript/crypto/examples/#derive-the-private-key-from-a-wif","text":"const { Identities } = require ( \"@solar-network/crypto\" ); Identities . PrivateKey . fromWIF ( \"validWif\" ); >>> string","title":"Derive the Private Key from a WIF"},{"location":"sdk/typescript/crypto/examples/#public-key","text":"Public Keys may be freely shared, and are included in transaction objects to validate the authenticity.","title":"Public Key"},{"location":"sdk/typescript/crypto/examples/#derive-the-public-key-from-a-passphrase","text":"const { Identities } = require ( \"@solar-network/crypto\" ); Identities . PublicKey . fromPassphrase ( \"this is a top secret passphrase\" ); >>> string","title":"Derive the Public Key from a Passphrase"},{"location":"sdk/typescript/crypto/examples/#derive-the-public-key-instance-object-from-a-hexadecimal-encoded-string","text":"This function has not been implemented in this client library .","title":"Derive the Public Key Instance Object from a Hexadecimal Encoded String"},{"location":"sdk/typescript/crypto/examples/#validate-a-public-key","text":"const { Identities } = require ( \"@solar-network/crypto\" ); Identities . PublicKey . validate ( \"validPublicKey\" ); >>> boolean","title":"Validate a Public Key"},{"location":"sdk/typescript/crypto/examples/#wif","text":"The WIF should remain secret, just like your passphrase and private key .","title":"WIF"},{"location":"sdk/typescript/crypto/examples/#derive-the-wif-from-a-passphrase","text":"const { Identities } = require ( \"@solar-network/crypto\" ); Identities . WIF . fromPassphrase ( \"this is a top secret passphrase\" ); >>> string","title":"Derive the WIF from a Passphrase"},{"location":"sdk/typescript/crypto/getting-started/","text":"NodeJS installation \u00b6 NodeJS can be downloaded here . Alternatively you can install NodeJS through your operating system packager manager . An excellent way to manage your NodeJS installation and be able to work with multiple version is to go through NVM . Yarn \u00b6 Yarn is a package manager for your code. It allows you to use and share code with other developers from around the world. Yarn does this quickly, securely, and reliably so you don\u2019t ever have to worry. Install Yarn \u00b6 Instructions on how to install Yarn can be found here Install package with Yarn \u00b6 yarn add @solar-network/crypto Development \u00b6 Fork the package . Clone your forked repository. git clone https://github.com/<githubusername>/javascript-crypto Next, move into the fresh cloned directory. cd javascript-crypto Proceed to install the dependencies. yarn install Dependencies are now installed, you can now run the tests to see if everything is running as it should. yarn test","title":"Getting Started"},{"location":"sdk/typescript/crypto/getting-started/#nodejs-installation","text":"NodeJS can be downloaded here . Alternatively you can install NodeJS through your operating system packager manager . An excellent way to manage your NodeJS installation and be able to work with multiple version is to go through NVM .","title":"NodeJS installation"},{"location":"sdk/typescript/crypto/getting-started/#yarn","text":"Yarn is a package manager for your code. It allows you to use and share code with other developers from around the world. Yarn does this quickly, securely, and reliably so you don\u2019t ever have to worry.","title":"Yarn"},{"location":"sdk/typescript/crypto/getting-started/#install-yarn","text":"Instructions on how to install Yarn can be found here","title":"Install Yarn"},{"location":"sdk/typescript/crypto/getting-started/#install-package-with-yarn","text":"yarn add @solar-network/crypto","title":"Install package with Yarn"},{"location":"sdk/typescript/crypto/getting-started/#development","text":"Fork the package . Clone your forked repository. git clone https://github.com/<githubusername>/javascript-crypto Next, move into the fresh cloned directory. cd javascript-crypto Proceed to install the dependencies. yarn install Dependencies are now installed, you can now run the tests to see if everything is running as it should. yarn test","title":"Development"},{"location":"sdk/typescript/crypto/intro/","text":"Crypto \u00b6 Install package with Yarn \u00b6 yarn add @solar-network/crypto Development \u00b6 Crypto package is part of our Solar Core repository. To make changes for our core repo. Clone your forked repository. git clone https://github.com/<githubusername>/core Next, move into the fresh cloned directory. cd core/crypto Proceed to install the dependencies. yarn install Dependencies are now installed, you can now run the tests to see if everything is running as it should. yarn test","title":"Getting Started"},{"location":"sdk/typescript/crypto/intro/#crypto","text":"","title":"Crypto"},{"location":"sdk/typescript/crypto/intro/#install-package-with-yarn","text":"yarn add @solar-network/crypto","title":"Install package with Yarn"},{"location":"sdk/typescript/crypto/intro/#development","text":"Crypto package is part of our Solar Core repository. To make changes for our core repo. Clone your forked repository. git clone https://github.com/<githubusername>/core Next, move into the fresh cloned directory. cd core/crypto Proceed to install the dependencies. yarn install Dependencies are now installed, you can now run the tests to see if everything is running as it should. yarn test","title":"Development"},{"location":"sxpswap/introduction/","text":"Introduction \u00b6 This section is meant for users and exchanges migrating their ERC20/BEP20 SXP to mainnet SXP. If you are already on SXP mainnet, then this guide is not for you. Click on the following links to proceed with the swap. Migration for MetaMask Users Migration for Trust Wallet Users Migration for Exchanges Technical Details","title":"Introduction"},{"location":"sxpswap/introduction/#introduction","text":"This section is meant for users and exchanges migrating their ERC20/BEP20 SXP to mainnet SXP. If you are already on SXP mainnet, then this guide is not for you. Click on the following links to proceed with the swap. Migration for MetaMask Users Migration for Trust Wallet Users Migration for Exchanges Technical Details","title":"Introduction"},{"location":"sxpswap/exchanges/getting-started/","text":"Introduction \u00b6 We advise Exchange Operators to read the information in the technical details section. Technical Details","title":"Introduction"},{"location":"sxpswap/exchanges/getting-started/#introduction","text":"We advise Exchange Operators to read the information in the technical details section. Technical Details","title":"Introduction"},{"location":"sxpswap/technical-details/security/broadcast-procedure/","text":"Phase 2 - Backend Program Broadcasting Transaction \u00b6 In the second phase, the backend program listens for new transactions on BEP20/ERC20 SXPSwap contract. The backend program listens to transactions from a local full node and from trusted remote API's. If the transaction is fully confirmed, the backend program will run the following validations checks. Check if the incoming transaction has already been processed on the backend tool and on the SXP blockchain Contract ID of the tokens that have been received on the SXPSwap contract. Amount of tokens that have been transferred. Validation of the new SXP mainnet address. Check validations over 3 different BSC/ETH nodes. Once all validations are passed. The backend program will generate a transaction and broadcast it to mainnet to the address that was submitted in the contract. Within this transaction, the vendorField will contain additional details regarding the SXPSwap transaction in the following format: Vendorfield bsc:0x4f7ce4430909fef471f30c4d7c74156bc9df8887c3b0f7d0c50d2085dcada254 The prefix determines where the transaction originated from, either Binance Smart Chain or Ethereum. Adding this note to mainnet transactions will provide transparency to incoming swaps, but it's also for the forging nodes to run their own validations. Security Notices \u00b6 The server that hosts the backend program has several security features in case of failures such as server hacks, server reboot, ddos attacks, DC issues or server maintenance. Swaps can only occur from a specific master address. The forging nodes will only process transactions from this wallet if the data in the vendorField matches with the response from the API's. Meaning that any other transactions sent from this wallet with a wrong address, wrong transaction ID or no vendorField at all, will be denied by the forging nodes. This also means that in case the private keys of this master address are leaked in the public or somehow obtained by a hacker, there is no way to move funds out of this wallet without matching data from SXPSwap. Even if it does contain matched data. Duplicate transactions with the same transaction ID are denied by the network.","title":"Broadcast Procedure"},{"location":"sxpswap/technical-details/security/broadcast-procedure/#phase-2-backend-program-broadcasting-transaction","text":"In the second phase, the backend program listens for new transactions on BEP20/ERC20 SXPSwap contract. The backend program listens to transactions from a local full node and from trusted remote API's. If the transaction is fully confirmed, the backend program will run the following validations checks. Check if the incoming transaction has already been processed on the backend tool and on the SXP blockchain Contract ID of the tokens that have been received on the SXPSwap contract. Amount of tokens that have been transferred. Validation of the new SXP mainnet address. Check validations over 3 different BSC/ETH nodes. Once all validations are passed. The backend program will generate a transaction and broadcast it to mainnet to the address that was submitted in the contract. Within this transaction, the vendorField will contain additional details regarding the SXPSwap transaction in the following format: Vendorfield bsc:0x4f7ce4430909fef471f30c4d7c74156bc9df8887c3b0f7d0c50d2085dcada254 The prefix determines where the transaction originated from, either Binance Smart Chain or Ethereum. Adding this note to mainnet transactions will provide transparency to incoming swaps, but it's also for the forging nodes to run their own validations.","title":"Phase 2 - Backend Program Broadcasting Transaction"},{"location":"sxpswap/technical-details/security/broadcast-procedure/#security-notices","text":"The server that hosts the backend program has several security features in case of failures such as server hacks, server reboot, ddos attacks, DC issues or server maintenance. Swaps can only occur from a specific master address. The forging nodes will only process transactions from this wallet if the data in the vendorField matches with the response from the API's. Meaning that any other transactions sent from this wallet with a wrong address, wrong transaction ID or no vendorField at all, will be denied by the forging nodes. This also means that in case the private keys of this master address are leaked in the public or somehow obtained by a hacker, there is no way to move funds out of this wallet without matching data from SXPSwap. Even if it does contain matched data. Duplicate transactions with the same transaction ID are denied by the network.","title":"Security Notices"},{"location":"sxpswap/technical-details/security/contract-procedure/","text":"Phase 1 - Sending tokens to SXPSwap Contract (BSC/ETH) \u00b6 In order to facilitate a successful migration, the Swipe (SXP) tokens on BEP20/ERC20 are meant to enter a contract and never leave the contract ever again. This is facilitated by a contract on BEP20 and ERC20. The process consists on 2 main functions. 1. The first function \"approve\", which exists on the Swipe (SXP) token contract, this serves for the purpose of approving the SXPSwap contract to move the Swipe tokens over the new SXPSwap Contract. 2. The second function \"transferTokenToContract\", this serves for the purpose of sending the tokens that were previously approved to SXPSwap. Functions on the new contract. The function \"transferTokenToContract\" is only accepted if the following parameters are included. These parameters are: Address of Swipe token. Amount of tokens to be transferred. A valid SXP mainnet address to be entered in string format. If these parameters are missing, the transaction will fail. Validation \u00b6 New Wallet Address Validation \u00b6 There are 4 validation controls for the SXP mainnet address that check for a 34 character address with the S prefix. 1. Validation on the frontend for Metamask users that are using the official SXPSwap tool. 2. Validation on the smart contract to only allow addresses with a certain prefix. 3. Validation on the backend program that sends the mainnet SXP to the new address. 4. Validation by the forging nodes that accept or deny the transaction created by the backend tool. Interacting with the contract directly and entering a wrong address by accident or on purpose will result in loss of funds. There is no way to recover the tokens from a contract and sending new SXP tokens on mainnet is impossible without a valid transaction on the contract side. Notes \u00b6 Other tokens can be sent to the SXPSwap contract. These tokens can not be recovered and will not be accepted by the backend program that broadcasts the swap to the forging delegates. Due to the validation by the backend program and the validation from the forging delegates, trying to send \"fake\" SXP tokens with a correct SXP mainnet address will have no impact on the swap procedure. Disclaimer! Read carefully! Below links will direct you to the contracts on Binance Smart Chain and Ethereum. Warning! Do no interact with the contract directly unless you know what you are doing. Interacting with the contract directly or sending your tokens to the contract without attaching a correct mainnet address will result in losing your SXP tokens. Mainnet \u00b6 BEP20 Token Contract ERC20 Token Contract BEP20 Swap Contract ERC20 Swap Contract Additionally, exchanges are also able to use the Metamask version of the swap. For testnet, this is available under https://swap.testnet.sh For mainnet under https://swap.solar.org Contact us if you wish to receive SXP testnet tokens on BSC Testnet or Ethereum Kovan.","title":"Contract Procedure"},{"location":"sxpswap/technical-details/security/contract-procedure/#phase-1-sending-tokens-to-sxpswap-contract-bsceth","text":"In order to facilitate a successful migration, the Swipe (SXP) tokens on BEP20/ERC20 are meant to enter a contract and never leave the contract ever again. This is facilitated by a contract on BEP20 and ERC20. The process consists on 2 main functions. 1. The first function \"approve\", which exists on the Swipe (SXP) token contract, this serves for the purpose of approving the SXPSwap contract to move the Swipe tokens over the new SXPSwap Contract. 2. The second function \"transferTokenToContract\", this serves for the purpose of sending the tokens that were previously approved to SXPSwap. Functions on the new contract. The function \"transferTokenToContract\" is only accepted if the following parameters are included. These parameters are: Address of Swipe token. Amount of tokens to be transferred. A valid SXP mainnet address to be entered in string format. If these parameters are missing, the transaction will fail.","title":"Phase 1 - Sending tokens to SXPSwap Contract (BSC/ETH)"},{"location":"sxpswap/technical-details/security/contract-procedure/#validation","text":"","title":"Validation"},{"location":"sxpswap/technical-details/security/contract-procedure/#new-wallet-address-validation","text":"There are 4 validation controls for the SXP mainnet address that check for a 34 character address with the S prefix. 1. Validation on the frontend for Metamask users that are using the official SXPSwap tool. 2. Validation on the smart contract to only allow addresses with a certain prefix. 3. Validation on the backend program that sends the mainnet SXP to the new address. 4. Validation by the forging nodes that accept or deny the transaction created by the backend tool. Interacting with the contract directly and entering a wrong address by accident or on purpose will result in loss of funds. There is no way to recover the tokens from a contract and sending new SXP tokens on mainnet is impossible without a valid transaction on the contract side.","title":"New Wallet Address Validation"},{"location":"sxpswap/technical-details/security/contract-procedure/#notes","text":"Other tokens can be sent to the SXPSwap contract. These tokens can not be recovered and will not be accepted by the backend program that broadcasts the swap to the forging delegates. Due to the validation by the backend program and the validation from the forging delegates, trying to send \"fake\" SXP tokens with a correct SXP mainnet address will have no impact on the swap procedure. Disclaimer! Read carefully! Below links will direct you to the contracts on Binance Smart Chain and Ethereum. Warning! Do no interact with the contract directly unless you know what you are doing. Interacting with the contract directly or sending your tokens to the contract without attaching a correct mainnet address will result in losing your SXP tokens.","title":"Notes"},{"location":"sxpswap/technical-details/security/contract-procedure/#mainnet","text":"BEP20 Token Contract ERC20 Token Contract BEP20 Swap Contract ERC20 Swap Contract Additionally, exchanges are also able to use the Metamask version of the swap. For testnet, this is available under https://swap.testnet.sh For mainnet under https://swap.solar.org Contact us if you wish to receive SXP testnet tokens on BSC Testnet or Ethereum Kovan.","title":"Mainnet"},{"location":"sxpswap/technical-details/security/introduction/","text":"Introduction \u00b6 The SXPSwap tool is an entirely decentralized module to facilitate the migration from BEP20/ERC20 to mainnet SXP. SXPSwap focuses on several security features that are important to facilitate a migration on protocol level. Contract Procedure Broadcast Procedure Mainnet Procedure","title":"Introduction"},{"location":"sxpswap/technical-details/security/introduction/#introduction","text":"The SXPSwap tool is an entirely decentralized module to facilitate the migration from BEP20/ERC20 to mainnet SXP. SXPSwap focuses on several security features that are important to facilitate a migration on protocol level. Contract Procedure Broadcast Procedure Mainnet Procedure","title":"Introduction"},{"location":"sxpswap/technical-details/security/mainnet-procedure/","text":"Phase 3 - Processing the Swaps \u00b6 Phase 3 relates to transactions from the Swap Master Address to the new SXP mainnet address. All nodes on mainnet are equipped with a plugin that validates and processes transactions sent by the Swap Master Address. Vendorfield Swaps can only occur from a specific master address. The forging nodes will only process transactions from this wallet if the data in the vendorField matches with the response from the API's. Meaning that any other transactions sent from this wallet with a wrong address, wrong transaction ID or no vendorField at all, will be denied by the forging nodes. This also means that in case the private keys of this master address are leaked in the public or somehow obtained by a hacker, there is no way to move funds out of this wallet without matching data from SXPSwap. Even if it does contain matched data. Duplicate transactions with the same transaction ID are denied by the network. The plugins on the forging, relay and seed nodes are equiped with plugins that request data from several API's to verify transactions that are sent from the Swap Master Address. Nodes can choose to use the default remote API or use a local full node to request data from the BSC or ETH chain. The node validates the following data to either accept or deny the transaction. 1. Transaction ID with a minimum amount of confirmations. 2. Match the new wallet address with the wallet address provided in the contract. 3. Match the amount that is being sent to the new wallet with the amount that was transferred to the contract. 4. Validate if the SXPSwap contract has the right contract ID for SXP. 5. Verify that the transaction hasn't been executed earlier. All nodes including forging nodes, relays, and seed peers will have to validate this transaction in order to accept the block. Nodes that have latency issues, bad or manipulated API or wrong data will fork from the network and from the seed peers.","title":"Mainnet Procedure"},{"location":"sxpswap/technical-details/security/mainnet-procedure/#phase-3-processing-the-swaps","text":"Phase 3 relates to transactions from the Swap Master Address to the new SXP mainnet address. All nodes on mainnet are equipped with a plugin that validates and processes transactions sent by the Swap Master Address. Vendorfield Swaps can only occur from a specific master address. The forging nodes will only process transactions from this wallet if the data in the vendorField matches with the response from the API's. Meaning that any other transactions sent from this wallet with a wrong address, wrong transaction ID or no vendorField at all, will be denied by the forging nodes. This also means that in case the private keys of this master address are leaked in the public or somehow obtained by a hacker, there is no way to move funds out of this wallet without matching data from SXPSwap. Even if it does contain matched data. Duplicate transactions with the same transaction ID are denied by the network. The plugins on the forging, relay and seed nodes are equiped with plugins that request data from several API's to verify transactions that are sent from the Swap Master Address. Nodes can choose to use the default remote API or use a local full node to request data from the BSC or ETH chain. The node validates the following data to either accept or deny the transaction. 1. Transaction ID with a minimum amount of confirmations. 2. Match the new wallet address with the wallet address provided in the contract. 3. Match the amount that is being sent to the new wallet with the amount that was transferred to the contract. 4. Validate if the SXPSwap contract has the right contract ID for SXP. 5. Verify that the transaction hasn't been executed earlier. All nodes including forging nodes, relays, and seed peers will have to validate this transaction in order to accept the block. Nodes that have latency issues, bad or manipulated API or wrong data will fork from the network and from the seed peers.","title":"Phase 3 - Processing the Swaps"},{"location":"sxpswap/users/metamask/","text":"Introduction \u00b6 Disclaimer! Please read the information on this page carefully. You need a Solar Wallet address to perform the swap from ERC20/BEP20 SXP to Mainnet SXP. Visit our official website to download the latest Solar Desktop Wallet . Swap Procedure \u00b6 This guide is meant for users that have their ERC20/BEP20 SXP tokens in the Metamask Wallet. Read the instructions below to swap your ERC20/BEP20 SXP tokens to Mainnet SXP coins: Create a mainnet address using the Solar Desktop Wallet or click here to learn more about creating wallets . Make sure to securely store your passphrase with additional backups. Do not share this passphrase with anyone. Make sure to have the SXP tokens (BEP20 or ERC20) in your MetaMask wallet with gas to cover the fees for the swap. Visit the Swap Website and make sure that you are visiting the right domain. https://swap.solar.org Connect to your MetaMask Wallet and click next. Select the network where you are holding your SXP tokens and click next. Enter the amount of SXP you wish to swap. You can try with a low amount and swap more later. On the next page, enter your wallet address from the Solar Desktop Wallet. The mainnet SXP address starts with an S and is 34 characters long. Click next after you've filled in your SXP mainnet wallet address. From this point, it won't be possible to recover your assets if you fill in the wrong address. Double check the details on this page and click on the \"Approve Swap\" button. You will now be asked to confirm the transactions which sends the tokens to a specialized contract. Wait. Do not close this page. You are not done yet. A new button will be available. Click on the button that says \"Swap Now\" and finalize the swap by confirming and signing the Swap transaction. The swap is done. You can now view the transaction on the block explorer. The new SXP mainnet coins will arrive in your wallet within 30-minutes after receiving the required amount of confirmations.","title":"Swap/Migration for MetaMask users"},{"location":"sxpswap/users/metamask/#introduction","text":"Disclaimer! Please read the information on this page carefully. You need a Solar Wallet address to perform the swap from ERC20/BEP20 SXP to Mainnet SXP. Visit our official website to download the latest Solar Desktop Wallet .","title":"Introduction"},{"location":"sxpswap/users/metamask/#swap-procedure","text":"This guide is meant for users that have their ERC20/BEP20 SXP tokens in the Metamask Wallet. Read the instructions below to swap your ERC20/BEP20 SXP tokens to Mainnet SXP coins: Create a mainnet address using the Solar Desktop Wallet or click here to learn more about creating wallets . Make sure to securely store your passphrase with additional backups. Do not share this passphrase with anyone. Make sure to have the SXP tokens (BEP20 or ERC20) in your MetaMask wallet with gas to cover the fees for the swap. Visit the Swap Website and make sure that you are visiting the right domain. https://swap.solar.org Connect to your MetaMask Wallet and click next. Select the network where you are holding your SXP tokens and click next. Enter the amount of SXP you wish to swap. You can try with a low amount and swap more later. On the next page, enter your wallet address from the Solar Desktop Wallet. The mainnet SXP address starts with an S and is 34 characters long. Click next after you've filled in your SXP mainnet wallet address. From this point, it won't be possible to recover your assets if you fill in the wrong address. Double check the details on this page and click on the \"Approve Swap\" button. You will now be asked to confirm the transactions which sends the tokens to a specialized contract. Wait. Do not close this page. You are not done yet. A new button will be available. Click on the button that says \"Swap Now\" and finalize the swap by confirming and signing the Swap transaction. The swap is done. You can now view the transaction on the block explorer. The new SXP mainnet coins will arrive in your wallet within 30-minutes after receiving the required amount of confirmations.","title":"Swap Procedure"},{"location":"sxpswap/users/trust-wallet/","text":"Introduction \u00b6 Coming soon The implementation for using the swap bridge with the Trust Wallet is currently being implemented and will be available in early Q2.","title":"Swap/Migration for Trust Wallet users"},{"location":"sxpswap/users/trust-wallet/#introduction","text":"Coming soon The implementation for using the swap bridge with the Trust Wallet is currently being implemented and will be available in early Q2.","title":"Introduction"}]}